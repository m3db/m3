// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package rpc

import (
	"bytes"
	"database/sql/driver"
	"errors"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type TimeType int64

const (
	TimeType_UNIX_SECONDS      TimeType = 0
	TimeType_UNIX_MICROSECONDS TimeType = 1
	TimeType_UNIX_MILLISECONDS TimeType = 2
	TimeType_UNIX_NANOSECONDS  TimeType = 3
)

func (p TimeType) String() string {
	switch p {
	case TimeType_UNIX_SECONDS:
		return "UNIX_SECONDS"
	case TimeType_UNIX_MICROSECONDS:
		return "UNIX_MICROSECONDS"
	case TimeType_UNIX_MILLISECONDS:
		return "UNIX_MILLISECONDS"
	case TimeType_UNIX_NANOSECONDS:
		return "UNIX_NANOSECONDS"
	}
	return "<UNSET>"
}

func TimeTypeFromString(s string) (TimeType, error) {
	switch s {
	case "UNIX_SECONDS":
		return TimeType_UNIX_SECONDS, nil
	case "UNIX_MICROSECONDS":
		return TimeType_UNIX_MICROSECONDS, nil
	case "UNIX_MILLISECONDS":
		return TimeType_UNIX_MILLISECONDS, nil
	case "UNIX_NANOSECONDS":
		return TimeType_UNIX_NANOSECONDS, nil
	}
	return TimeType(0), fmt.Errorf("not a valid TimeType string")
}

func TimeTypePtr(v TimeType) *TimeType { return &v }

func (p TimeType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TimeType) UnmarshalText(text []byte) error {
	q, err := TimeTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TimeType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TimeType(v)
	return nil
}

func (p *TimeType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type ErrorType int64

const (
	ErrorType_INTERNAL_ERROR ErrorType = 0
	ErrorType_BAD_REQUEST    ErrorType = 1
)

func (p ErrorType) String() string {
	switch p {
	case ErrorType_INTERNAL_ERROR:
		return "INTERNAL_ERROR"
	case ErrorType_BAD_REQUEST:
		return "BAD_REQUEST"
	}
	return "<UNSET>"
}

func ErrorTypeFromString(s string) (ErrorType, error) {
	switch s {
	case "INTERNAL_ERROR":
		return ErrorType_INTERNAL_ERROR, nil
	case "BAD_REQUEST":
		return ErrorType_BAD_REQUEST, nil
	}
	return ErrorType(0), fmt.Errorf("not a valid ErrorType string")
}

func ErrorTypePtr(v ErrorType) *ErrorType { return &v }

func (p ErrorType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ErrorType) UnmarshalText(text []byte) error {
	q, err := ErrorTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ErrorType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ErrorType(v)
	return nil
}

func (p *ErrorType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Attributes:
//  - Type
//  - Message
type Error struct {
	Type    ErrorType `thrift:"type,1,required" db:"type" json:"type"`
	Message string    `thrift:"message,2,required" db:"message" json:"message"`
}

func NewError() *Error {
	return &Error{
		Type: 0,
	}
}

func (p *Error) GetType() ErrorType {
	return p.Type
}

func (p *Error) GetMessage() string {
	return p.Message
}
func (p *Error) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetType bool = false
	var issetMessage bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetType = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetMessage = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetType {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"))
	}
	if !issetMessage {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Message is not set"))
	}
	return nil
}

func (p *Error) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := ErrorType(v)
		p.Type = temp
	}
	return nil
}

func (p *Error) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *Error) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Error"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Error) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.Type)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err)
	}
	return err
}

func (p *Error) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("message", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
	}
	if err := oprot.WriteString(string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
	}
	return err
}

func (p *Error) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Error(%+v)", *p)
}

func (p *Error) Error() string {
	return p.String()
}

// Attributes:
//  - Errors
type WriteBatchErrors struct {
	Errors []*WriteBatchError `thrift:"errors,1,required" db:"errors" json:"errors"`
}

func NewWriteBatchErrors() *WriteBatchErrors {
	return &WriteBatchErrors{}
}

func (p *WriteBatchErrors) GetErrors() []*WriteBatchError {
	return p.Errors
}
func (p *WriteBatchErrors) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetErrors bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetErrors = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetErrors {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Errors is not set"))
	}
	return nil
}

func (p *WriteBatchErrors) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteBatchError, 0, size)
	p.Errors = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &WriteBatchError{}
		if err := _elem0.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.Errors = append(p.Errors, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchErrors) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("WriteBatchErrors"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchErrors) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("errors", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errors: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Errors)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Errors {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errors: ", p), err)
	}
	return err
}

func (p *WriteBatchErrors) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchErrors(%+v)", *p)
}

func (p *WriteBatchErrors) Error() string {
	return p.String()
}

// Attributes:
//  - Ok
//  - Status
type HealthResult_ struct {
	Ok     bool   `thrift:"ok,1,required" db:"ok" json:"ok"`
	Status string `thrift:"status,2,required" db:"status" json:"status"`
}

func NewHealthResult_() *HealthResult_ {
	return &HealthResult_{}
}

func (p *HealthResult_) GetOk() bool {
	return p.Ok
}

func (p *HealthResult_) GetStatus() string {
	return p.Status
}
func (p *HealthResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetOk bool = false
	var issetStatus bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetOk = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetStatus = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetOk {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ok is not set"))
	}
	if !issetStatus {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Status is not set"))
	}
	return nil
}

func (p *HealthResult_) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Ok = v
	}
	return nil
}

func (p *HealthResult_) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Status = v
	}
	return nil
}

func (p *HealthResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("HealthResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *HealthResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ok", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ok: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.Ok)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ok (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ok: ", p), err)
	}
	return err
}

func (p *HealthResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("status", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err)
	}
	if err := oprot.WriteString(string(p.Status)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err)
	}
	return err
}

func (p *HealthResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("HealthResult_(%+v)", *p)
}

// Attributes:
//  - ID
//  - Datapoint
type WriteRequest struct {
	ID        string     `thrift:"id,1,required" db:"id" json:"id"`
	Datapoint *Datapoint `thrift:"datapoint,2,required" db:"datapoint" json:"datapoint"`
}

func NewWriteRequest() *WriteRequest {
	return &WriteRequest{}
}

func (p *WriteRequest) GetID() string {
	return p.ID
}

var WriteRequest_Datapoint_DEFAULT *Datapoint

func (p *WriteRequest) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteRequest_Datapoint_DEFAULT
	}
	return p.Datapoint
}
func (p *WriteRequest) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false
	var issetDatapoint bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetID = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetDatapoint = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"))
	}
	if !issetDatapoint {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"))
	}
	return nil
}

func (p *WriteRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteRequest) ReadField2(iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampType: 0,
	}
	if err := p.Datapoint.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("WriteRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteString(string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *WriteRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datapoint", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:datapoint: ", p), err)
	}
	return err
}

func (p *WriteRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteRequest(%+v)", *p)
}

// Attributes:
//  - Elements
type WriteBatchRequest struct {
	Elements []*WriteRequest `thrift:"elements,1,required" db:"elements" json:"elements"`
}

func NewWriteBatchRequest() *WriteBatchRequest {
	return &WriteBatchRequest{}
}

func (p *WriteBatchRequest) GetElements() []*WriteRequest {
	return p.Elements
}
func (p *WriteBatchRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetElements = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"))
	}
	return nil
}

func (p *WriteBatchRequest) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteRequest, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem1 := &WriteRequest{}
		if err := _elem1.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem1), err)
		}
		p.Elements = append(p.Elements, _elem1)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("WriteBatchRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *WriteBatchRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRequest(%+v)", *p)
}

// Attributes:
//  - Index
//  - Err
type WriteBatchError struct {
	Index int64  `thrift:"index,1,required" db:"index" json:"index"`
	Err   *Error `thrift:"err,2,required" db:"err" json:"err"`
}

func NewWriteBatchError() *WriteBatchError {
	return &WriteBatchError{}
}

func (p *WriteBatchError) GetIndex() int64 {
	return p.Index
}

var WriteBatchError_Err_DEFAULT *Error

func (p *WriteBatchError) GetErr() *Error {
	if !p.IsSetErr() {
		return WriteBatchError_Err_DEFAULT
	}
	return p.Err
}
func (p *WriteBatchError) IsSetErr() bool {
	return p.Err != nil
}

func (p *WriteBatchError) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIndex bool = false
	var issetErr bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetIndex = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetErr = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIndex {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Index is not set"))
	}
	if !issetErr {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Err is not set"))
	}
	return nil
}

func (p *WriteBatchError) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Index = v
	}
	return nil
}

func (p *WriteBatchError) ReadField2(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *WriteBatchError) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("WriteBatchError"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchError) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("index", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:index: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.Index)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.index (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:index: ", p), err)
	}
	return err
}

func (p *WriteBatchError) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err)
	}
	if err := p.Err.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err)
	}
	return err
}

func (p *WriteBatchError) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchError(%+v)", *p)
}

// Attributes:
//  - RangeStart
//  - RangeEnd
//  - ID
//  - RangeType
//  - ResultTimeType
type FetchRequest struct {
	RangeStart     int64    `thrift:"rangeStart,1,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd       int64    `thrift:"rangeEnd,2,required" db:"rangeEnd" json:"rangeEnd"`
	ID             string   `thrift:"id,3,required" db:"id" json:"id"`
	RangeType      TimeType `thrift:"rangeType,4" db:"rangeType" json:"rangeType,omitempty"`
	ResultTimeType TimeType `thrift:"resultTimeType,5" db:"resultTimeType" json:"resultTimeType,omitempty"`
}

func NewFetchRequest() *FetchRequest {
	return &FetchRequest{
		RangeType: 0,

		ResultTimeType: 0,
	}
}

func (p *FetchRequest) GetRangeStart() int64 {
	return p.RangeStart
}

func (p *FetchRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}

func (p *FetchRequest) GetID() string {
	return p.ID
}

var FetchRequest_RangeType_DEFAULT TimeType = 0

func (p *FetchRequest) GetRangeType() TimeType {
	return p.RangeType
}

var FetchRequest_ResultTimeType_DEFAULT TimeType = 0

func (p *FetchRequest) GetResultTimeType() TimeType {
	return p.ResultTimeType
}
func (p *FetchRequest) IsSetRangeType() bool {
	return p.RangeType != FetchRequest_RangeType_DEFAULT
}

func (p *FetchRequest) IsSetResultTimeType() bool {
	return p.ResultTimeType != FetchRequest_ResultTimeType_DEFAULT
}

func (p *FetchRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRangeStart bool = false
	var issetRangeEnd bool = false
	var issetID bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetRangeStart = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetRangeEnd = true
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
			issetID = true
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRangeStart {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"))
	}
	if !issetRangeEnd {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"))
	}
	if !issetID {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"))
	}
	return nil
}

func (p *FetchRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchRequest) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchRequest) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *FetchRequest) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *FetchRequest) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TimeType(v)
		p.ResultTimeType = temp
	}
	return nil
}

func (p *FetchRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
		if err := p.writeField3(oprot); err != nil {
			return err
		}
		if err := p.writeField4(oprot); err != nil {
			return err
		}
		if err := p.writeField5(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rangeStart", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rangeEnd", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:id: ", p), err)
	}
	if err := oprot.WriteString(string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:id: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin("rangeType", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rangeType: ", p), err)
		}
	}
	return err
}

func (p *FetchRequest) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetResultTimeType() {
		if err := oprot.WriteFieldBegin("resultTimeType", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:resultTimeType: ", p), err)
		}
		if err := oprot.WriteI32(int32(p.ResultTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.resultTimeType (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:resultTimeType: ", p), err)
		}
	}
	return err
}

func (p *FetchRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRequest(%+v)", *p)
}

// Attributes:
//  - Datapoints
type FetchResult_ struct {
	Datapoints []*Datapoint `thrift:"datapoints,1,required" db:"datapoints" json:"datapoints"`
}

func NewFetchResult_() *FetchResult_ {
	return &FetchResult_{}
}

func (p *FetchResult_) GetDatapoints() []*Datapoint {
	return p.Datapoints
}
func (p *FetchResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDatapoints bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetDatapoints = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDatapoints {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoints is not set"))
	}
	return nil
}

func (p *FetchResult_) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Datapoint, 0, size)
	p.Datapoints = tSlice
	for i := 0; i < size; i++ {
		_elem2 := &Datapoint{
			TimestampType: 0,
		}
		if err := _elem2.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
		}
		p.Datapoints = append(p.Datapoints, _elem2)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datapoints", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:datapoints: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Datapoints)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Datapoints {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:datapoints: ", p), err)
	}
	return err
}

func (p *FetchResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchResult_(%+v)", *p)
}

// Attributes:
//  - Timestamp
//  - Value
//  - Annotation
//  - TimestampType
type Datapoint struct {
	Timestamp     int64    `thrift:"timestamp,1,required" db:"timestamp" json:"timestamp"`
	Value         float64  `thrift:"value,2,required" db:"value" json:"value"`
	Annotation    []byte   `thrift:"annotation,3" db:"annotation" json:"annotation,omitempty"`
	TimestampType TimeType `thrift:"timestampType,4" db:"timestampType" json:"timestampType,omitempty"`
}

func NewDatapoint() *Datapoint {
	return &Datapoint{
		TimestampType: 0,
	}
}

func (p *Datapoint) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *Datapoint) GetValue() float64 {
	return p.Value
}

var Datapoint_Annotation_DEFAULT []byte

func (p *Datapoint) GetAnnotation() []byte {
	return p.Annotation
}

var Datapoint_TimestampType_DEFAULT TimeType = 0

func (p *Datapoint) GetTimestampType() TimeType {
	return p.TimestampType
}
func (p *Datapoint) IsSetAnnotation() bool {
	return p.Annotation != nil
}

func (p *Datapoint) IsSetTimestampType() bool {
	return p.TimestampType != Datapoint_TimestampType_DEFAULT
}

func (p *Datapoint) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTimestamp bool = false
	var issetValue bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetTimestamp = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetValue = true
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTimestamp {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Timestamp is not set"))
	}
	if !issetValue {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"))
	}
	return nil
}

func (p *Datapoint) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *Datapoint) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *Datapoint) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Annotation = v
	}
	return nil
}

func (p *Datapoint) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TimeType(v)
		p.TimestampType = temp
	}
	return nil
}

func (p *Datapoint) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Datapoint"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
		if err := p.writeField3(oprot); err != nil {
			return err
		}
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Datapoint) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timestamp: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.timestamp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timestamp: ", p), err)
	}
	return err
}

func (p *Datapoint) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
	}
	if err := oprot.WriteDouble(float64(p.Value)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
	}
	return err
}

func (p *Datapoint) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetAnnotation() {
		if err := oprot.WriteFieldBegin("annotation", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:annotation: ", p), err)
		}
		if err := oprot.WriteBinary(p.Annotation); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.annotation (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:annotation: ", p), err)
		}
	}
	return err
}

func (p *Datapoint) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestampType() {
		if err := oprot.WriteFieldBegin("timestampType", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timestampType: ", p), err)
		}
		if err := oprot.WriteI32(int32(p.TimestampType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestampType (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timestampType: ", p), err)
		}
	}
	return err
}

func (p *Datapoint) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Datapoint(%+v)", *p)
}

// Attributes:
//  - RangeStart
//  - RangeEnd
//  - Ids
//  - RangeType
type FetchRawBatchRequest struct {
	RangeStart int64    `thrift:"rangeStart,1,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd   int64    `thrift:"rangeEnd,2,required" db:"rangeEnd" json:"rangeEnd"`
	Ids        []string `thrift:"ids,3,required" db:"ids" json:"ids"`
	RangeType  TimeType `thrift:"rangeType,4" db:"rangeType" json:"rangeType,omitempty"`
}

func NewFetchRawBatchRequest() *FetchRawBatchRequest {
	return &FetchRawBatchRequest{
		RangeType: 0,
	}
}

func (p *FetchRawBatchRequest) GetRangeStart() int64 {
	return p.RangeStart
}

func (p *FetchRawBatchRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}

func (p *FetchRawBatchRequest) GetIds() []string {
	return p.Ids
}

var FetchRawBatchRequest_RangeType_DEFAULT TimeType = 0

func (p *FetchRawBatchRequest) GetRangeType() TimeType {
	return p.RangeType
}
func (p *FetchRawBatchRequest) IsSetRangeType() bool {
	return p.RangeType != FetchRawBatchRequest_RangeType_DEFAULT
}

func (p *FetchRawBatchRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRangeStart bool = false
	var issetRangeEnd bool = false
	var issetIds bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetRangeStart = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetRangeEnd = true
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
			issetIds = true
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRangeStart {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"))
	}
	if !issetRangeEnd {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"))
	}
	if !issetIds {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ids is not set"))
	}
	return nil
}

func (p *FetchRawBatchRequest) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchRawBatchRequest) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchRawBatchRequest) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.Ids = tSlice
	for i := 0; i < size; i++ {
		var _elem3 string
		if v, err := iprot.ReadString(); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem3 = v
		}
		p.Ids = append(p.Ids, _elem3)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchRawBatchRequest) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *FetchRawBatchRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchRawBatchRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
		if err := p.writeField3(oprot); err != nil {
			return err
		}
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRawBatchRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rangeStart", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchRawBatchRequest) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rangeEnd", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchRawBatchRequest) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("ids", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:ids: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Ids)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Ids {
		if err := oprot.WriteString(string(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:ids: ", p), err)
	}
	return err
}

func (p *FetchRawBatchRequest) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin("rangeType", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rangeType: ", p), err)
		}
	}
	return err
}

func (p *FetchRawBatchRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRawBatchRequest(%+v)", *p)
}

// Attributes:
//  - Elements
type FetchRawBatchResult_ struct {
	Elements []*FetchRawResult_ `thrift:"elements,1,required" db:"elements" json:"elements"`
}

func NewFetchRawBatchResult_() *FetchRawBatchResult_ {
	return &FetchRawBatchResult_{}
}

func (p *FetchRawBatchResult_) GetElements() []*FetchRawResult_ {
	return p.Elements
}
func (p *FetchRawBatchResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetElements = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"))
	}
	return nil
}

func (p *FetchRawBatchResult_) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FetchRawResult_, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &FetchRawResult_{}
		if err := _elem4.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.Elements = append(p.Elements, _elem4)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchRawBatchResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchRawBatchResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRawBatchResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *FetchRawBatchResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRawBatchResult_(%+v)", *p)
}

// Attributes:
//  - Head
//  - Tail
type Segment struct {
	Head []byte `thrift:"head,1,required" db:"head" json:"head"`
	Tail []byte `thrift:"tail,2,required" db:"tail" json:"tail"`
}

func NewSegment() *Segment {
	return &Segment{}
}

func (p *Segment) GetHead() []byte {
	return p.Head
}

func (p *Segment) GetTail() []byte {
	return p.Tail
}
func (p *Segment) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetHead bool = false
	var issetTail bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetHead = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
			issetTail = true
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetHead {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Head is not set"))
	}
	if !issetTail {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tail is not set"))
	}
	return nil
}

func (p *Segment) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Head = v
	}
	return nil
}

func (p *Segment) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Tail = v
	}
	return nil
}

func (p *Segment) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Segment"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Segment) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("head", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:head: ", p), err)
	}
	if err := oprot.WriteBinary(p.Head); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.head (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:head: ", p), err)
	}
	return err
}

func (p *Segment) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tail", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tail: ", p), err)
	}
	if err := oprot.WriteBinary(p.Tail); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tail (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tail: ", p), err)
	}
	return err
}

func (p *Segment) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Segment(%+v)", *p)
}

// Attributes:
//  - Merged
//  - Unmerged
type Segments struct {
	Merged   *Segment   `thrift:"merged,1" db:"merged" json:"merged,omitempty"`
	Unmerged []*Segment `thrift:"unmerged,2" db:"unmerged" json:"unmerged,omitempty"`
}

func NewSegments() *Segments {
	return &Segments{}
}

var Segments_Merged_DEFAULT *Segment

func (p *Segments) GetMerged() *Segment {
	if !p.IsSetMerged() {
		return Segments_Merged_DEFAULT
	}
	return p.Merged
}

var Segments_Unmerged_DEFAULT []*Segment

func (p *Segments) GetUnmerged() []*Segment {
	return p.Unmerged
}
func (p *Segments) IsSetMerged() bool {
	return p.Merged != nil
}

func (p *Segments) IsSetUnmerged() bool {
	return p.Unmerged != nil
}

func (p *Segments) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Segments) ReadField1(iprot thrift.TProtocol) error {
	p.Merged = &Segment{}
	if err := p.Merged.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Merged), err)
	}
	return nil
}

func (p *Segments) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Segment, 0, size)
	p.Unmerged = tSlice
	for i := 0; i < size; i++ {
		_elem5 := &Segment{}
		if err := _elem5.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem5), err)
		}
		p.Unmerged = append(p.Unmerged, _elem5)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Segments) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Segments"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Segments) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetMerged() {
		if err := oprot.WriteFieldBegin("merged", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:merged: ", p), err)
		}
		if err := p.Merged.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Merged), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:merged: ", p), err)
		}
	}
	return err
}

func (p *Segments) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetUnmerged() {
		if err := oprot.WriteFieldBegin("unmerged", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:unmerged: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Unmerged)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Unmerged {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:unmerged: ", p), err)
		}
	}
	return err
}

func (p *Segments) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Segments(%+v)", *p)
}

// Attributes:
//  - Segments
//  - Err
type FetchRawResult_ struct {
	Segments []*Segments `thrift:"segments,1,required" db:"segments" json:"segments"`
	Err      *Error      `thrift:"err,2" db:"err" json:"err,omitempty"`
}

func NewFetchRawResult_() *FetchRawResult_ {
	return &FetchRawResult_{}
}

func (p *FetchRawResult_) GetSegments() []*Segments {
	return p.Segments
}

var FetchRawResult__Err_DEFAULT *Error

func (p *FetchRawResult_) GetErr() *Error {
	if !p.IsSetErr() {
		return FetchRawResult__Err_DEFAULT
	}
	return p.Err
}
func (p *FetchRawResult_) IsSetErr() bool {
	return p.Err != nil
}

func (p *FetchRawResult_) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetSegments bool = false

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
			issetSegments = true
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetSegments {
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Segments is not set"))
	}
	return nil
}

func (p *FetchRawResult_) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Segments, 0, size)
	p.Segments = tSlice
	for i := 0; i < size; i++ {
		_elem6 := &Segments{}
		if err := _elem6.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem6), err)
		}
		p.Segments = append(p.Segments, _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchRawResult_) ReadField2(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *FetchRawResult_) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("FetchRawResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRawResult_) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("segments", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:segments: ", p), err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Segments)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Segments {
		if err := v.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:segments: ", p), err)
	}
	return err
}

func (p *FetchRawResult_) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err)
		}
	}
	return err
}

func (p *FetchRawResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRawResult_(%+v)", *p)
}

type Node interface {
	Health() (r *HealthResult_, err error)
	// Parameters:
	//  - Req
	Write(req *WriteRequest) (err error)
	// Parameters:
	//  - Req
	WriteBatch(req *WriteBatchRequest) (err error)
	// Parameters:
	//  - Req
	Fetch(req *FetchRequest) (r *FetchResult_, err error)
	// Parameters:
	//  - Req
	FetchRawBatch(req *FetchRawBatchRequest) (r *FetchRawBatchResult_, err error)
}

type NodeClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewNodeClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *NodeClient {
	return &NodeClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewNodeClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *NodeClient {
	return &NodeClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

func (p *NodeClient) Health() (r *HealthResult_, err error) {
	if err = p.sendHealth(); err != nil {
		return
	}
	return p.recvHealth()
}

func (p *NodeClient) sendHealth() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("health", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := NodeHealthArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NodeClient) recvHealth() (value *HealthResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "health" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "health failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "health failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "health failed: invalid message type")
		return
	}
	result := NodeHealthResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *NodeClient) Write(req *WriteRequest) (err error) {
	if err = p.sendWrite(req); err != nil {
		return
	}
	return p.recvWrite()
}

func (p *NodeClient) sendWrite(req *WriteRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("write", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := NodeWriteArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NodeClient) recvWrite() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "write" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "write failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "write failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error9 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error10 error
		error10, err = error9.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error10
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "write failed: invalid message type")
		return
	}
	result := NodeWriteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	return
}

// Parameters:
//  - Req
func (p *NodeClient) WriteBatch(req *WriteBatchRequest) (err error) {
	if err = p.sendWriteBatch(req); err != nil {
		return
	}
	return p.recvWriteBatch()
}

func (p *NodeClient) sendWriteBatch(req *WriteBatchRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("writeBatch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := NodeWriteBatchArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NodeClient) recvWriteBatch() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "writeBatch" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "writeBatch failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "writeBatch failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "writeBatch failed: invalid message type")
		return
	}
	result := NodeWriteBatchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	return
}

// Parameters:
//  - Req
func (p *NodeClient) Fetch(req *FetchRequest) (r *FetchResult_, err error) {
	if err = p.sendFetch(req); err != nil {
		return
	}
	return p.recvFetch()
}

func (p *NodeClient) sendFetch(req *FetchRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("fetch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := NodeFetchArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NodeClient) recvFetch() (value *FetchResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "fetch" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "fetch failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "fetch failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error13 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error14 error
		error14, err = error13.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error14
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "fetch failed: invalid message type")
		return
	}
	result := NodeFetchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *NodeClient) FetchRawBatch(req *FetchRawBatchRequest) (r *FetchRawBatchResult_, err error) {
	if err = p.sendFetchRawBatch(req); err != nil {
		return
	}
	return p.recvFetchRawBatch()
}

func (p *NodeClient) sendFetchRawBatch(req *FetchRawBatchRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("fetchRawBatch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := NodeFetchRawBatchArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *NodeClient) recvFetchRawBatch() (value *FetchRawBatchResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "fetchRawBatch" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "fetchRawBatch failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "fetchRawBatch failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "fetchRawBatch failed: invalid message type")
		return
	}
	result := NodeFetchRawBatchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	value = result.GetSuccess()
	return
}

type NodeProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Node
}

func (p *NodeProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *NodeProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *NodeProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewNodeProcessor(handler Node) *NodeProcessor {

	self17 := &NodeProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self17.processorMap["health"] = &nodeProcessorHealth{handler: handler}
	self17.processorMap["write"] = &nodeProcessorWrite{handler: handler}
	self17.processorMap["writeBatch"] = &nodeProcessorWriteBatch{handler: handler}
	self17.processorMap["fetch"] = &nodeProcessorFetch{handler: handler}
	self17.processorMap["fetchRawBatch"] = &nodeProcessorFetchRawBatch{handler: handler}
	return self17
}

func (p *NodeProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x18 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x18.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x18

}

type nodeProcessorHealth struct {
	handler Node
}

func (p *nodeProcessorHealth) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NodeHealthArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("health", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NodeHealthResult{}
	var retval *HealthResult_
	var err2 error
	if retval, err2 = p.handler.Health(); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing health: "+err2.Error())
			oprot.WriteMessageBegin("health", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("health", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nodeProcessorWrite struct {
	handler Node
}

func (p *nodeProcessorWrite) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NodeWriteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("write", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NodeWriteResult{}
	var err2 error
	if err2 = p.handler.Write(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing write: "+err2.Error())
			oprot.WriteMessageBegin("write", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("write", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nodeProcessorWriteBatch struct {
	handler Node
}

func (p *nodeProcessorWriteBatch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NodeWriteBatchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("writeBatch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NodeWriteBatchResult{}
	var err2 error
	if err2 = p.handler.WriteBatch(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *WriteBatchErrors:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeBatch: "+err2.Error())
			oprot.WriteMessageBegin("writeBatch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("writeBatch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nodeProcessorFetch struct {
	handler Node
}

func (p *nodeProcessorFetch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NodeFetchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NodeFetchResult{}
	var retval *FetchResult_
	var err2 error
	if retval, err2 = p.handler.Fetch(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetch: "+err2.Error())
			oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("fetch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type nodeProcessorFetchRawBatch struct {
	handler Node
}

func (p *nodeProcessorFetchRawBatch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NodeFetchRawBatchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("fetchRawBatch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := NodeFetchRawBatchResult{}
	var retval *FetchRawBatchResult_
	var err2 error
	if retval, err2 = p.handler.FetchRawBatch(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchRawBatch: "+err2.Error())
			oprot.WriteMessageBegin("fetchRawBatch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("fetchRawBatch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type NodeHealthArgs struct {
}

func NewNodeHealthArgs() *NodeHealthArgs {
	return &NodeHealthArgs{}
}

func (p *NodeHealthArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeHealthArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("health_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeHealthArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeHealthArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Err
type NodeHealthResult struct {
	Success *HealthResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *Error         `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeHealthResult() *NodeHealthResult {
	return &NodeHealthResult{}
}

var NodeHealthResult_Success_DEFAULT *HealthResult_

func (p *NodeHealthResult) GetSuccess() *HealthResult_ {
	if !p.IsSetSuccess() {
		return NodeHealthResult_Success_DEFAULT
	}
	return p.Success
}

var NodeHealthResult_Err_DEFAULT *Error

func (p *NodeHealthResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeHealthResult_Err_DEFAULT
	}
	return p.Err
}
func (p *NodeHealthResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeHealthResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeHealthResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeHealthResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &HealthResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeHealthResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeHealthResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("health_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(oprot); err != nil {
			return err
		}
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeHealthResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeHealthResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeHealthResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeHealthResult(%+v)", *p)
}

// Attributes:
//  - Req
type NodeWriteArgs struct {
	Req *WriteRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteArgs() *NodeWriteArgs {
	return &NodeWriteArgs{}
}

var NodeWriteArgs_Req_DEFAULT *WriteRequest

func (p *NodeWriteArgs) GetReq() *WriteRequest {
	if !p.IsSetReq() {
		return NodeWriteArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *NodeWriteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &WriteRequest{}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("write_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteArgs(%+v)", *p)
}

// Attributes:
//  - Err
type NodeWriteResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteResult() *NodeWriteResult {
	return &NodeWriteResult{}
}

var NodeWriteResult_Err_DEFAULT *Error

func (p *NodeWriteResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeWriteResult_Err_DEFAULT
	}
	return p.Err
}
func (p *NodeWriteResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("write_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteResult(%+v)", *p)
}

// Attributes:
//  - Req
type NodeWriteBatchArgs struct {
	Req *WriteBatchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteBatchArgs() *NodeWriteBatchArgs {
	return &NodeWriteBatchArgs{}
}

var NodeWriteBatchArgs_Req_DEFAULT *WriteBatchRequest

func (p *NodeWriteBatchArgs) GetReq() *WriteBatchRequest {
	if !p.IsSetReq() {
		return NodeWriteBatchArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *NodeWriteBatchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteBatchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &WriteBatchRequest{}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteBatchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("writeBatch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteBatchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchArgs(%+v)", *p)
}

// Attributes:
//  - Err
type NodeWriteBatchResult struct {
	Err *WriteBatchErrors `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteBatchResult() *NodeWriteBatchResult {
	return &NodeWriteBatchResult{}
}

var NodeWriteBatchResult_Err_DEFAULT *WriteBatchErrors

func (p *NodeWriteBatchResult) GetErr() *WriteBatchErrors {
	if !p.IsSetErr() {
		return NodeWriteBatchResult_Err_DEFAULT
	}
	return p.Err
}
func (p *NodeWriteBatchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteBatchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &WriteBatchErrors{}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteBatchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("writeBatch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteBatchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchResult(%+v)", *p)
}

// Attributes:
//  - Req
type NodeFetchArgs struct {
	Req *FetchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchArgs() *NodeFetchArgs {
	return &NodeFetchArgs{}
}

var NodeFetchArgs_Req_DEFAULT *FetchRequest

func (p *NodeFetchArgs) GetReq() *FetchRequest {
	if !p.IsSetReq() {
		return NodeFetchArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *NodeFetchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &FetchRequest{
		RangeType: 0,

		ResultTimeType: 0,
	}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Err
type NodeFetchResult struct {
	Success *FetchResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *Error        `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchResult() *NodeFetchResult {
	return &NodeFetchResult{}
}

var NodeFetchResult_Success_DEFAULT *FetchResult_

func (p *NodeFetchResult) GetSuccess() *FetchResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchResult_Err_DEFAULT *Error

func (p *NodeFetchResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchResult_Err_DEFAULT
	}
	return p.Err
}
func (p *NodeFetchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &FetchResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(oprot); err != nil {
			return err
		}
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchResult(%+v)", *p)
}

// Attributes:
//  - Req
type NodeFetchRawBatchArgs struct {
	Req *FetchRawBatchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchRawBatchArgs() *NodeFetchRawBatchArgs {
	return &NodeFetchRawBatchArgs{}
}

var NodeFetchRawBatchArgs_Req_DEFAULT *FetchRawBatchRequest

func (p *NodeFetchRawBatchArgs) GetReq() *FetchRawBatchRequest {
	if !p.IsSetReq() {
		return NodeFetchRawBatchArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *NodeFetchRawBatchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchRawBatchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchRawBatchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &FetchRawBatchRequest{
		RangeType: 0,
	}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchRawBatchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetchRawBatch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchRawBatchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchRawBatchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchRawBatchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Err
type NodeFetchRawBatchResult struct {
	Success *FetchRawBatchResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *Error                `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchRawBatchResult() *NodeFetchRawBatchResult {
	return &NodeFetchRawBatchResult{}
}

var NodeFetchRawBatchResult_Success_DEFAULT *FetchRawBatchResult_

func (p *NodeFetchRawBatchResult) GetSuccess() *FetchRawBatchResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchRawBatchResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchRawBatchResult_Err_DEFAULT *Error

func (p *NodeFetchRawBatchResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchRawBatchResult_Err_DEFAULT
	}
	return p.Err
}
func (p *NodeFetchRawBatchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchRawBatchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchRawBatchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchRawBatchResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &FetchRawBatchResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchRawBatchResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchRawBatchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetchRawBatch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(oprot); err != nil {
			return err
		}
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchRawBatchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchRawBatchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchRawBatchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchRawBatchResult(%+v)", *p)
}

type Cluster interface {
	Health() (r *HealthResult_, err error)
	// Parameters:
	//  - Req
	Write(req *WriteRequest) (err error)
	// Parameters:
	//  - Req
	Fetch(req *FetchRequest) (r *FetchResult_, err error)
}

type ClusterClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewClusterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ClusterClient {
	return &ClusterClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewClusterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ClusterClient {
	return &ClusterClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

func (p *ClusterClient) Health() (r *HealthResult_, err error) {
	if err = p.sendHealth(); err != nil {
		return
	}
	return p.recvHealth()
}

func (p *ClusterClient) sendHealth() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("health", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ClusterHealthArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ClusterClient) recvHealth() (value *HealthResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "health" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "health failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "health failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "health failed: invalid message type")
		return
	}
	result := ClusterHealthResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Req
func (p *ClusterClient) Write(req *WriteRequest) (err error) {
	if err = p.sendWrite(req); err != nil {
		return
	}
	return p.recvWrite()
}

func (p *ClusterClient) sendWrite(req *WriteRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("write", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ClusterWriteArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ClusterClient) recvWrite() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "write" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "write failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "write failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error45 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error46 error
		error46, err = error45.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error46
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "write failed: invalid message type")
		return
	}
	result := ClusterWriteResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	return
}

// Parameters:
//  - Req
func (p *ClusterClient) Fetch(req *FetchRequest) (r *FetchResult_, err error) {
	if err = p.sendFetch(req); err != nil {
		return
	}
	return p.recvFetch()
}

func (p *ClusterClient) sendFetch(req *FetchRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("fetch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ClusterFetchArgs{
		Req: req,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *ClusterClient) recvFetch() (value *FetchResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "fetch" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "fetch failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "fetch failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "fetch failed: invalid message type")
		return
	}
	result := ClusterFetchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Err != nil {
		err = result.Err
		return
	}
	value = result.GetSuccess()
	return
}

type ClusterProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Cluster
}

func (p *ClusterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ClusterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ClusterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewClusterProcessor(handler Cluster) *ClusterProcessor {

	self49 := &ClusterProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self49.processorMap["health"] = &clusterProcessorHealth{handler: handler}
	self49.processorMap["write"] = &clusterProcessorWrite{handler: handler}
	self49.processorMap["fetch"] = &clusterProcessorFetch{handler: handler}
	return self49
}

func (p *ClusterProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x50 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x50.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x50

}

type clusterProcessorHealth struct {
	handler Cluster
}

func (p *clusterProcessorHealth) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ClusterHealthArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("health", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ClusterHealthResult{}
	var retval *HealthResult_
	var err2 error
	if retval, err2 = p.handler.Health(); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing health: "+err2.Error())
			oprot.WriteMessageBegin("health", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("health", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clusterProcessorWrite struct {
	handler Cluster
}

func (p *clusterProcessorWrite) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ClusterWriteArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("write", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ClusterWriteResult{}
	var err2 error
	if err2 = p.handler.Write(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing write: "+err2.Error())
			oprot.WriteMessageBegin("write", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("write", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type clusterProcessorFetch struct {
	handler Cluster
}

func (p *clusterProcessorFetch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ClusterFetchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ClusterFetchResult{}
	var retval *FetchResult_
	var err2 error
	if retval, err2 = p.handler.Fetch(args.Req); err2 != nil {
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetch: "+err2.Error())
			oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("fetch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type ClusterHealthArgs struct {
}

func NewClusterHealthArgs() *ClusterHealthArgs {
	return &ClusterHealthArgs{}
}

func (p *ClusterHealthArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterHealthArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("health_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterHealthArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterHealthArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Err
type ClusterHealthResult struct {
	Success *HealthResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *Error         `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterHealthResult() *ClusterHealthResult {
	return &ClusterHealthResult{}
}

var ClusterHealthResult_Success_DEFAULT *HealthResult_

func (p *ClusterHealthResult) GetSuccess() *HealthResult_ {
	if !p.IsSetSuccess() {
		return ClusterHealthResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterHealthResult_Err_DEFAULT *Error

func (p *ClusterHealthResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterHealthResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ClusterHealthResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterHealthResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterHealthResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterHealthResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &HealthResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterHealthResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterHealthResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("health_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(oprot); err != nil {
			return err
		}
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterHealthResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterHealthResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterHealthResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterHealthResult(%+v)", *p)
}

// Attributes:
//  - Req
type ClusterWriteArgs struct {
	Req *WriteRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterWriteArgs() *ClusterWriteArgs {
	return &ClusterWriteArgs{}
}

var ClusterWriteArgs_Req_DEFAULT *WriteRequest

func (p *ClusterWriteArgs) GetReq() *WriteRequest {
	if !p.IsSetReq() {
		return ClusterWriteArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *ClusterWriteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterWriteArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &WriteRequest{}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterWriteArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("write_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterWriteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteArgs(%+v)", *p)
}

// Attributes:
//  - Err
type ClusterWriteResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterWriteResult() *ClusterWriteResult {
	return &ClusterWriteResult{}
}

var ClusterWriteResult_Err_DEFAULT *Error

func (p *ClusterWriteResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterWriteResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ClusterWriteResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterWriteResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterWriteResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("write_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterWriteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteResult(%+v)", *p)
}

// Attributes:
//  - Req
type ClusterFetchArgs struct {
	Req *FetchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterFetchArgs() *ClusterFetchArgs {
	return &ClusterFetchArgs{}
}

var ClusterFetchArgs_Req_DEFAULT *FetchRequest

func (p *ClusterFetchArgs) GetReq() *FetchRequest {
	if !p.IsSetReq() {
		return ClusterFetchArgs_Req_DEFAULT
	}
	return p.Req
}
func (p *ClusterFetchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterFetchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterFetchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Req = &FetchRequest{
		RangeType: 0,

		ResultTimeType: 0,
	}
	if err := p.Req.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterFetchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterFetchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterFetchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterFetchArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - Err
type ClusterFetchResult struct {
	Success *FetchResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err     *Error        `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterFetchResult() *ClusterFetchResult {
	return &ClusterFetchResult{}
}

var ClusterFetchResult_Success_DEFAULT *FetchResult_

func (p *ClusterFetchResult) GetSuccess() *FetchResult_ {
	if !p.IsSetSuccess() {
		return ClusterFetchResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterFetchResult_Err_DEFAULT *Error

func (p *ClusterFetchResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterFetchResult_Err_DEFAULT
	}
	return p.Err
}
func (p *ClusterFetchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterFetchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterFetchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterFetchResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &FetchResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterFetchResult) ReadField1(iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterFetchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(oprot); err != nil {
			return err
		}
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterFetchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterFetchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin("err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterFetchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterFetchResult(%+v)", *p)
}
