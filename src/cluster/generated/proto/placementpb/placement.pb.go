// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/m3db/m3/src/cluster/generated/proto/placementpb/placement.proto

// Copyright (c) 2024 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package placementpb

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ShardState int32

const (
	ShardState_INITIALIZING ShardState = 0
	ShardState_AVAILABLE    ShardState = 1
	ShardState_LEAVING      ShardState = 2
)

var ShardState_name = map[int32]string{
	0: "INITIALIZING",
	1: "AVAILABLE",
	2: "LEAVING",
}

var ShardState_value = map[string]int32{
	"INITIALIZING": 0,
	"AVAILABLE":    1,
	"LEAVING":      2,
}

func (x ShardState) String() string {
	return proto.EnumName(ShardState_name, int32(x))
}

func (ShardState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{0}
}

type CompressMode int32

const (
	CompressMode_NONE CompressMode = 0
	CompressMode_ZSTD CompressMode = 1
)

var CompressMode_name = map[int32]string{
	0: "NONE",
	1: "ZSTD",
}

var CompressMode_value = map[string]int32{
	"NONE": 0,
	"ZSTD": 1,
}

func (x CompressMode) String() string {
	return proto.EnumName(CompressMode_name, int32(x))
}

func (CompressMode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{1}
}

type Placement struct {
	Instances     map[string]*Instance `protobuf:"bytes,1,rep,name=instances,proto3" json:"instances,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReplicaFactor uint32               `protobuf:"varint,2,opt,name=replica_factor,json=replicaFactor,proto3" json:"replica_factor,omitempty"`
	NumShards     uint32               `protobuf:"varint,3,opt,name=num_shards,json=numShards,proto3" json:"num_shards,omitempty"`
	IsSharded     bool                 `protobuf:"varint,4,opt,name=is_sharded,json=isSharded,proto3" json:"is_sharded,omitempty"`
	// cutover_time is the placement-level cutover time and determines when the clients
	// watching the placement deems the placement as "in effect" and can use it to determine
	// shard placement.
	CutoverTime int64 `protobuf:"varint,5,opt,name=cutover_time,json=cutoverTime,proto3" json:"cutover_time,omitempty"`
	IsMirrored  bool  `protobuf:"varint,6,opt,name=is_mirrored,json=isMirrored,proto3" json:"is_mirrored,omitempty"`
	// max_shard_set_id stores the maximum shard set id used to guarantee unique
	// shard set id generations across placement changes.
	MaxShardSetId uint32 `protobuf:"varint,7,opt,name=max_shard_set_id,json=maxShardSetId,proto3" json:"max_shard_set_id,omitempty"`
}

func (m *Placement) Reset()         { *m = Placement{} }
func (m *Placement) String() string { return proto.CompactTextString(m) }
func (*Placement) ProtoMessage()    {}
func (*Placement) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{0}
}
func (m *Placement) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Placement) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Placement.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Placement) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Placement.Merge(m, src)
}
func (m *Placement) XXX_Size() int {
	return m.Size()
}
func (m *Placement) XXX_DiscardUnknown() {
	xxx_messageInfo_Placement.DiscardUnknown(m)
}

var xxx_messageInfo_Placement proto.InternalMessageInfo

func (m *Placement) GetInstances() map[string]*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *Placement) GetReplicaFactor() uint32 {
	if m != nil {
		return m.ReplicaFactor
	}
	return 0
}

func (m *Placement) GetNumShards() uint32 {
	if m != nil {
		return m.NumShards
	}
	return 0
}

func (m *Placement) GetIsSharded() bool {
	if m != nil {
		return m.IsSharded
	}
	return false
}

func (m *Placement) GetCutoverTime() int64 {
	if m != nil {
		return m.CutoverTime
	}
	return 0
}

func (m *Placement) GetIsMirrored() bool {
	if m != nil {
		return m.IsMirrored
	}
	return false
}

func (m *Placement) GetMaxShardSetId() uint32 {
	if m != nil {
		return m.MaxShardSetId
	}
	return 0
}

type Instance struct {
	Id             string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	IsolationGroup string            `protobuf:"bytes,2,opt,name=isolation_group,json=isolationGroup,proto3" json:"isolation_group,omitempty"`
	Zone           string            `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty"`
	Weight         uint32            `protobuf:"varint,4,opt,name=weight,proto3" json:"weight,omitempty"`
	Endpoint       string            `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Shards         []*Shard          `protobuf:"bytes,6,rep,name=shards,proto3" json:"shards,omitempty"`
	ShardSetId     uint32            `protobuf:"varint,7,opt,name=shard_set_id,json=shardSetId,proto3" json:"shard_set_id,omitempty"`
	Hostname       string            `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port           uint32            `protobuf:"varint,9,opt,name=port,proto3" json:"port,omitempty"`
	Metadata       *InstanceMetadata `protobuf:"bytes,10,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Instance) Reset()         { *m = Instance{} }
func (m *Instance) String() string { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()    {}
func (*Instance) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{1}
}
func (m *Instance) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Instance) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Instance.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Instance) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Instance.Merge(m, src)
}
func (m *Instance) XXX_Size() int {
	return m.Size()
}
func (m *Instance) XXX_DiscardUnknown() {
	xxx_messageInfo_Instance.DiscardUnknown(m)
}

var xxx_messageInfo_Instance proto.InternalMessageInfo

func (m *Instance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Instance) GetIsolationGroup() string {
	if m != nil {
		return m.IsolationGroup
	}
	return ""
}

func (m *Instance) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Instance) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Instance) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Instance) GetShards() []*Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *Instance) GetShardSetId() uint32 {
	if m != nil {
		return m.ShardSetId
	}
	return 0
}

func (m *Instance) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Instance) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Instance) GetMetadata() *InstanceMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type InstanceMetadata struct {
	DebugPort uint32 `protobuf:"varint,1,opt,name=debug_port,json=debugPort,proto3" json:"debug_port,omitempty"`
}

func (m *InstanceMetadata) Reset()         { *m = InstanceMetadata{} }
func (m *InstanceMetadata) String() string { return proto.CompactTextString(m) }
func (*InstanceMetadata) ProtoMessage()    {}
func (*InstanceMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{2}
}
func (m *InstanceMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceMetadata.Merge(m, src)
}
func (m *InstanceMetadata) XXX_Size() int {
	return m.Size()
}
func (m *InstanceMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceMetadata proto.InternalMessageInfo

func (m *InstanceMetadata) GetDebugPort() uint32 {
	if m != nil {
		return m.DebugPort
	}
	return 0
}

type Shard struct {
	Id       uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	State    ShardState `protobuf:"varint,2,opt,name=state,proto3,enum=placementpb.ShardState" json:"state,omitempty"`
	SourceId string     `protobuf:"bytes,3,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	// Shard-level cutover and cutoff times determine when the shards have been cut over or
	// cut off from the source instance to the destination instance. The placement-level
	// cutover times are usually (but not required to be) earlier than shard-level cutover
	// times if the clients watching the placement need to send traffic to the shards before
	// they are ready to cut over or after they are ready to cut off (e.g., for warmup purposes).
	CutoverNanos int64 `protobuf:"varint,4,opt,name=cutover_nanos,json=cutoverNanos,proto3" json:"cutover_nanos,omitempty"`
	CutoffNanos  int64 `protobuf:"varint,5,opt,name=cutoff_nanos,json=cutoffNanos,proto3" json:"cutoff_nanos,omitempty"`
	// redirect_to_shard_id is used during resharding process.
	// If set, all the incoming writes will be redirected to the specified shard.
	RedirectToShardId *types.UInt32Value `protobuf:"bytes,6,opt,name=redirect_to_shard_id,json=redirectToShardId,proto3" json:"redirect_to_shard_id,omitempty"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}
func (*Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{3}
}
func (m *Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shard.Merge(m, src)
}
func (m *Shard) XXX_Size() int {
	return m.Size()
}
func (m *Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_Shard proto.InternalMessageInfo

func (m *Shard) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Shard) GetState() ShardState {
	if m != nil {
		return m.State
	}
	return ShardState_INITIALIZING
}

func (m *Shard) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *Shard) GetCutoverNanos() int64 {
	if m != nil {
		return m.CutoverNanos
	}
	return 0
}

func (m *Shard) GetCutoffNanos() int64 {
	if m != nil {
		return m.CutoffNanos
	}
	return 0
}

func (m *Shard) GetRedirectToShardId() *types.UInt32Value {
	if m != nil {
		return m.RedirectToShardId
	}
	return nil
}

type PlacementSnapshots struct {
	// snapshots field is used only when compress_mode == NONE.
	Snapshots           []*Placement `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"` // Deprecated: Do not use.
	CompressMode        CompressMode `protobuf:"varint,2,opt,name=compress_mode,json=compressMode,proto3,enum=placementpb.CompressMode" json:"compress_mode,omitempty"`
	CompressedPlacement []byte       `protobuf:"bytes,3,opt,name=compressed_placement,json=compressedPlacement,proto3" json:"compressed_placement,omitempty"`
}

func (m *PlacementSnapshots) Reset()         { *m = PlacementSnapshots{} }
func (m *PlacementSnapshots) String() string { return proto.CompactTextString(m) }
func (*PlacementSnapshots) ProtoMessage()    {}
func (*PlacementSnapshots) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{4}
}
func (m *PlacementSnapshots) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementSnapshots) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementSnapshots.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementSnapshots) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementSnapshots.Merge(m, src)
}
func (m *PlacementSnapshots) XXX_Size() int {
	return m.Size()
}
func (m *PlacementSnapshots) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementSnapshots.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementSnapshots proto.InternalMessageInfo

// Deprecated: Do not use.
func (m *PlacementSnapshots) GetSnapshots() []*Placement {
	if m != nil {
		return m.Snapshots
	}
	return nil
}

func (m *PlacementSnapshots) GetCompressMode() CompressMode {
	if m != nil {
		return m.CompressMode
	}
	return CompressMode_NONE
}

func (m *PlacementSnapshots) GetCompressedPlacement() []byte {
	if m != nil {
		return m.CompressedPlacement
	}
	return nil
}

type Options struct {
	IsSharded         *types.BoolValue `protobuf:"bytes,1,opt,name=is_sharded,json=isSharded,proto3" json:"is_sharded,omitempty"`
	SkipPortMirroring *types.BoolValue `protobuf:"bytes,2,opt,name=skip_port_mirroring,json=skipPortMirroring,proto3" json:"skip_port_mirroring,omitempty"`
}

func (m *Options) Reset()         { *m = Options{} }
func (m *Options) String() string { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()    {}
func (*Options) Descriptor() ([]byte, []int) {
	return fileDescriptor_49f8390e6e800fd6, []int{5}
}
func (m *Options) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Options) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Options.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Options) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Options.Merge(m, src)
}
func (m *Options) XXX_Size() int {
	return m.Size()
}
func (m *Options) XXX_DiscardUnknown() {
	xxx_messageInfo_Options.DiscardUnknown(m)
}

var xxx_messageInfo_Options proto.InternalMessageInfo

func (m *Options) GetIsSharded() *types.BoolValue {
	if m != nil {
		return m.IsSharded
	}
	return nil
}

func (m *Options) GetSkipPortMirroring() *types.BoolValue {
	if m != nil {
		return m.SkipPortMirroring
	}
	return nil
}

func init() {
	proto.RegisterEnum("placementpb.ShardState", ShardState_name, ShardState_value)
	proto.RegisterEnum("placementpb.CompressMode", CompressMode_name, CompressMode_value)
	proto.RegisterType((*Placement)(nil), "placementpb.Placement")
	proto.RegisterMapType((map[string]*Instance)(nil), "placementpb.Placement.InstancesEntry")
	proto.RegisterType((*Instance)(nil), "placementpb.Instance")
	proto.RegisterType((*InstanceMetadata)(nil), "placementpb.InstanceMetadata")
	proto.RegisterType((*Shard)(nil), "placementpb.Shard")
	proto.RegisterType((*PlacementSnapshots)(nil), "placementpb.PlacementSnapshots")
	proto.RegisterType((*Options)(nil), "placementpb.Options")
}

func init() {
	proto.RegisterFile("github.com/m3db/m3/src/cluster/generated/proto/placementpb/placement.proto", fileDescriptor_49f8390e6e800fd6)
}

var fileDescriptor_49f8390e6e800fd6 = []byte{
	// 870 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0x4d, 0x6f, 0x1b, 0x37,
	0x10, 0x35, 0x25, 0x5b, 0xd6, 0x8e, 0x3e, 0xaa, 0x30, 0x69, 0xba, 0x75, 0x1b, 0x55, 0x55, 0x11,
	0x54, 0x70, 0x51, 0x09, 0x91, 0x2f, 0x49, 0x0e, 0x05, 0xe4, 0xd4, 0x0d, 0x36, 0xb0, 0x94, 0x80,
	0x72, 0x7d, 0xc8, 0x65, 0x41, 0xed, 0x52, 0x12, 0x11, 0xed, 0x72, 0x41, 0x72, 0xf3, 0xd1, 0x5f,
	0x91, 0xbf, 0x54, 0xa0, 0x87, 0x1e, 0x73, 0xec, 0xb1, 0xb0, 0x7f, 0x44, 0x81, 0x9e, 0x8a, 0x25,
	0x77, 0xf5, 0xd1, 0x18, 0xb9, 0x71, 0xde, 0xbc, 0x21, 0x87, 0x8f, 0x6f, 0x08, 0xcf, 0x16, 0x5c,
	0x2f, 0xd3, 0x59, 0x3f, 0x10, 0xd1, 0x20, 0x3a, 0x09, 0x67, 0x83, 0xe8, 0x64, 0xa0, 0x64, 0x30,
	0x08, 0x56, 0xa9, 0xd2, 0x4c, 0x0e, 0x16, 0x2c, 0x66, 0x92, 0x6a, 0x16, 0x0e, 0x12, 0x29, 0xb4,
	0x18, 0x24, 0x2b, 0x1a, 0xb0, 0x88, 0xc5, 0x3a, 0x99, 0x6d, 0xd6, 0x7d, 0x93, 0xc3, 0xb5, 0xad,
	0xe4, 0x51, 0x7b, 0x21, 0xc4, 0x62, 0xc5, 0x6c, 0xd9, 0x2c, 0x9d, 0x0f, 0xde, 0x48, 0x9a, 0x24,
	0x4c, 0x2a, 0x4b, 0xee, 0xfe, 0x53, 0x02, 0xe7, 0x45, 0xc1, 0xc7, 0x4f, 0xc0, 0xe1, 0xb1, 0xd2,
	0x34, 0x0e, 0x98, 0x72, 0x51, 0xa7, 0xdc, 0xab, 0x0d, 0xef, 0xf7, 0xb7, 0xb6, 0xeb, 0xaf, 0xa9,
	0x7d, 0xaf, 0xe0, 0x9d, 0xc5, 0x5a, 0xbe, 0x23, 0x9b, 0x3a, 0x7c, 0x1f, 0x9a, 0x92, 0x25, 0x2b,
	0x1e, 0x50, 0x7f, 0x4e, 0x03, 0x2d, 0xa4, 0x5b, 0xea, 0xa0, 0x5e, 0x83, 0x34, 0x72, 0xf4, 0x17,
	0x03, 0xe2, 0x7b, 0x00, 0x71, 0x1a, 0xf9, 0x6a, 0x49, 0x65, 0xa8, 0xdc, 0xb2, 0xa1, 0x38, 0x71,
	0x1a, 0x4d, 0x0d, 0x90, 0xa5, 0xb9, 0xb2, 0x59, 0x16, 0xba, 0xfb, 0x1d, 0xd4, 0xab, 0x12, 0x87,
	0xab, 0xa9, 0x05, 0xf0, 0xb7, 0x50, 0x0f, 0x52, 0x2d, 0x5e, 0x33, 0xe9, 0x6b, 0x1e, 0x31, 0xf7,
	0xa0, 0x83, 0x7a, 0x65, 0x52, 0xcb, 0xb1, 0x0b, 0x1e, 0x31, 0xfc, 0x0d, 0xd4, 0xb8, 0xf2, 0x23,
	0x2e, 0xa5, 0x90, 0x2c, 0x74, 0x2b, 0x66, 0x0b, 0xe0, 0x6a, 0x9c, 0x23, 0xf8, 0x7b, 0x68, 0x45,
	0xf4, 0xad, 0x3d, 0xc3, 0x57, 0x4c, 0xfb, 0x3c, 0x74, 0x0f, 0x6d, 0xab, 0x11, 0x7d, 0x6b, 0x4e,
	0x9a, 0x32, 0xed, 0x85, 0x47, 0x53, 0x68, 0xee, 0x5e, 0x17, 0xb7, 0xa0, 0xfc, 0x8a, 0xbd, 0x73,
	0x51, 0x07, 0xf5, 0x1c, 0x92, 0x2d, 0xf1, 0x0f, 0x70, 0xf0, 0x9a, 0xae, 0x52, 0x66, 0x2e, 0x5b,
	0x1b, 0x7e, 0xbe, 0x23, 0x5b, 0x51, 0x4d, 0x2c, 0xe7, 0x71, 0xe9, 0x21, 0xea, 0xfe, 0x51, 0x82,
	0x6a, 0x81, 0xe3, 0x26, 0x94, 0x78, 0x98, 0x6f, 0x57, 0xe2, 0x59, 0x6b, 0x9f, 0x71, 0x25, 0x56,
	0x54, 0x73, 0x11, 0xfb, 0x0b, 0x29, 0xd2, 0xc4, 0xec, 0xeb, 0x90, 0xe6, 0x1a, 0x7e, 0x9a, 0xa1,
	0x18, 0xc3, 0xfe, 0x6f, 0x22, 0x66, 0x46, 0x3f, 0x87, 0x98, 0x35, 0xbe, 0x0b, 0x95, 0x37, 0x8c,
	0x2f, 0x96, 0xda, 0xc8, 0xd6, 0x20, 0x79, 0x84, 0x8f, 0xa0, 0xca, 0xe2, 0x30, 0x11, 0x3c, 0xd6,
	0x46, 0x2f, 0x87, 0xac, 0x63, 0x7c, 0x0c, 0x95, 0xfc, 0x25, 0x2a, 0xe6, 0xd9, 0xf1, 0x4e, 0xff,
	0x46, 0x0b, 0x92, 0x33, 0x70, 0x07, 0xea, 0x37, 0x68, 0x06, 0x6a, 0x2d, 0x58, 0x76, 0xd2, 0x52,
	0x28, 0x1d, 0xd3, 0x88, 0xb9, 0x55, 0x7b, 0x52, 0x11, 0x67, 0x1d, 0x27, 0x42, 0x6a, 0xd7, 0x31,
	0x55, 0x66, 0x8d, 0x1f, 0x41, 0x35, 0x62, 0x9a, 0x86, 0x54, 0x53, 0x17, 0x8c, 0x7e, 0xf7, 0x6e,
	0xd4, 0x6f, 0x9c, 0x93, 0xc8, 0x9a, 0xde, 0x7d, 0x00, 0xad, 0xff, 0x67, 0x33, 0xef, 0x84, 0x6c,
	0x96, 0x2e, 0x7c, 0x73, 0x10, 0xb2, 0xd6, 0x32, 0xc8, 0x0b, 0x21, 0x75, 0xf7, 0x5f, 0x04, 0x07,
	0xe6, 0x46, 0x5b, 0xb2, 0x37, 0x8c, 0xec, 0x3f, 0xc2, 0x81, 0xd2, 0x54, 0xdb, 0x47, 0x6c, 0x0e,
	0xbf, 0xf8, 0x58, 0x84, 0x69, 0x96, 0x26, 0x96, 0x85, 0xbf, 0x02, 0x47, 0x89, 0x54, 0x06, 0x2c,
	0x53, 0xc1, 0xbe, 0x40, 0xd5, 0x02, 0x5e, 0x88, 0xbf, 0x83, 0x46, 0xe1, 0xd0, 0x98, 0xc6, 0x42,
	0x99, 0xc7, 0x28, 0x93, 0xc2, 0xb6, 0x93, 0x0c, 0x2b, 0x6c, 0x3c, 0x9f, 0xe7, 0x9c, 0x2d, 0x1b,
	0xcf, 0xe7, 0x96, 0x32, 0x86, 0x3b, 0x92, 0x85, 0x5c, 0xb2, 0x40, 0xfb, 0x5a, 0xe4, 0x6e, 0xe5,
	0xd6, 0xcf, 0xb5, 0xe1, 0xd7, 0x7d, 0x3b, 0xe0, 0xfd, 0x62, 0xc0, 0xfb, 0xbf, 0x7a, 0xb1, 0x3e,
	0x19, 0x5e, 0x66, 0x3e, 0x23, 0xb7, 0x8a, 0xca, 0x0b, 0x61, 0xba, 0xf7, 0xc2, 0xee, 0xef, 0x08,
	0xf0, 0x7a, 0x8a, 0xa7, 0x31, 0x4d, 0xd4, 0x52, 0x68, 0x85, 0x1f, 0x82, 0xa3, 0x8a, 0x20, 0x9f,
	0xfc, 0xbb, 0x37, 0x4f, 0xfe, 0x69, 0xc9, 0x45, 0x64, 0x43, 0xc6, 0x3f, 0x41, 0x23, 0x10, 0x51,
	0x22, 0x99, 0x52, 0x7e, 0x24, 0xc2, 0x42, 0xbb, 0x2f, 0x77, 0xaa, 0x9f, 0xe4, 0x8c, 0xb1, 0x08,
	0x19, 0xa9, 0x07, 0x5b, 0x11, 0x7e, 0x00, 0x77, 0x8a, 0x98, 0x85, 0xfe, 0xba, 0xc8, 0xe8, 0x59,
	0x27, 0xb7, 0x37, 0xb9, 0x75, 0x07, 0xdd, 0xf7, 0x08, 0x0e, 0x9f, 0x27, 0xd9, 0x10, 0x28, 0xfc,
	0x68, 0xe7, 0x9f, 0x40, 0x46, 0x94, 0xa3, 0x8f, 0x44, 0x39, 0x15, 0x62, 0x65, 0x25, 0xd9, 0xfa,
	0x43, 0x9e, 0xc1, 0x6d, 0xf5, 0x8a, 0x27, 0xc6, 0x25, 0xf9, 0x3f, 0xc1, 0xe3, 0x45, 0x3e, 0xc0,
	0x9f, 0xda, 0xe3, 0x56, 0x56, 0x96, 0x59, 0x69, 0x5c, 0x14, 0x1d, 0x3f, 0x06, 0xd8, 0xf8, 0x03,
	0xb7, 0xa0, 0xee, 0x4d, 0xbc, 0x0b, 0x6f, 0x74, 0xee, 0xbd, 0xf4, 0x26, 0x4f, 0x5b, 0x7b, 0xb8,
	0x01, 0xce, 0xe8, 0x72, 0xe4, 0x9d, 0x8f, 0x4e, 0xcf, 0xcf, 0x5a, 0x08, 0xd7, 0xe0, 0xf0, 0xfc,
	0x6c, 0x74, 0x99, 0xe5, 0x4a, 0xc7, 0x5d, 0xa8, 0x6f, 0xeb, 0x83, 0xab, 0xb0, 0x3f, 0x79, 0x3e,
	0x39, 0x6b, 0xed, 0x65, 0xab, 0x97, 0xd3, 0x8b, 0x9f, 0x5b, 0xe8, 0xd4, 0xfd, 0xf3, 0xaa, 0x8d,
	0x3e, 0x5c, 0xb5, 0xd1, 0xdf, 0x57, 0x6d, 0xf4, 0xfe, 0xba, 0xbd, 0xf7, 0xe1, 0xba, 0xbd, 0xf7,
	0xd7, 0x75, 0x7b, 0x6f, 0x56, 0x31, 0x0d, 0x9e, 0xfc, 0x17, 0x00, 0x00, 0xff, 0xff, 0xc8, 0x8e,
	0xf0, 0x70, 0x43, 0x06, 0x00, 0x00,
}

func (m *Placement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Placement) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Placement) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxShardSetId != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.MaxShardSetId))
		i--
		dAtA[i] = 0x38
	}
	if m.IsMirrored {
		i--
		if m.IsMirrored {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.CutoverTime != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoverTime))
		i--
		dAtA[i] = 0x28
	}
	if m.IsSharded {
		i--
		if m.IsSharded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.NumShards != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.NumShards))
		i--
		dAtA[i] = 0x18
	}
	if m.ReplicaFactor != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.ReplicaFactor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Instances) > 0 {
		for k := range m.Instances {
			v := m.Instances[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintPlacement(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintPlacement(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintPlacement(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Instance) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlacement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Port != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0x42
	}
	if m.ShardSetId != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.ShardSetId))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlacement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Endpoint) > 0 {
		i -= len(m.Endpoint)
		copy(dAtA[i:], m.Endpoint)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Endpoint)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Weight != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.Weight))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Zone) > 0 {
		i -= len(m.Zone)
		copy(dAtA[i:], m.Zone)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Zone)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IsolationGroup) > 0 {
		i -= len(m.IsolationGroup)
		copy(dAtA[i:], m.IsolationGroup)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.IsolationGroup)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstanceMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DebugPort != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.DebugPort))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Shard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RedirectToShardId != nil {
		{
			size, err := m.RedirectToShardId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlacement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.CutoffNanos != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoffNanos))
		i--
		dAtA[i] = 0x28
	}
	if m.CutoverNanos != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoverNanos))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SourceId) > 0 {
		i -= len(m.SourceId)
		copy(dAtA[i:], m.SourceId)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.SourceId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.State != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PlacementSnapshots) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementSnapshots) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementSnapshots) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CompressedPlacement) > 0 {
		i -= len(m.CompressedPlacement)
		copy(dAtA[i:], m.CompressedPlacement)
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.CompressedPlacement)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CompressMode != 0 {
		i = encodeVarintPlacement(dAtA, i, uint64(m.CompressMode))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Snapshots) > 0 {
		for iNdEx := len(m.Snapshots) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Snapshots[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintPlacement(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Options) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SkipPortMirroring != nil {
		{
			size, err := m.SkipPortMirroring.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlacement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.IsSharded != nil {
		{
			size, err := m.IsSharded.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPlacement(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintPlacement(dAtA []byte, offset int, v uint64) int {
	offset -= sovPlacement(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Placement) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPlacement(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlacement(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlacement(uint64(mapEntrySize))
		}
	}
	if m.ReplicaFactor != 0 {
		n += 1 + sovPlacement(uint64(m.ReplicaFactor))
	}
	if m.NumShards != 0 {
		n += 1 + sovPlacement(uint64(m.NumShards))
	}
	if m.IsSharded {
		n += 2
	}
	if m.CutoverTime != 0 {
		n += 1 + sovPlacement(uint64(m.CutoverTime))
	}
	if m.IsMirrored {
		n += 2
	}
	if m.MaxShardSetId != 0 {
		n += 1 + sovPlacement(uint64(m.MaxShardSetId))
	}
	return n
}

func (m *Instance) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	l = len(m.IsolationGroup)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovPlacement(uint64(m.Weight))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovPlacement(uint64(l))
		}
	}
	if m.ShardSetId != 0 {
		n += 1 + sovPlacement(uint64(m.ShardSetId))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPlacement(uint64(m.Port))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *InstanceMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DebugPort != 0 {
		n += 1 + sovPlacement(uint64(m.DebugPort))
	}
	return n
}

func (m *Shard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlacement(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovPlacement(uint64(m.State))
	}
	l = len(m.SourceId)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.CutoverNanos != 0 {
		n += 1 + sovPlacement(uint64(m.CutoverNanos))
	}
	if m.CutoffNanos != 0 {
		n += 1 + sovPlacement(uint64(m.CutoffNanos))
	}
	if m.RedirectToShardId != nil {
		l = m.RedirectToShardId.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *PlacementSnapshots) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Snapshots) > 0 {
		for _, e := range m.Snapshots {
			l = e.Size()
			n += 1 + l + sovPlacement(uint64(l))
		}
	}
	if m.CompressMode != 0 {
		n += 1 + sovPlacement(uint64(m.CompressMode))
	}
	l = len(m.CompressedPlacement)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *Options) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsSharded != nil {
		l = m.IsSharded.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.SkipPortMirroring != nil {
		l = m.SkipPortMirroring.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func sovPlacement(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPlacement(x uint64) (n int) {
	return sovPlacement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Placement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Placement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Placement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[string]*Instance)
			}
			var mapkey string
			var mapvalue *Instance
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlacement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlacement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlacement
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthPlacement
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlacement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlacement
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthPlacement
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instance{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlacement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthPlacement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaFactor", wireType)
			}
			m.ReplicaFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaFactor |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumShards", wireType)
			}
			m.NumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumShards |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSharded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoverTime", wireType)
			}
			m.CutoverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoverTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMirrored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMirrored = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxShardSetId", wireType)
			}
			m.MaxShardSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxShardSetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSetId", wireType)
			}
			m.ShardSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardSetId |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &InstanceMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugPort", wireType)
			}
			m.DebugPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoverNanos", wireType)
			}
			m.CutoverNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoverNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoffNanos", wireType)
			}
			m.CutoffNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoffNanos |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToShardId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedirectToShardId == nil {
				m.RedirectToShardId = &types.UInt32Value{}
			}
			if err := m.RedirectToShardId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementSnapshots) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementSnapshots: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementSnapshots: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshots = append(m.Snapshots, &Placement{})
			if err := m.Snapshots[len(m.Snapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressMode", wireType)
			}
			m.CompressMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressMode |= CompressMode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedPlacement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedPlacement = append(m.CompressedPlacement[:0], dAtA[iNdEx:postIndex]...)
			if m.CompressedPlacement == nil {
				m.CompressedPlacement = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IsSharded == nil {
				m.IsSharded = &types.BoolValue{}
			}
			if err := m.IsSharded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SkipPortMirroring", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPlacement
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SkipPortMirroring == nil {
				m.SkipPortMirroring = &types.BoolValue{}
			}
			if err := m.SkipPortMirroring.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlacement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPlacement
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPlacement
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPlacement
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPlacement        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlacement          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPlacement = fmt.Errorf("proto: unexpected end of group")
)
