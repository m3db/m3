// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: github.com/m3db/m3/src/cluster/generated/proto/placementpb/placement.proto

// Copyright (c) 2021 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/*
	Package placementpb is a generated protocol buffer package.

	It is generated from these files:
		github.com/m3db/m3/src/cluster/generated/proto/placementpb/placement.proto

	It has these top-level messages:
		Placement
		Instance
		InstanceMetadata
		Shard
		PlacementSnapshots
		Options
*/
package placementpb

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/gogo/protobuf/types"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type ShardState int32

const (
	ShardState_INITIALIZING ShardState = 0
	ShardState_AVAILABLE    ShardState = 1
	ShardState_LEAVING      ShardState = 2
)

var ShardState_name = map[int32]string{
	0: "INITIALIZING",
	1: "AVAILABLE",
	2: "LEAVING",
}
var ShardState_value = map[string]int32{
	"INITIALIZING": 0,
	"AVAILABLE":    1,
	"LEAVING":      2,
}

func (x ShardState) String() string {
	return proto.EnumName(ShardState_name, int32(x))
}
func (ShardState) EnumDescriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{0} }

type CompressMode int32

const (
	CompressMode_NONE CompressMode = 0
	CompressMode_ZSTD CompressMode = 1
)

var CompressMode_name = map[int32]string{
	0: "NONE",
	1: "ZSTD",
}
var CompressMode_value = map[string]int32{
	"NONE": 0,
	"ZSTD": 1,
}

func (x CompressMode) String() string {
	return proto.EnumName(CompressMode_name, int32(x))
}
func (CompressMode) EnumDescriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{1} }

type Placement struct {
	Instances     map[string]*Instance `protobuf:"bytes,1,rep,name=instances" json:"instances,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	ReplicaFactor uint32               `protobuf:"varint,2,opt,name=replica_factor,json=replicaFactor,proto3" json:"replica_factor,omitempty"`
	NumShards     uint32               `protobuf:"varint,3,opt,name=num_shards,json=numShards,proto3" json:"num_shards,omitempty"`
	IsSharded     bool                 `protobuf:"varint,4,opt,name=is_sharded,json=isSharded,proto3" json:"is_sharded,omitempty"`
	// cutover_time is the placement-level cutover time and determines when the clients
	// watching the placement deems the placement as "in effect" and can use it to determine
	// shard placement.
	CutoverTime int64 `protobuf:"varint,5,opt,name=cutover_time,json=cutoverTime,proto3" json:"cutover_time,omitempty"`
	IsMirrored  bool  `protobuf:"varint,6,opt,name=is_mirrored,json=isMirrored,proto3" json:"is_mirrored,omitempty"`
	// max_shard_set_id stores the maximum shard set id used to guarantee unique
	// shard set id generations across placement changes.
	MaxShardSetId uint32 `protobuf:"varint,7,opt,name=max_shard_set_id,json=maxShardSetId,proto3" json:"max_shard_set_id,omitempty"`
}

func (m *Placement) Reset()                    { *m = Placement{} }
func (m *Placement) String() string            { return proto.CompactTextString(m) }
func (*Placement) ProtoMessage()               {}
func (*Placement) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{0} }

func (m *Placement) GetInstances() map[string]*Instance {
	if m != nil {
		return m.Instances
	}
	return nil
}

func (m *Placement) GetReplicaFactor() uint32 {
	if m != nil {
		return m.ReplicaFactor
	}
	return 0
}

func (m *Placement) GetNumShards() uint32 {
	if m != nil {
		return m.NumShards
	}
	return 0
}

func (m *Placement) GetIsSharded() bool {
	if m != nil {
		return m.IsSharded
	}
	return false
}

func (m *Placement) GetCutoverTime() int64 {
	if m != nil {
		return m.CutoverTime
	}
	return 0
}

func (m *Placement) GetIsMirrored() bool {
	if m != nil {
		return m.IsMirrored
	}
	return false
}

func (m *Placement) GetMaxShardSetId() uint32 {
	if m != nil {
		return m.MaxShardSetId
	}
	return 0
}

type Instance struct {
	Id             string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	IsolationGroup string            `protobuf:"bytes,2,opt,name=isolation_group,json=isolationGroup,proto3" json:"isolation_group,omitempty"`
	Zone           string            `protobuf:"bytes,3,opt,name=zone,proto3" json:"zone,omitempty"`
	Weight         uint32            `protobuf:"varint,4,opt,name=weight,proto3" json:"weight,omitempty"`
	Endpoint       string            `protobuf:"bytes,5,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Shards         []*Shard          `protobuf:"bytes,6,rep,name=shards" json:"shards,omitempty"`
	ShardSetId     uint32            `protobuf:"varint,7,opt,name=shard_set_id,json=shardSetId,proto3" json:"shard_set_id,omitempty"`
	Hostname       string            `protobuf:"bytes,8,opt,name=hostname,proto3" json:"hostname,omitempty"`
	Port           uint32            `protobuf:"varint,9,opt,name=port,proto3" json:"port,omitempty"`
	Metadata       *InstanceMetadata `protobuf:"bytes,10,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *Instance) Reset()                    { *m = Instance{} }
func (m *Instance) String() string            { return proto.CompactTextString(m) }
func (*Instance) ProtoMessage()               {}
func (*Instance) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{1} }

func (m *Instance) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Instance) GetIsolationGroup() string {
	if m != nil {
		return m.IsolationGroup
	}
	return ""
}

func (m *Instance) GetZone() string {
	if m != nil {
		return m.Zone
	}
	return ""
}

func (m *Instance) GetWeight() uint32 {
	if m != nil {
		return m.Weight
	}
	return 0
}

func (m *Instance) GetEndpoint() string {
	if m != nil {
		return m.Endpoint
	}
	return ""
}

func (m *Instance) GetShards() []*Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *Instance) GetShardSetId() uint32 {
	if m != nil {
		return m.ShardSetId
	}
	return 0
}

func (m *Instance) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *Instance) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *Instance) GetMetadata() *InstanceMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type InstanceMetadata struct {
	DebugPort uint32 `protobuf:"varint,1,opt,name=debug_port,json=debugPort,proto3" json:"debug_port,omitempty"`
}

func (m *InstanceMetadata) Reset()                    { *m = InstanceMetadata{} }
func (m *InstanceMetadata) String() string            { return proto.CompactTextString(m) }
func (*InstanceMetadata) ProtoMessage()               {}
func (*InstanceMetadata) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{2} }

func (m *InstanceMetadata) GetDebugPort() uint32 {
	if m != nil {
		return m.DebugPort
	}
	return 0
}

type Shard struct {
	Id       uint32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	State    ShardState `protobuf:"varint,2,opt,name=state,proto3,enum=placementpb.ShardState" json:"state,omitempty"`
	SourceId string     `protobuf:"bytes,3,opt,name=source_id,json=sourceId,proto3" json:"source_id,omitempty"`
	// Shard-level cutover and cutoff times determine when the shards have been cut over or
	// cut off from the source instance to the destination instance. The placement-level
	// cutover times are usually (but not required to be) earlier than shard-level cutover
	// times if the clients watching the placement need to send traffic to the shards before
	// they are ready to cut over or after they are ready to cut off (e.g., for warmup purposes).
	CutoverNanos int64 `protobuf:"varint,4,opt,name=cutover_nanos,json=cutoverNanos,proto3" json:"cutover_nanos,omitempty"`
	CutoffNanos  int64 `protobuf:"varint,5,opt,name=cutoff_nanos,json=cutoffNanos,proto3" json:"cutoff_nanos,omitempty"`
	// redirect_to_shard_id is used during resharding process.
	// If set, all the incoming writes will be redirected to the specified shard.
	RedirectToShardId *google_protobuf.UInt32Value `protobuf:"bytes,6,opt,name=redirect_to_shard_id,json=redirectToShardId" json:"redirect_to_shard_id,omitempty"`
}

func (m *Shard) Reset()                    { *m = Shard{} }
func (m *Shard) String() string            { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()               {}
func (*Shard) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{3} }

func (m *Shard) GetId() uint32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Shard) GetState() ShardState {
	if m != nil {
		return m.State
	}
	return ShardState_INITIALIZING
}

func (m *Shard) GetSourceId() string {
	if m != nil {
		return m.SourceId
	}
	return ""
}

func (m *Shard) GetCutoverNanos() int64 {
	if m != nil {
		return m.CutoverNanos
	}
	return 0
}

func (m *Shard) GetCutoffNanos() int64 {
	if m != nil {
		return m.CutoffNanos
	}
	return 0
}

func (m *Shard) GetRedirectToShardId() *google_protobuf.UInt32Value {
	if m != nil {
		return m.RedirectToShardId
	}
	return nil
}

type PlacementSnapshots struct {
	// snapshots field is used only when compress_mode == NONE.
	Snapshots           []*Placement `protobuf:"bytes,1,rep,name=snapshots" json:"snapshots,omitempty"`
	CompressMode        CompressMode `protobuf:"varint,2,opt,name=compress_mode,json=compressMode,proto3,enum=placementpb.CompressMode" json:"compress_mode,omitempty"`
	CompressedPlacement []byte       `protobuf:"bytes,3,opt,name=compressed_placement,json=compressedPlacement,proto3" json:"compressed_placement,omitempty"`
}

func (m *PlacementSnapshots) Reset()                    { *m = PlacementSnapshots{} }
func (m *PlacementSnapshots) String() string            { return proto.CompactTextString(m) }
func (*PlacementSnapshots) ProtoMessage()               {}
func (*PlacementSnapshots) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{4} }

func (m *PlacementSnapshots) GetSnapshots() []*Placement {
	if m != nil {
		return m.Snapshots
	}
	return nil
}

func (m *PlacementSnapshots) GetCompressMode() CompressMode {
	if m != nil {
		return m.CompressMode
	}
	return CompressMode_NONE
}

func (m *PlacementSnapshots) GetCompressedPlacement() []byte {
	if m != nil {
		return m.CompressedPlacement
	}
	return nil
}

type Options struct {
	IsSharded *google_protobuf.BoolValue `protobuf:"bytes,1,opt,name=is_sharded,json=isSharded" json:"is_sharded,omitempty"`
}

func (m *Options) Reset()                    { *m = Options{} }
func (m *Options) String() string            { return proto.CompactTextString(m) }
func (*Options) ProtoMessage()               {}
func (*Options) Descriptor() ([]byte, []int) { return fileDescriptorPlacement, []int{5} }

func (m *Options) GetIsSharded() *google_protobuf.BoolValue {
	if m != nil {
		return m.IsSharded
	}
	return nil
}

func init() {
	proto.RegisterType((*Placement)(nil), "placementpb.Placement")
	proto.RegisterType((*Instance)(nil), "placementpb.Instance")
	proto.RegisterType((*InstanceMetadata)(nil), "placementpb.InstanceMetadata")
	proto.RegisterType((*Shard)(nil), "placementpb.Shard")
	proto.RegisterType((*PlacementSnapshots)(nil), "placementpb.PlacementSnapshots")
	proto.RegisterType((*Options)(nil), "placementpb.Options")
	proto.RegisterEnum("placementpb.ShardState", ShardState_name, ShardState_value)
	proto.RegisterEnum("placementpb.CompressMode", CompressMode_name, CompressMode_value)
}
func (m *Placement) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Placement) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k, _ := range m.Instances {
			dAtA[i] = 0xa
			i++
			v := m.Instances[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovPlacement(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovPlacement(uint64(len(k))) + msgSize
			i = encodeVarintPlacement(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlacement(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintPlacement(dAtA, i, uint64(v.Size()))
				n1, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n1
			}
		}
	}
	if m.ReplicaFactor != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.ReplicaFactor))
	}
	if m.NumShards != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.NumShards))
	}
	if m.IsSharded {
		dAtA[i] = 0x20
		i++
		if m.IsSharded {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.CutoverTime != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoverTime))
	}
	if m.IsMirrored {
		dAtA[i] = 0x30
		i++
		if m.IsMirrored {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.MaxShardSetId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.MaxShardSetId))
	}
	return i, nil
}

func (m *Instance) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Instance) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Id)))
		i += copy(dAtA[i:], m.Id)
	}
	if len(m.IsolationGroup) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.IsolationGroup)))
		i += copy(dAtA[i:], m.IsolationGroup)
	}
	if len(m.Zone) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Zone)))
		i += copy(dAtA[i:], m.Zone)
	}
	if m.Weight != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.Weight))
	}
	if len(m.Endpoint) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Endpoint)))
		i += copy(dAtA[i:], m.Endpoint)
	}
	if len(m.Shards) > 0 {
		for _, msg := range m.Shards {
			dAtA[i] = 0x32
			i++
			i = encodeVarintPlacement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.ShardSetId != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.ShardSetId))
	}
	if len(m.Hostname) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.Hostname)))
		i += copy(dAtA[i:], m.Hostname)
	}
	if m.Port != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.Port))
	}
	if m.Metadata != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.Metadata.Size()))
		n2, err := m.Metadata.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *InstanceMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DebugPort != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.DebugPort))
	}
	return i, nil
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.Id))
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.State))
	}
	if len(m.SourceId) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.SourceId)))
		i += copy(dAtA[i:], m.SourceId)
	}
	if m.CutoverNanos != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoverNanos))
	}
	if m.CutoffNanos != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.CutoffNanos))
	}
	if m.RedirectToShardId != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.RedirectToShardId.Size()))
		n3, err := m.RedirectToShardId.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *PlacementSnapshots) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementSnapshots) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Snapshots) > 0 {
		for _, msg := range m.Snapshots {
			dAtA[i] = 0xa
			i++
			i = encodeVarintPlacement(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CompressMode != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.CompressMode))
	}
	if len(m.CompressedPlacement) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(len(m.CompressedPlacement)))
		i += copy(dAtA[i:], m.CompressedPlacement)
	}
	return i, nil
}

func (m *Options) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Options) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.IsSharded != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintPlacement(dAtA, i, uint64(m.IsSharded.Size()))
		n4, err := m.IsSharded.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func encodeVarintPlacement(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Placement) Size() (n int) {
	var l int
	_ = l
	if len(m.Instances) > 0 {
		for k, v := range m.Instances {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovPlacement(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovPlacement(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovPlacement(uint64(mapEntrySize))
		}
	}
	if m.ReplicaFactor != 0 {
		n += 1 + sovPlacement(uint64(m.ReplicaFactor))
	}
	if m.NumShards != 0 {
		n += 1 + sovPlacement(uint64(m.NumShards))
	}
	if m.IsSharded {
		n += 2
	}
	if m.CutoverTime != 0 {
		n += 1 + sovPlacement(uint64(m.CutoverTime))
	}
	if m.IsMirrored {
		n += 2
	}
	if m.MaxShardSetId != 0 {
		n += 1 + sovPlacement(uint64(m.MaxShardSetId))
	}
	return n
}

func (m *Instance) Size() (n int) {
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	l = len(m.IsolationGroup)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	l = len(m.Zone)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.Weight != 0 {
		n += 1 + sovPlacement(uint64(m.Weight))
	}
	l = len(m.Endpoint)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovPlacement(uint64(l))
		}
	}
	if m.ShardSetId != 0 {
		n += 1 + sovPlacement(uint64(m.ShardSetId))
	}
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.Port != 0 {
		n += 1 + sovPlacement(uint64(m.Port))
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *InstanceMetadata) Size() (n int) {
	var l int
	_ = l
	if m.DebugPort != 0 {
		n += 1 + sovPlacement(uint64(m.DebugPort))
	}
	return n
}

func (m *Shard) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovPlacement(uint64(m.Id))
	}
	if m.State != 0 {
		n += 1 + sovPlacement(uint64(m.State))
	}
	l = len(m.SourceId)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	if m.CutoverNanos != 0 {
		n += 1 + sovPlacement(uint64(m.CutoverNanos))
	}
	if m.CutoffNanos != 0 {
		n += 1 + sovPlacement(uint64(m.CutoffNanos))
	}
	if m.RedirectToShardId != nil {
		l = m.RedirectToShardId.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *PlacementSnapshots) Size() (n int) {
	var l int
	_ = l
	if len(m.Snapshots) > 0 {
		for _, e := range m.Snapshots {
			l = e.Size()
			n += 1 + l + sovPlacement(uint64(l))
		}
	}
	if m.CompressMode != 0 {
		n += 1 + sovPlacement(uint64(m.CompressMode))
	}
	l = len(m.CompressedPlacement)
	if l > 0 {
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func (m *Options) Size() (n int) {
	var l int
	_ = l
	if m.IsSharded != nil {
		l = m.IsSharded.Size()
		n += 1 + l + sovPlacement(uint64(l))
	}
	return n
}

func sovPlacement(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozPlacement(x uint64) (n int) {
	return sovPlacement(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Placement) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Placement: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Placement: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Instances", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Instances == nil {
				m.Instances = make(map[string]*Instance)
			}
			var mapkey string
			var mapvalue *Instance
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowPlacement
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlacement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthPlacement
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowPlacement
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthPlacement
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthPlacement
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Instance{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipPlacement(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthPlacement
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Instances[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaFactor", wireType)
			}
			m.ReplicaFactor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaFactor |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumShards", wireType)
			}
			m.NumShards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumShards |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSharded = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoverTime", wireType)
			}
			m.CutoverTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoverTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMirrored", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMirrored = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxShardSetId", wireType)
			}
			m.MaxShardSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxShardSetId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Instance) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Instance: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Instance: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationGroup", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationGroup = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Zone = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Weight", wireType)
			}
			m.Weight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Weight |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Endpoint = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardSetId", wireType)
			}
			m.ShardSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardSetId |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &InstanceMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DebugPort", wireType)
			}
			m.DebugPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DebugPort |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (ShardState(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoverNanos", wireType)
			}
			m.CutoverNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoverNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CutoffNanos", wireType)
			}
			m.CutoffNanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CutoffNanos |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RedirectToShardId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RedirectToShardId == nil {
				m.RedirectToShardId = &google_protobuf.UInt32Value{}
			}
			if err := m.RedirectToShardId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementSnapshots) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementSnapshots: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementSnapshots: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshots", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snapshots = append(m.Snapshots, &Placement{})
			if err := m.Snapshots[len(m.Snapshots)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressMode", wireType)
			}
			m.CompressMode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressMode |= (CompressMode(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressedPlacement", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompressedPlacement = append(m.CompressedPlacement[:0], dAtA[iNdEx:postIndex]...)
			if m.CompressedPlacement == nil {
				m.CompressedPlacement = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Options) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Options: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Options: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSharded", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPlacement
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IsSharded == nil {
				m.IsSharded = &google_protobuf.BoolValue{}
			}
			if err := m.IsSharded.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPlacement(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPlacement
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPlacement(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPlacement
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPlacement
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthPlacement
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowPlacement
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipPlacement(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthPlacement = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPlacement   = fmt.Errorf("proto: integer overflow")
)

func init() {
	proto.RegisterFile("github.com/m3db/m3/src/cluster/generated/proto/placementpb/placement.proto", fileDescriptorPlacement)
}

var fileDescriptorPlacement = []byte{
	// 835 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x54, 0xcd, 0x6e, 0x1b, 0x37,
	0x10, 0xf6, 0x4a, 0xb6, 0xac, 0x1d, 0xfd, 0x74, 0xcb, 0xa6, 0xe9, 0xd6, 0x6d, 0x54, 0x55, 0x45,
	0x50, 0xc1, 0x45, 0x25, 0x44, 0xbe, 0x24, 0x39, 0x14, 0x90, 0x13, 0x37, 0xd8, 0xc2, 0x56, 0x02,
	0x4a, 0xf5, 0x21, 0x97, 0x05, 0xb5, 0xa4, 0x24, 0xa2, 0xda, 0xe5, 0x82, 0xe4, 0xe6, 0xa7, 0x4f,
	0xd1, 0x57, 0x2a, 0xd0, 0x43, 0x8f, 0x7d, 0x84, 0xc2, 0x7d, 0x88, 0x02, 0x3d, 0x15, 0x4b, 0xee,
	0xea, 0x27, 0xf6, 0x8d, 0xf3, 0xcd, 0x37, 0x9c, 0xe1, 0x37, 0x33, 0x84, 0x9f, 0x96, 0x5c, 0xaf,
	0xb2, 0xf9, 0x20, 0x12, 0xf1, 0x30, 0x3e, 0xa3, 0xf3, 0x61, 0x7c, 0x36, 0x54, 0x32, 0x1a, 0x46,
	0xeb, 0x4c, 0x69, 0x26, 0x87, 0x4b, 0x96, 0x30, 0x49, 0x34, 0xa3, 0xc3, 0x54, 0x0a, 0x2d, 0x86,
	0xe9, 0x9a, 0x44, 0x2c, 0x66, 0x89, 0x4e, 0xe7, 0xdb, 0xf3, 0xc0, 0xf8, 0x50, 0x63, 0xc7, 0x79,
	0xd2, 0x59, 0x0a, 0xb1, 0x5c, 0x33, 0x1b, 0x36, 0xcf, 0x16, 0xc3, 0xb7, 0x92, 0xa4, 0x29, 0x93,
	0xca, 0x92, 0x7b, 0xff, 0x56, 0xc0, 0x7d, 0x55, 0xf2, 0xd1, 0x33, 0x70, 0x79, 0xa2, 0x34, 0x49,
	0x22, 0xa6, 0x7c, 0xa7, 0x5b, 0xed, 0x37, 0x46, 0x0f, 0x07, 0x3b, 0xd7, 0x0d, 0x36, 0xd4, 0x41,
	0x50, 0xf2, 0x2e, 0x12, 0x2d, 0xdf, 0xe3, 0x6d, 0x1c, 0x7a, 0x08, 0x6d, 0xc9, 0xd2, 0x35, 0x8f,
	0x48, 0xb8, 0x20, 0x91, 0x16, 0xd2, 0xaf, 0x74, 0x9d, 0x7e, 0x0b, 0xb7, 0x0a, 0xf4, 0x47, 0x03,
	0xa2, 0x07, 0x00, 0x49, 0x16, 0x87, 0x6a, 0x45, 0x24, 0x55, 0x7e, 0xd5, 0x50, 0xdc, 0x24, 0x8b,
	0xa7, 0x06, 0xc8, 0xdd, 0x5c, 0x59, 0x2f, 0xa3, 0xfe, 0x61, 0xd7, 0xe9, 0xd7, 0xb1, 0xcb, 0xd5,
	0xd4, 0x02, 0xe8, 0x6b, 0x68, 0x46, 0x99, 0x16, 0x6f, 0x98, 0x0c, 0x35, 0x8f, 0x99, 0x7f, 0xd4,
	0x75, 0xfa, 0x55, 0xdc, 0x28, 0xb0, 0x19, 0x8f, 0x19, 0xfa, 0x0a, 0x1a, 0x5c, 0x85, 0x31, 0x97,
	0x52, 0x48, 0x46, 0xfd, 0x9a, 0xb9, 0x02, 0xb8, 0xba, 0x2a, 0x10, 0xf4, 0x2d, 0x78, 0x31, 0x79,
	0x67, 0x73, 0x84, 0x8a, 0xe9, 0x90, 0x53, 0xff, 0xd8, 0x96, 0x1a, 0x93, 0x77, 0x26, 0xd3, 0x94,
	0xe9, 0x80, 0x9e, 0x4c, 0xa1, 0xbd, 0xff, 0x5c, 0xe4, 0x41, 0xf5, 0x17, 0xf6, 0xde, 0x77, 0xba,
	0x4e, 0xdf, 0xc5, 0xf9, 0x11, 0x7d, 0x07, 0x47, 0x6f, 0xc8, 0x3a, 0x63, 0xe6, 0xb1, 0x8d, 0xd1,
	0xa7, 0x7b, 0xb2, 0x95, 0xd1, 0xd8, 0x72, 0x9e, 0x56, 0x1e, 0x3b, 0xbd, 0x3f, 0x2a, 0x50, 0x2f,
	0x71, 0xd4, 0x86, 0x0a, 0xa7, 0xc5, 0x75, 0x15, 0x9e, 0x97, 0xf6, 0x11, 0x57, 0x62, 0x4d, 0x34,
	0x17, 0x49, 0xb8, 0x94, 0x22, 0x4b, 0xcd, 0xbd, 0x2e, 0x6e, 0x6f, 0xe0, 0x17, 0x39, 0x8a, 0x10,
	0x1c, 0xfe, 0x2a, 0x12, 0x66, 0xf4, 0x73, 0xb1, 0x39, 0xa3, 0xfb, 0x50, 0x7b, 0xcb, 0xf8, 0x72,
	0xa5, 0x8d, 0x6c, 0x2d, 0x5c, 0x58, 0xe8, 0x04, 0xea, 0x2c, 0xa1, 0xa9, 0xe0, 0x89, 0x36, 0x7a,
	0xb9, 0x78, 0x63, 0xa3, 0x53, 0xa8, 0x15, 0x9d, 0xa8, 0x99, 0xb6, 0xa3, 0xbd, 0xfa, 0x8d, 0x16,
	0xb8, 0x60, 0xa0, 0x2e, 0x34, 0xef, 0xd0, 0x0c, 0xd4, 0x46, 0xb0, 0x3c, 0xd3, 0x4a, 0x28, 0x9d,
	0x90, 0x98, 0xf9, 0x75, 0x9b, 0xa9, 0xb4, 0xf3, 0x8a, 0x53, 0x21, 0xb5, 0xef, 0x9a, 0x28, 0x73,
	0x46, 0x4f, 0xa0, 0x1e, 0x33, 0x4d, 0x28, 0xd1, 0xc4, 0x07, 0xa3, 0xdf, 0x83, 0x3b, 0xf5, 0xbb,
	0x2a, 0x48, 0x78, 0x43, 0xef, 0x3d, 0x02, 0xef, 0x43, 0x6f, 0x3e, 0x3b, 0x94, 0xcd, 0xb3, 0x65,
	0x68, 0x12, 0x39, 0x76, 0xb4, 0x0c, 0xf2, 0x4a, 0x48, 0xdd, 0xfb, 0xcf, 0x81, 0x23, 0xf3, 0xa2,
	0x1d, 0xd9, 0x5b, 0x46, 0xf6, 0xef, 0xe1, 0x48, 0x69, 0xa2, 0x6d, 0x13, 0xdb, 0xa3, 0xcf, 0x6e,
	0x8b, 0x30, 0xcd, 0xdd, 0xd8, 0xb2, 0xd0, 0x17, 0xe0, 0x2a, 0x91, 0xc9, 0x88, 0xe5, 0x2a, 0xd8,
	0x0e, 0xd4, 0x2d, 0x10, 0x50, 0xf4, 0x0d, 0xb4, 0xca, 0x09, 0x4d, 0x48, 0x22, 0x94, 0x69, 0x46,
	0x15, 0x97, 0x63, 0x3b, 0xc9, 0xb1, 0x72, 0x8c, 0x17, 0x8b, 0x82, 0xb3, 0x33, 0xc6, 0x8b, 0x85,
	0xa5, 0x5c, 0xc1, 0x3d, 0xc9, 0x28, 0x97, 0x2c, 0xd2, 0xa1, 0x16, 0xc5, 0xb4, 0x72, 0x3b, 0xcf,
	0x8d, 0xd1, 0x97, 0x03, 0xbb, 0xe0, 0x83, 0x72, 0xc1, 0x07, 0x3f, 0x07, 0x89, 0x3e, 0x1b, 0x5d,
	0xe7, 0x73, 0x86, 0x3f, 0x2e, 0x23, 0x67, 0xc2, 0x54, 0x1f, 0xd0, 0xde, 0xef, 0x0e, 0xa0, 0xcd,
	0x16, 0x4f, 0x13, 0x92, 0xaa, 0x95, 0xd0, 0x0a, 0x3d, 0x06, 0x57, 0x95, 0x46, 0xb1, 0xf9, 0xf7,
	0xef, 0xde, 0xfc, 0xf3, 0x8a, 0xef, 0xe0, 0x2d, 0x19, 0xfd, 0x00, 0xad, 0x48, 0xc4, 0xa9, 0x64,
	0x4a, 0x85, 0xb1, 0xa0, 0xa5, 0x76, 0x9f, 0xef, 0x45, 0x3f, 0x2b, 0x18, 0x57, 0x82, 0x32, 0xdc,
	0x8c, 0x76, 0x2c, 0xf4, 0x08, 0xee, 0x95, 0x36, 0xa3, 0xe1, 0x26, 0xc8, 0xe8, 0xd9, 0xc4, 0x9f,
	0x6c, 0x7d, 0x9b, 0x0a, 0x7a, 0xcf, 0xe1, 0xf8, 0x65, 0x9a, 0xef, 0x80, 0x42, 0x4f, 0xf6, 0xbe,
	0x09, 0xc7, 0x68, 0x72, 0x72, 0x4b, 0x93, 0x73, 0x21, 0xd6, 0x56, 0x91, 0xed, 0x17, 0x72, 0xfa,
	0x14, 0x60, 0xdb, 0x52, 0xe4, 0x41, 0x33, 0x98, 0x04, 0xb3, 0x60, 0x7c, 0x19, 0xbc, 0x0e, 0x26,
	0x2f, 0xbc, 0x03, 0xd4, 0x02, 0x77, 0x7c, 0x3d, 0x0e, 0x2e, 0xc7, 0xe7, 0x97, 0x17, 0x9e, 0x83,
	0x1a, 0x70, 0x7c, 0x79, 0x31, 0xbe, 0xce, 0x7d, 0x95, 0xd3, 0x1e, 0x34, 0x77, 0x9f, 0x84, 0xea,
	0x70, 0x38, 0x79, 0x39, 0xb9, 0xf0, 0x0e, 0xf2, 0xd3, 0xeb, 0xe9, 0xec, 0xb9, 0xe7, 0x9c, 0x7b,
	0x7f, 0xde, 0x74, 0x9c, 0xbf, 0x6e, 0x3a, 0xce, 0xdf, 0x37, 0x1d, 0xe7, 0xb7, 0x7f, 0x3a, 0x07,
	0xf3, 0x9a, 0x29, 0xe8, 0xec, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x46, 0x70, 0xf8, 0xb6, 0xee,
	0x05, 0x00, 0x00,
}
