// Code generated by Thrift Compiler (0.21.0). DO NOT EDIT.

// Copyright (c) 2024 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package rpc

import (
	"bytes"
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"log/slog"
	"time"
	thrift "github.com/apache/thrift/lib/go/thrift"
	"strings"
	"regexp"
)

// (needed to ensure safety because of naive import list construction.)
var _ = bytes.Equal
var _ = context.Background
var _ = errors.New
var _ = fmt.Printf
var _ = slog.Log
var _ = time.Now
var _ = thrift.ZERO
// (needed by validator.)
var _ = strings.Contains
var _ = regexp.MatchString

type TimeType int64
const (
	TimeType_UNIX_SECONDS TimeType = 0
	TimeType_UNIX_MICROSECONDS TimeType = 1
	TimeType_UNIX_MILLISECONDS TimeType = 2
	TimeType_UNIX_NANOSECONDS TimeType = 3
)

func (p TimeType) String() string {
	switch p {
	case TimeType_UNIX_SECONDS: return "UNIX_SECONDS"
	case TimeType_UNIX_MICROSECONDS: return "UNIX_MICROSECONDS"
	case TimeType_UNIX_MILLISECONDS: return "UNIX_MILLISECONDS"
	case TimeType_UNIX_NANOSECONDS: return "UNIX_NANOSECONDS"
	}
	return "<UNSET>"
}

func TimeTypeFromString(s string) (TimeType, error) {
	switch s {
	case "UNIX_SECONDS": return TimeType_UNIX_SECONDS, nil
	case "UNIX_MICROSECONDS": return TimeType_UNIX_MICROSECONDS, nil
	case "UNIX_MILLISECONDS": return TimeType_UNIX_MILLISECONDS, nil
	case "UNIX_NANOSECONDS": return TimeType_UNIX_NANOSECONDS, nil
	}
	return TimeType(0), fmt.Errorf("not a valid TimeType string")
}


func TimeTypePtr(v TimeType) *TimeType { return &v }

func (p TimeType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *TimeType) UnmarshalText(text []byte) error {
	q, err := TimeTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *TimeType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = TimeType(v)
	return nil
}

func (p *TimeType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type ErrorType int64
const (
	ErrorType_INTERNAL_ERROR ErrorType = 0
	ErrorType_BAD_REQUEST ErrorType = 1
)

func (p ErrorType) String() string {
	switch p {
	case ErrorType_INTERNAL_ERROR: return "INTERNAL_ERROR"
	case ErrorType_BAD_REQUEST: return "BAD_REQUEST"
	}
	return "<UNSET>"
}

func ErrorTypeFromString(s string) (ErrorType, error) {
	switch s {
	case "INTERNAL_ERROR": return ErrorType_INTERNAL_ERROR, nil
	case "BAD_REQUEST": return ErrorType_BAD_REQUEST, nil
	}
	return ErrorType(0), fmt.Errorf("not a valid ErrorType string")
}


func ErrorTypePtr(v ErrorType) *ErrorType { return &v }

func (p ErrorType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ErrorType) UnmarshalText(text []byte) error {
	q, err := ErrorTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ErrorType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ErrorType(v)
	return nil
}

func (p *ErrorType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type ErrorFlags int64
const (
	ErrorFlags_NONE ErrorFlags = 0
	ErrorFlags_RESOURCE_EXHAUSTED ErrorFlags = 1
	ErrorFlags_SERVER_TIMEOUT ErrorFlags = 2
)

func (p ErrorFlags) String() string {
	switch p {
	case ErrorFlags_NONE: return "NONE"
	case ErrorFlags_RESOURCE_EXHAUSTED: return "RESOURCE_EXHAUSTED"
	case ErrorFlags_SERVER_TIMEOUT: return "SERVER_TIMEOUT"
	}
	return "<UNSET>"
}

func ErrorFlagsFromString(s string) (ErrorFlags, error) {
	switch s {
	case "NONE": return ErrorFlags_NONE, nil
	case "RESOURCE_EXHAUSTED": return ErrorFlags_RESOURCE_EXHAUSTED, nil
	case "SERVER_TIMEOUT": return ErrorFlags_SERVER_TIMEOUT, nil
	}
	return ErrorFlags(0), fmt.Errorf("not a valid ErrorFlags string")
}


func ErrorFlagsPtr(v ErrorFlags) *ErrorFlags { return &v }

func (p ErrorFlags) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ErrorFlags) UnmarshalText(text []byte) error {
	q, err := ErrorFlagsFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ErrorFlags) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ErrorFlags(v)
	return nil
}

func (p *ErrorFlags) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type AggregateQueryType int64
const (
	AggregateQueryType_AGGREGATE_BY_TAG_NAME AggregateQueryType = 0
	AggregateQueryType_AGGREGATE_BY_TAG_NAME_VALUE AggregateQueryType = 1
)

func (p AggregateQueryType) String() string {
	switch p {
	case AggregateQueryType_AGGREGATE_BY_TAG_NAME: return "AGGREGATE_BY_TAG_NAME"
	case AggregateQueryType_AGGREGATE_BY_TAG_NAME_VALUE: return "AGGREGATE_BY_TAG_NAME_VALUE"
	}
	return "<UNSET>"
}

func AggregateQueryTypeFromString(s string) (AggregateQueryType, error) {
	switch s {
	case "AGGREGATE_BY_TAG_NAME": return AggregateQueryType_AGGREGATE_BY_TAG_NAME, nil
	case "AGGREGATE_BY_TAG_NAME_VALUE": return AggregateQueryType_AGGREGATE_BY_TAG_NAME_VALUE, nil
	}
	return AggregateQueryType(0), fmt.Errorf("not a valid AggregateQueryType string")
}


func AggregateQueryTypePtr(v AggregateQueryType) *AggregateQueryType { return &v }

func (p AggregateQueryType) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *AggregateQueryType) UnmarshalText(text []byte) error {
	q, err := AggregateQueryTypeFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *AggregateQueryType) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = AggregateQueryType(v)
	return nil
}

func (p *AggregateQueryType) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type ReadConsistency int64
const (
	ReadConsistency_ONE ReadConsistency = 0
	ReadConsistency_UNSTRICT_MAJORITY ReadConsistency = 1
	ReadConsistency_MAJORITY ReadConsistency = 2
	ReadConsistency_UNSTRICT_ALL ReadConsistency = 3
	ReadConsistency_ALL ReadConsistency = 4
)

func (p ReadConsistency) String() string {
	switch p {
	case ReadConsistency_ONE: return "ONE"
	case ReadConsistency_UNSTRICT_MAJORITY: return "UNSTRICT_MAJORITY"
	case ReadConsistency_MAJORITY: return "MAJORITY"
	case ReadConsistency_UNSTRICT_ALL: return "UNSTRICT_ALL"
	case ReadConsistency_ALL: return "ALL"
	}
	return "<UNSET>"
}

func ReadConsistencyFromString(s string) (ReadConsistency, error) {
	switch s {
	case "ONE": return ReadConsistency_ONE, nil
	case "UNSTRICT_MAJORITY": return ReadConsistency_UNSTRICT_MAJORITY, nil
	case "MAJORITY": return ReadConsistency_MAJORITY, nil
	case "UNSTRICT_ALL": return ReadConsistency_UNSTRICT_ALL, nil
	case "ALL": return ReadConsistency_ALL, nil
	}
	return ReadConsistency(0), fmt.Errorf("not a valid ReadConsistency string")
}


func ReadConsistencyPtr(v ReadConsistency) *ReadConsistency { return &v }

func (p ReadConsistency) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *ReadConsistency) UnmarshalText(text []byte) error {
	q, err := ReadConsistencyFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *ReadConsistency) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = ReadConsistency(v)
	return nil
}

func (p *ReadConsistency) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

type EqualTimestampStrategy int64
const (
	EqualTimestampStrategy_LAST_PUSHED EqualTimestampStrategy = 0
	EqualTimestampStrategy_HIGHEST_VALUE EqualTimestampStrategy = 1
	EqualTimestampStrategy_LOWEST_VALUE EqualTimestampStrategy = 2
	EqualTimestampStrategy_HIGHEST_FREQUENCY EqualTimestampStrategy = 3
)

func (p EqualTimestampStrategy) String() string {
	switch p {
	case EqualTimestampStrategy_LAST_PUSHED: return "LAST_PUSHED"
	case EqualTimestampStrategy_HIGHEST_VALUE: return "HIGHEST_VALUE"
	case EqualTimestampStrategy_LOWEST_VALUE: return "LOWEST_VALUE"
	case EqualTimestampStrategy_HIGHEST_FREQUENCY: return "HIGHEST_FREQUENCY"
	}
	return "<UNSET>"
}

func EqualTimestampStrategyFromString(s string) (EqualTimestampStrategy, error) {
	switch s {
	case "LAST_PUSHED": return EqualTimestampStrategy_LAST_PUSHED, nil
	case "HIGHEST_VALUE": return EqualTimestampStrategy_HIGHEST_VALUE, nil
	case "LOWEST_VALUE": return EqualTimestampStrategy_LOWEST_VALUE, nil
	case "HIGHEST_FREQUENCY": return EqualTimestampStrategy_HIGHEST_FREQUENCY, nil
	}
	return EqualTimestampStrategy(0), fmt.Errorf("not a valid EqualTimestampStrategy string")
}


func EqualTimestampStrategyPtr(v EqualTimestampStrategy) *EqualTimestampStrategy { return &v }

func (p EqualTimestampStrategy) MarshalText() ([]byte, error) {
	return []byte(p.String()), nil
}

func (p *EqualTimestampStrategy) UnmarshalText(text []byte) error {
	q, err := EqualTimestampStrategyFromString(string(text))
	if err != nil {
		return err
	}
	*p = q
	return nil
}

func (p *EqualTimestampStrategy) Scan(value interface{}) error {
	v, ok := value.(int64)
	if !ok {
		return errors.New("Scan value is not int64")
	}
	*p = EqualTimestampStrategy(v)
	return nil
}

func (p *EqualTimestampStrategy) Value() (driver.Value, error) {
	if p == nil {
		return nil, nil
	}
	return int64(*p), nil
}

// Attributes:
//  - Type
//  - Message
//  - Flags
// 
type Error struct {
	Type ErrorType `thrift:"type,1,required" db:"type" json:"type"`
	Message string `thrift:"message,2,required" db:"message" json:"message"`
	Flags int64 `thrift:"flags,3" db:"flags" json:"flags"`
}

func NewError() *Error {
	return &Error{
		Type: 0,
	}
}



func (p *Error) GetType() ErrorType {
	return p.Type
}



func (p *Error) GetMessage() string {
	return p.Message
}

var Error_Flags_DEFAULT int64 = 0


func (p *Error) GetFlags() int64 {
	return p.Flags
}

func (p *Error) IsSetFlags() bool {
	return p.Flags != Error_Flags_DEFAULT
}

func (p *Error) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetType bool = false;
	var issetMessage bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetType = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetMessage = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetType{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Type is not set"));
	}
	if !issetMessage{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Message is not set"));
	}
	return nil
}

func (p *Error) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := ErrorType(v)
		p.Type = temp
	}
	return nil
}

func (p *Error) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Message = v
	}
	return nil
}

func (p *Error) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Flags = v
	}
	return nil
}

func (p *Error) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Error"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Error) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "type", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:type: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Type)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.type (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:type: ", p), err)
	}
	return err
}

func (p *Error) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "message", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:message: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Message)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.message (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:message: ", p), err)
	}
	return err
}

func (p *Error) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetFlags() {
		if err := oprot.WriteFieldBegin(ctx, "flags", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:flags: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(p.Flags)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.flags (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:flags: ", p), err)
		}
	}
	return err
}

func (p *Error) Equals(other *Error) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Type != other.Type { return false }
	if p.Message != other.Message { return false }
	if p.Flags != other.Flags { return false }
	return true
}

func (p *Error) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Error(%+v)", *p)
}

func (p *Error) Error() string {
	return p.String()
}

func (Error) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*Error)(nil)

func (p *Error) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Error",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Error)(nil)

func (p *Error) Validate() error {
	return nil
}

// Attributes:
//  - Errors
// 
type WriteBatchRawErrors struct {
	Errors []*WriteBatchRawError `thrift:"errors,1,required" db:"errors" json:"errors"`
}

func NewWriteBatchRawErrors() *WriteBatchRawErrors {
	return &WriteBatchRawErrors{}
}



func (p *WriteBatchRawErrors) GetErrors() []*WriteBatchRawError {
	return p.Errors
}

func (p *WriteBatchRawErrors) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetErrors bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetErrors = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetErrors{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Errors is not set"));
	}
	return nil
}

func (p *WriteBatchRawErrors) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteBatchRawError, 0, size)
	p.Errors = tSlice
	for i := 0; i < size; i++ {
		_elem0 := &WriteBatchRawError{}
		if err := _elem0.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem0), err)
		}
		p.Errors = append(p.Errors, _elem0)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchRawErrors) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawErrors"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawErrors) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "errors", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:errors: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Errors)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Errors {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:errors: ", p), err)
	}
	return err
}

func (p *WriteBatchRawErrors) Equals(other *WriteBatchRawErrors) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Errors) != len(other.Errors) { return false }
	for i, _tgt := range p.Errors {
		_src1 := other.Errors[i]
		if !_tgt.Equals(_src1) { return false }
	}
	return true
}

func (p *WriteBatchRawErrors) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawErrors(%+v)", *p)
}

func (p *WriteBatchRawErrors) Error() string {
	return p.String()
}

func (WriteBatchRawErrors) TExceptionType() thrift.TExceptionType {
	return thrift.TExceptionTypeCompiled
}

var _ thrift.TException = (*WriteBatchRawErrors)(nil)

func (p *WriteBatchRawErrors) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawErrors",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawErrors)(nil)

func (p *WriteBatchRawErrors) Validate() error {
	return nil
}

// Attributes:
//  - RangeStart
//  - RangeEnd
//  - NameSpace
//  - ID
//  - RangeType
//  - ResultTimeType
//  - Source
// 
type FetchRequest struct {
	RangeStart int64 `thrift:"rangeStart,1,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,2,required" db:"rangeEnd" json:"rangeEnd"`
	NameSpace string `thrift:"nameSpace,3,required" db:"nameSpace" json:"nameSpace"`
	ID string `thrift:"id,4,required" db:"id" json:"id"`
	RangeType TimeType `thrift:"rangeType,5" db:"rangeType" json:"rangeType"`
	ResultTimeType TimeType `thrift:"resultTimeType,6" db:"resultTimeType" json:"resultTimeType"`
	Source []byte `thrift:"source,7" db:"source" json:"source,omitempty"`
}

func NewFetchRequest() *FetchRequest {
	return &FetchRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
}



func (p *FetchRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *FetchRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *FetchRequest) GetNameSpace() string {
	return p.NameSpace
}



func (p *FetchRequest) GetID() string {
	return p.ID
}

var FetchRequest_RangeType_DEFAULT TimeType = 0


func (p *FetchRequest) GetRangeType() TimeType {
	return p.RangeType
}

var FetchRequest_ResultTimeType_DEFAULT TimeType = 0


func (p *FetchRequest) GetResultTimeType() TimeType {
	return p.ResultTimeType
}

var FetchRequest_Source_DEFAULT []byte


func (p *FetchRequest) GetSource() []byte {
	return p.Source
}

func (p *FetchRequest) IsSetRangeType() bool {
	return p.RangeType != FetchRequest_RangeType_DEFAULT
}

func (p *FetchRequest) IsSetResultTimeType() bool {
	return p.ResultTimeType != FetchRequest_ResultTimeType_DEFAULT
}

func (p *FetchRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *FetchRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetNameSpace bool = false;
	var issetID bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	return nil
}

func (p *FetchRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *FetchRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *FetchRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := TimeType(v)
		p.ResultTimeType = temp
	}
	return nil
}

func (p *FetchRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *FetchRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nameSpace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err)
	}
	return err
}

func (p *FetchRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeType", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:rangeType: ", p), err)
		}
	}
	return err
}

func (p *FetchRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetResultTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "resultTimeType", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:resultTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.ResultTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.resultTimeType (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:resultTimeType: ", p), err)
		}
	}
	return err
}

func (p *FetchRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:source: ", p), err)
		}
	}
	return err
}

func (p *FetchRequest) Equals(other *FetchRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.NameSpace != other.NameSpace { return false }
	if p.ID != other.ID { return false }
	if p.RangeType != other.RangeType { return false }
	if p.ResultTimeType != other.ResultTimeType { return false }
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	return true
}

func (p *FetchRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRequest(%+v)", *p)
}

func (p *FetchRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchRequest)(nil)

func (p *FetchRequest) Validate() error {
	return nil
}

// Attributes:
//  - Datapoints
// 
type FetchResult_ struct {
	Datapoints []*Datapoint `thrift:"datapoints,1,required" db:"datapoints" json:"datapoints"`
}

func NewFetchResult_() *FetchResult_ {
	return &FetchResult_{}
}



func (p *FetchResult_) GetDatapoints() []*Datapoint {
	return p.Datapoints
}

func (p *FetchResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDatapoints bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetDatapoints = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDatapoints{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoints is not set"));
	}
	return nil
}

func (p *FetchResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Datapoint, 0, size)
	p.Datapoints = tSlice
	for i := 0; i < size; i++ {
		_elem2 := &Datapoint{
			TimestampTimeType: 0,
		}
		if err := _elem2.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem2), err)
		}
		p.Datapoints = append(p.Datapoints, _elem2)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoints", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:datapoints: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Datapoints)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Datapoints {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:datapoints: ", p), err)
	}
	return err
}

func (p *FetchResult_) Equals(other *FetchResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Datapoints) != len(other.Datapoints) { return false }
	for i, _tgt := range p.Datapoints {
		_src3 := other.Datapoints[i]
		if !_tgt.Equals(_src3) { return false }
	}
	return true
}

func (p *FetchResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchResult_(%+v)", *p)
}

func (p *FetchResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchResult_)(nil)

func (p *FetchResult_) Validate() error {
	return nil
}

// Attributes:
//  - Timestamp
//  - Value
//  - Annotation
//  - TimestampTimeType
// 
type Datapoint struct {
	Timestamp int64 `thrift:"timestamp,1,required" db:"timestamp" json:"timestamp"`
	Value float64 `thrift:"value,2,required" db:"value" json:"value"`
	Annotation []byte `thrift:"annotation,3" db:"annotation" json:"annotation,omitempty"`
	TimestampTimeType TimeType `thrift:"timestampTimeType,4" db:"timestampTimeType" json:"timestampTimeType"`
}

func NewDatapoint() *Datapoint {
	return &Datapoint{
		TimestampTimeType: 0,
	}
}



func (p *Datapoint) GetTimestamp() int64 {
	return p.Timestamp
}



func (p *Datapoint) GetValue() float64 {
	return p.Value
}

var Datapoint_Annotation_DEFAULT []byte


func (p *Datapoint) GetAnnotation() []byte {
	return p.Annotation
}

var Datapoint_TimestampTimeType_DEFAULT TimeType = 0


func (p *Datapoint) GetTimestampTimeType() TimeType {
	return p.TimestampTimeType
}

func (p *Datapoint) IsSetAnnotation() bool {
	return p.Annotation != nil
}

func (p *Datapoint) IsSetTimestampTimeType() bool {
	return p.TimestampTimeType != Datapoint_TimestampTimeType_DEFAULT
}

func (p *Datapoint) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTimestamp bool = false;
	var issetValue bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTimestamp = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetValue = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTimestamp{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Timestamp is not set"));
	}
	if !issetValue{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"));
	}
	return nil
}

func (p *Datapoint) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *Datapoint) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *Datapoint) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Annotation = v
	}
	return nil
}

func (p *Datapoint) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		temp := TimeType(v)
		p.TimestampTimeType = temp
	}
	return nil
}

func (p *Datapoint) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Datapoint"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Datapoint) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "timestamp", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:timestamp: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Timestamp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.timestamp (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:timestamp: ", p), err)
	}
	return err
}

func (p *Datapoint) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.Value)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
	}
	return err
}

func (p *Datapoint) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAnnotation() {
		if err := oprot.WriteFieldBegin(ctx, "annotation", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:annotation: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Annotation); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.annotation (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:annotation: ", p), err)
		}
	}
	return err
}

func (p *Datapoint) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestampTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "timestampTimeType", thrift.I32, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:timestampTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.TimestampTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.timestampTimeType (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:timestampTimeType: ", p), err)
		}
	}
	return err
}

func (p *Datapoint) Equals(other *Datapoint) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Timestamp != other.Timestamp { return false }
	if p.Value != other.Value { return false }
	if bytes.Compare(p.Annotation, other.Annotation) != 0 { return false }
	if p.TimestampTimeType != other.TimestampTimeType { return false }
	return true
}

func (p *Datapoint) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Datapoint(%+v)", *p)
}

func (p *Datapoint) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Datapoint",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Datapoint)(nil)

func (p *Datapoint) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - ID
//  - Datapoint
// 
type WriteRequest struct {
	NameSpace string `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	ID string `thrift:"id,2,required" db:"id" json:"id"`
	Datapoint *Datapoint `thrift:"datapoint,3,required" db:"datapoint" json:"datapoint"`
}

func NewWriteRequest() *WriteRequest {
	return &WriteRequest{}
}



func (p *WriteRequest) GetNameSpace() string {
	return p.NameSpace
}



func (p *WriteRequest) GetID() string {
	return p.ID
}

var WriteRequest_Datapoint_DEFAULT *Datapoint

func (p *WriteRequest) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteRequest_Datapoint_DEFAULT
	}
	return p.Datapoint
}

func (p *WriteRequest) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetID bool = false;
	var issetDatapoint bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	return nil
}

func (p *WriteRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id: ", p), err)
	}
	return err
}

func (p *WriteRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:datapoint: ", p), err)
	}
	return err
}

func (p *WriteRequest) Equals(other *WriteRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.NameSpace != other.NameSpace { return false }
	if p.ID != other.ID { return false }
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	return true
}

func (p *WriteRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteRequest(%+v)", *p)
}

func (p *WriteRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteRequest)(nil)

func (p *WriteRequest) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - ID
//  - Tags
//  - Datapoint
// 
type WriteTaggedRequest struct {
	NameSpace string `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	ID string `thrift:"id,2,required" db:"id" json:"id"`
	Tags []*Tag `thrift:"tags,3,required" db:"tags" json:"tags"`
	Datapoint *Datapoint `thrift:"datapoint,4,required" db:"datapoint" json:"datapoint"`
}

func NewWriteTaggedRequest() *WriteTaggedRequest {
	return &WriteTaggedRequest{}
}



func (p *WriteTaggedRequest) GetNameSpace() string {
	return p.NameSpace
}



func (p *WriteTaggedRequest) GetID() string {
	return p.ID
}



func (p *WriteTaggedRequest) GetTags() []*Tag {
	return p.Tags
}

var WriteTaggedRequest_Datapoint_DEFAULT *Datapoint

func (p *WriteTaggedRequest) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteTaggedRequest_Datapoint_DEFAULT
	}
	return p.Datapoint
}

func (p *WriteTaggedRequest) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteTaggedRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetID bool = false;
	var issetTags bool = false;
	var issetDatapoint bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetTags = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetTags{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tags is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	return nil
}

func (p *WriteTaggedRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteTaggedRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteTaggedRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Tag, 0, size)
	p.Tags = tSlice
	for i := 0; i < size; i++ {
		_elem4 := &Tag{}
		if err := _elem4.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem4), err)
		}
		p.Tags = append(p.Tags, _elem4)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteTaggedRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteTaggedRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteTaggedRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteTaggedRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteTaggedRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:id: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:id: ", p), err)
	}
	return err
}

func (p *WriteTaggedRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tags", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:tags: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tags)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tags {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:tags: ", p), err)
	}
	return err
}

func (p *WriteTaggedRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:datapoint: ", p), err)
	}
	return err
}

func (p *WriteTaggedRequest) Equals(other *WriteTaggedRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.NameSpace != other.NameSpace { return false }
	if p.ID != other.ID { return false }
	if len(p.Tags) != len(other.Tags) { return false }
	for i, _tgt := range p.Tags {
		_src5 := other.Tags[i]
		if !_tgt.Equals(_src5) { return false }
	}
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	return true
}

func (p *WriteTaggedRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteTaggedRequest(%+v)", *p)
}

func (p *WriteTaggedRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteTaggedRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteTaggedRequest)(nil)

func (p *WriteTaggedRequest) Validate() error {
	return nil
}

// Attributes:
//  - RangeStart
//  - RangeEnd
//  - NameSpace
//  - Ids
//  - RangeTimeType
//  - Source
// 
type FetchBatchRawRequest struct {
	RangeStart int64 `thrift:"rangeStart,1,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,2,required" db:"rangeEnd" json:"rangeEnd"`
	NameSpace []byte `thrift:"nameSpace,3,required" db:"nameSpace" json:"nameSpace"`
	Ids [][]byte `thrift:"ids,4,required" db:"ids" json:"ids"`
	RangeTimeType TimeType `thrift:"rangeTimeType,5" db:"rangeTimeType" json:"rangeTimeType"`
	Source []byte `thrift:"source,6" db:"source" json:"source,omitempty"`
}

func NewFetchBatchRawRequest() *FetchBatchRawRequest {
	return &FetchBatchRawRequest{
		RangeTimeType: 0,
	}
}



func (p *FetchBatchRawRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *FetchBatchRawRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *FetchBatchRawRequest) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *FetchBatchRawRequest) GetIds() [][]byte {
	return p.Ids
}

var FetchBatchRawRequest_RangeTimeType_DEFAULT TimeType = 0


func (p *FetchBatchRawRequest) GetRangeTimeType() TimeType {
	return p.RangeTimeType
}

var FetchBatchRawRequest_Source_DEFAULT []byte


func (p *FetchBatchRawRequest) GetSource() []byte {
	return p.Source
}

func (p *FetchBatchRawRequest) IsSetRangeTimeType() bool {
	return p.RangeTimeType != FetchBatchRawRequest_RangeTimeType_DEFAULT
}

func (p *FetchBatchRawRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *FetchBatchRawRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetNameSpace bool = false;
	var issetIds bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetIds = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetIds{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ids is not set"));
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Ids = tSlice
	for i := 0; i < size; i++ {
		var _elem6 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem6 = v
		}
		p.Ids = append(p.Ids, _elem6)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TimeType(v)
		p.RangeTimeType = temp
	}
	return nil
}

func (p *FetchBatchRawRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *FetchBatchRawRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBatchRawRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBatchRawRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchBatchRawRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchBatchRawRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchBatchRawRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ids", thrift.LIST, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:ids: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.Ids)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Ids {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:ids: ", p), err)
	}
	return err
}

func (p *FetchBatchRawRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeTimeType", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:rangeTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeTimeType (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:rangeTimeType: ", p), err)
		}
	}
	return err
}

func (p *FetchBatchRawRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:source: ", p), err)
		}
	}
	return err
}

func (p *FetchBatchRawRequest) Equals(other *FetchBatchRawRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if len(p.Ids) != len(other.Ids) { return false }
	for i, _tgt := range p.Ids {
		_src7 := other.Ids[i]
		if bytes.Compare(_tgt, _src7) != 0 { return false }
	}
	if p.RangeTimeType != other.RangeTimeType { return false }
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	return true
}

func (p *FetchBatchRawRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBatchRawRequest(%+v)", *p)
}

func (p *FetchBatchRawRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBatchRawRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBatchRawRequest)(nil)

func (p *FetchBatchRawRequest) Validate() error {
	return nil
}

// Attributes:
//  - NameSpaces
//  - Elements
//  - Source
// 
type FetchBatchRawV2Request struct {
	NameSpaces [][]byte `thrift:"nameSpaces,1,required" db:"nameSpaces" json:"nameSpaces"`
	Elements []*FetchBatchRawV2RequestElement `thrift:"elements,2,required" db:"elements" json:"elements"`
	Source []byte `thrift:"source,3" db:"source" json:"source,omitempty"`
}

func NewFetchBatchRawV2Request() *FetchBatchRawV2Request {
	return &FetchBatchRawV2Request{}
}



func (p *FetchBatchRawV2Request) GetNameSpaces() [][]byte {
	return p.NameSpaces
}



func (p *FetchBatchRawV2Request) GetElements() []*FetchBatchRawV2RequestElement {
	return p.Elements
}

var FetchBatchRawV2Request_Source_DEFAULT []byte


func (p *FetchBatchRawV2Request) GetSource() []byte {
	return p.Source
}

func (p *FetchBatchRawV2Request) IsSetSource() bool {
	return p.Source != nil
}

func (p *FetchBatchRawV2Request) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpaces bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpaces = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpaces{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpaces is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *FetchBatchRawV2Request) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.NameSpaces = tSlice
	for i := 0; i < size; i++ {
		var _elem8 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem8 = v
		}
		p.NameSpaces = append(p.NameSpaces, _elem8)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBatchRawV2Request) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FetchBatchRawV2RequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem9 := &FetchBatchRawV2RequestElement{
			RangeTimeType: 0,
		}
		if err := _elem9.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem9), err)
		}
		p.Elements = append(p.Elements, _elem9)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBatchRawV2Request) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *FetchBatchRawV2Request) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBatchRawV2Request"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBatchRawV2Request) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpaces", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpaces: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.NameSpaces)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.NameSpaces {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpaces: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2Request) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:elements: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2Request) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:source: ", p), err)
		}
	}
	return err
}

func (p *FetchBatchRawV2Request) Equals(other *FetchBatchRawV2Request) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.NameSpaces) != len(other.NameSpaces) { return false }
	for i, _tgt := range p.NameSpaces {
		_src10 := other.NameSpaces[i]
		if bytes.Compare(_tgt, _src10) != 0 { return false }
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src11 := other.Elements[i]
		if !_tgt.Equals(_src11) { return false }
	}
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	return true
}

func (p *FetchBatchRawV2Request) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBatchRawV2Request(%+v)", *p)
}

func (p *FetchBatchRawV2Request) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBatchRawV2Request",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBatchRawV2Request)(nil)

func (p *FetchBatchRawV2Request) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - RangeStart
//  - RangeEnd
//  - ID
//  - RangeTimeType
// 
type FetchBatchRawV2RequestElement struct {
	NameSpace int64 `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	RangeStart int64 `thrift:"rangeStart,2,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,3,required" db:"rangeEnd" json:"rangeEnd"`
	ID []byte `thrift:"id,4,required" db:"id" json:"id"`
	RangeTimeType TimeType `thrift:"rangeTimeType,5" db:"rangeTimeType" json:"rangeTimeType"`
}

func NewFetchBatchRawV2RequestElement() *FetchBatchRawV2RequestElement {
	return &FetchBatchRawV2RequestElement{
		RangeTimeType: 0,
	}
}



func (p *FetchBatchRawV2RequestElement) GetNameSpace() int64 {
	return p.NameSpace
}



func (p *FetchBatchRawV2RequestElement) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *FetchBatchRawV2RequestElement) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *FetchBatchRawV2RequestElement) GetID() []byte {
	return p.ID
}

var FetchBatchRawV2RequestElement_RangeTimeType_DEFAULT TimeType = 0


func (p *FetchBatchRawV2RequestElement) GetRangeTimeType() TimeType {
	return p.RangeTimeType
}

func (p *FetchBatchRawV2RequestElement) IsSetRangeTimeType() bool {
	return p.RangeTimeType != FetchBatchRawV2RequestElement_RangeTimeType_DEFAULT
}

func (p *FetchBatchRawV2RequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetID bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		temp := TimeType(v)
		p.RangeTimeType = temp
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBatchRawV2RequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBatchRawV2RequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2RequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2RequestElement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2RequestElement) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:id: ", p), err)
	}
	return err
}

func (p *FetchBatchRawV2RequestElement) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeTimeType", thrift.I32, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:rangeTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeTimeType (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:rangeTimeType: ", p), err)
		}
	}
	return err
}

func (p *FetchBatchRawV2RequestElement) Equals(other *FetchBatchRawV2RequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.NameSpace != other.NameSpace { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if p.RangeTimeType != other.RangeTimeType { return false }
	return true
}

func (p *FetchBatchRawV2RequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBatchRawV2RequestElement(%+v)", *p)
}

func (p *FetchBatchRawV2RequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBatchRawV2RequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBatchRawV2RequestElement)(nil)

func (p *FetchBatchRawV2RequestElement) Validate() error {
	return nil
}

// Attributes:
//  - Elements
// 
type FetchBatchRawResult_ struct {
	Elements []*FetchRawResult_ `thrift:"elements,1,required" db:"elements" json:"elements"`
}

func NewFetchBatchRawResult_() *FetchBatchRawResult_ {
	return &FetchBatchRawResult_{}
}



func (p *FetchBatchRawResult_) GetElements() []*FetchRawResult_ {
	return p.Elements
}

func (p *FetchBatchRawResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *FetchBatchRawResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FetchRawResult_, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem12 := &FetchRawResult_{}
		if err := _elem12.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem12), err)
		}
		p.Elements = append(p.Elements, _elem12)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBatchRawResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBatchRawResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBatchRawResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *FetchBatchRawResult_) Equals(other *FetchBatchRawResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src13 := other.Elements[i]
		if !_tgt.Equals(_src13) { return false }
	}
	return true
}

func (p *FetchBatchRawResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBatchRawResult_(%+v)", *p)
}

func (p *FetchBatchRawResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBatchRawResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBatchRawResult_)(nil)

func (p *FetchBatchRawResult_) Validate() error {
	return nil
}

// Attributes:
//  - Segments
//  - Err
// 
type FetchRawResult_ struct {
	Segments []*Segments `thrift:"segments,1,required" db:"segments" json:"segments"`
	Err *Error `thrift:"err,2" db:"err" json:"err,omitempty"`
}

func NewFetchRawResult_() *FetchRawResult_ {
	return &FetchRawResult_{}
}



func (p *FetchRawResult_) GetSegments() []*Segments {
	return p.Segments
}

var FetchRawResult__Err_DEFAULT *Error

func (p *FetchRawResult_) GetErr() *Error {
	if !p.IsSetErr() {
		return FetchRawResult__Err_DEFAULT
	}
	return p.Err
}

func (p *FetchRawResult_) IsSetErr() bool {
	return p.Err != nil
}

func (p *FetchRawResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetSegments bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetSegments = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetSegments{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Segments is not set"));
	}
	return nil
}

func (p *FetchRawResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Segments, 0, size)
	p.Segments = tSlice
	for i := 0; i < size; i++ {
		_elem14 := &Segments{}
		if err := _elem14.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem14), err)
		}
		p.Segments = append(p.Segments, _elem14)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchRawResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *FetchRawResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchRawResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchRawResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "segments", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:segments: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Segments)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Segments {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:segments: ", p), err)
	}
	return err
}

func (p *FetchRawResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err)
		}
	}
	return err
}

func (p *FetchRawResult_) Equals(other *FetchRawResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Segments) != len(other.Segments) { return false }
	for i, _tgt := range p.Segments {
		_src15 := other.Segments[i]
		if !_tgt.Equals(_src15) { return false }
	}
	if !p.Err.Equals(other.Err) { return false }
	return true
}

func (p *FetchRawResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchRawResult_(%+v)", *p)
}

func (p *FetchRawResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchRawResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchRawResult_)(nil)

func (p *FetchRawResult_) Validate() error {
	return nil
}

// Attributes:
//  - Merged
//  - Unmerged
// 
type Segments struct {
	Merged *Segment `thrift:"merged,1" db:"merged" json:"merged,omitempty"`
	Unmerged []*Segment `thrift:"unmerged,2" db:"unmerged" json:"unmerged,omitempty"`
}

func NewSegments() *Segments {
	return &Segments{}
}

var Segments_Merged_DEFAULT *Segment

func (p *Segments) GetMerged() *Segment {
	if !p.IsSetMerged() {
		return Segments_Merged_DEFAULT
	}
	return p.Merged
}

var Segments_Unmerged_DEFAULT []*Segment


func (p *Segments) GetUnmerged() []*Segment {
	return p.Unmerged
}

func (p *Segments) IsSetMerged() bool {
	return p.Merged != nil
}

func (p *Segments) IsSetUnmerged() bool {
	return p.Unmerged != nil
}

func (p *Segments) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Segments) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Merged = &Segment{}
	if err := p.Merged.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Merged), err)
	}
	return nil
}

func (p *Segments) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Segment, 0, size)
	p.Unmerged = tSlice
	for i := 0; i < size; i++ {
		_elem16 := &Segment{}
		if err := _elem16.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem16), err)
		}
		p.Unmerged = append(p.Unmerged, _elem16)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Segments) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Segments"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Segments) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMerged() {
		if err := oprot.WriteFieldBegin(ctx, "merged", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:merged: ", p), err)
		}
		if err := p.Merged.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Merged), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:merged: ", p), err)
		}
	}
	return err
}

func (p *Segments) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetUnmerged() {
		if err := oprot.WriteFieldBegin(ctx, "unmerged", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:unmerged: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Unmerged)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Unmerged {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:unmerged: ", p), err)
		}
	}
	return err
}

func (p *Segments) Equals(other *Segments) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Merged.Equals(other.Merged) { return false }
	if len(p.Unmerged) != len(other.Unmerged) { return false }
	for i, _tgt := range p.Unmerged {
		_src17 := other.Unmerged[i]
		if !_tgt.Equals(_src17) { return false }
	}
	return true
}

func (p *Segments) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Segments(%+v)", *p)
}

func (p *Segments) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Segments",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Segments)(nil)

func (p *Segments) Validate() error {
	return nil
}

// Attributes:
//  - Head
//  - Tail
//  - StartTime
//  - BlockSize
//  - Checksum
// 
type Segment struct {
	Head []byte `thrift:"head,1,required" db:"head" json:"head"`
	Tail []byte `thrift:"tail,2,required" db:"tail" json:"tail"`
	StartTime *int64 `thrift:"startTime,3" db:"startTime" json:"startTime,omitempty"`
	BlockSize *int64 `thrift:"blockSize,4" db:"blockSize" json:"blockSize,omitempty"`
	Checksum *int64 `thrift:"checksum,5" db:"checksum" json:"checksum,omitempty"`
}

func NewSegment() *Segment {
	return &Segment{}
}



func (p *Segment) GetHead() []byte {
	return p.Head
}



func (p *Segment) GetTail() []byte {
	return p.Tail
}

var Segment_StartTime_DEFAULT int64

func (p *Segment) GetStartTime() int64 {
	if !p.IsSetStartTime() {
		return Segment_StartTime_DEFAULT
	}
	return *p.StartTime
}

var Segment_BlockSize_DEFAULT int64

func (p *Segment) GetBlockSize() int64 {
	if !p.IsSetBlockSize() {
		return Segment_BlockSize_DEFAULT
	}
	return *p.BlockSize
}

var Segment_Checksum_DEFAULT int64

func (p *Segment) GetChecksum() int64 {
	if !p.IsSetChecksum() {
		return Segment_Checksum_DEFAULT
	}
	return *p.Checksum
}

func (p *Segment) IsSetStartTime() bool {
	return p.StartTime != nil
}

func (p *Segment) IsSetBlockSize() bool {
	return p.BlockSize != nil
}

func (p *Segment) IsSetChecksum() bool {
	return p.Checksum != nil
}

func (p *Segment) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetHead bool = false;
	var issetTail bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetHead = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTail = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetHead{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Head is not set"));
	}
	if !issetTail{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tail is not set"));
	}
	return nil
}

func (p *Segment) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Head = v
	}
	return nil
}

func (p *Segment) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Tail = v
	}
	return nil
}

func (p *Segment) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.StartTime = &v
	}
	return nil
}

func (p *Segment) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.BlockSize = &v
	}
	return nil
}

func (p *Segment) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Checksum = &v
	}
	return nil
}

func (p *Segment) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Segment"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Segment) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "head", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:head: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Head); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.head (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:head: ", p), err)
	}
	return err
}

func (p *Segment) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tail", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tail: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Tail); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tail (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tail: ", p), err)
	}
	return err
}

func (p *Segment) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetStartTime() {
		if err := oprot.WriteFieldBegin(ctx, "startTime", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:startTime: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.StartTime)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.startTime (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:startTime: ", p), err)
		}
	}
	return err
}

func (p *Segment) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetBlockSize() {
		if err := oprot.WriteFieldBegin(ctx, "blockSize", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:blockSize: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.BlockSize)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.blockSize (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:blockSize: ", p), err)
		}
	}
	return err
}

func (p *Segment) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetChecksum() {
		if err := oprot.WriteFieldBegin(ctx, "checksum", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:checksum: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Checksum)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.checksum (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:checksum: ", p), err)
		}
	}
	return err
}

func (p *Segment) Equals(other *Segment) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Head, other.Head) != 0 { return false }
	if bytes.Compare(p.Tail, other.Tail) != 0 { return false }
	if p.StartTime != other.StartTime {
		if p.StartTime == nil || other.StartTime == nil {
			return false
		}
		if (*p.StartTime) != (*other.StartTime) { return false }
	}
	if p.BlockSize != other.BlockSize {
		if p.BlockSize == nil || other.BlockSize == nil {
			return false
		}
		if (*p.BlockSize) != (*other.BlockSize) { return false }
	}
	if p.Checksum != other.Checksum {
		if p.Checksum == nil || other.Checksum == nil {
			return false
		}
		if (*p.Checksum) != (*other.Checksum) { return false }
	}
	return true
}

func (p *Segment) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Segment(%+v)", *p)
}

func (p *Segment) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Segment",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Segment)(nil)

func (p *Segment) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - Query
//  - RangeStart
//  - RangeEnd
//  - FetchData
//  - SeriesLimit
//  - RangeTimeType
//  - RequireExhaustive
//  - DocsLimit
//  - Source
//  - RequireNoWait
// 
type FetchTaggedRequest struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	Query []byte `thrift:"query,2,required" db:"query" json:"query"`
	RangeStart int64 `thrift:"rangeStart,3,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,4,required" db:"rangeEnd" json:"rangeEnd"`
	FetchData bool `thrift:"fetchData,5,required" db:"fetchData" json:"fetchData"`
	SeriesLimit *int64 `thrift:"seriesLimit,6" db:"seriesLimit" json:"seriesLimit,omitempty"`
	RangeTimeType TimeType `thrift:"rangeTimeType,7" db:"rangeTimeType" json:"rangeTimeType"`
	RequireExhaustive bool `thrift:"requireExhaustive,8" db:"requireExhaustive" json:"requireExhaustive"`
	DocsLimit *int64 `thrift:"docsLimit,9" db:"docsLimit" json:"docsLimit,omitempty"`
	Source []byte `thrift:"source,10" db:"source" json:"source,omitempty"`
	RequireNoWait bool `thrift:"requireNoWait,11" db:"requireNoWait" json:"requireNoWait"`
}

func NewFetchTaggedRequest() *FetchTaggedRequest {
	return &FetchTaggedRequest{
		RangeTimeType: 0,
		RequireExhaustive: true,
	}
}



func (p *FetchTaggedRequest) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *FetchTaggedRequest) GetQuery() []byte {
	return p.Query
}



func (p *FetchTaggedRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *FetchTaggedRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *FetchTaggedRequest) GetFetchData() bool {
	return p.FetchData
}

var FetchTaggedRequest_SeriesLimit_DEFAULT int64

func (p *FetchTaggedRequest) GetSeriesLimit() int64 {
	if !p.IsSetSeriesLimit() {
		return FetchTaggedRequest_SeriesLimit_DEFAULT
	}
	return *p.SeriesLimit
}

var FetchTaggedRequest_RangeTimeType_DEFAULT TimeType = 0


func (p *FetchTaggedRequest) GetRangeTimeType() TimeType {
	return p.RangeTimeType
}

var FetchTaggedRequest_RequireExhaustive_DEFAULT bool = true


func (p *FetchTaggedRequest) GetRequireExhaustive() bool {
	return p.RequireExhaustive
}

var FetchTaggedRequest_DocsLimit_DEFAULT int64

func (p *FetchTaggedRequest) GetDocsLimit() int64 {
	if !p.IsSetDocsLimit() {
		return FetchTaggedRequest_DocsLimit_DEFAULT
	}
	return *p.DocsLimit
}

var FetchTaggedRequest_Source_DEFAULT []byte


func (p *FetchTaggedRequest) GetSource() []byte {
	return p.Source
}

var FetchTaggedRequest_RequireNoWait_DEFAULT bool = false


func (p *FetchTaggedRequest) GetRequireNoWait() bool {
	return p.RequireNoWait
}

func (p *FetchTaggedRequest) IsSetSeriesLimit() bool {
	return p.SeriesLimit != nil
}

func (p *FetchTaggedRequest) IsSetRangeTimeType() bool {
	return p.RangeTimeType != FetchTaggedRequest_RangeTimeType_DEFAULT
}

func (p *FetchTaggedRequest) IsSetRequireExhaustive() bool {
	return p.RequireExhaustive != FetchTaggedRequest_RequireExhaustive_DEFAULT
}

func (p *FetchTaggedRequest) IsSetDocsLimit() bool {
	return p.DocsLimit != nil
}

func (p *FetchTaggedRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *FetchTaggedRequest) IsSetRequireNoWait() bool {
	return p.RequireNoWait != FetchTaggedRequest_RequireNoWait_DEFAULT
}

func (p *FetchTaggedRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetQuery bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetFetchData bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetQuery = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
				issetFetchData = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetQuery{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetFetchData{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field FetchData is not set"));
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.FetchData = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.SeriesLimit = &v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := TimeType(v)
		p.RangeTimeType = temp
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.RequireExhaustive = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.DocsLimit = &v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *FetchTaggedRequest) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.RequireNoWait = v
	}
	return nil
}

func (p *FetchTaggedRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchTaggedRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchTaggedRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchTaggedRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:query: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:query: ", p), err)
	}
	return err
}

func (p *FetchTaggedRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchTaggedRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchTaggedRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "fetchData", thrift.BOOL, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:fetchData: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.FetchData)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.fetchData (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:fetchData: ", p), err)
	}
	return err
}

func (p *FetchTaggedRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSeriesLimit() {
		if err := oprot.WriteFieldBegin(ctx, "seriesLimit", thrift.I64, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:seriesLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.SeriesLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.seriesLimit (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:seriesLimit: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeTimeType", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:rangeTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeTimeType (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:rangeTimeType: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireExhaustive() {
		if err := oprot.WriteFieldBegin(ctx, "requireExhaustive", thrift.BOOL, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:requireExhaustive: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(p.RequireExhaustive)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireExhaustive (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:requireExhaustive: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDocsLimit() {
		if err := oprot.WriteFieldBegin(ctx, "docsLimit", thrift.I64, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:docsLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.DocsLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.docsLimit (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:docsLimit: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:source: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireNoWait() {
		if err := oprot.WriteFieldBegin(ctx, "requireNoWait", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:requireNoWait: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(p.RequireNoWait)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireNoWait (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:requireNoWait: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedRequest) Equals(other *FetchTaggedRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if bytes.Compare(p.Query, other.Query) != 0 { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.FetchData != other.FetchData { return false }
	if p.SeriesLimit != other.SeriesLimit {
		if p.SeriesLimit == nil || other.SeriesLimit == nil {
			return false
		}
		if (*p.SeriesLimit) != (*other.SeriesLimit) { return false }
	}
	if p.RangeTimeType != other.RangeTimeType { return false }
	if p.RequireExhaustive != other.RequireExhaustive { return false }
	if p.DocsLimit != other.DocsLimit {
		if p.DocsLimit == nil || other.DocsLimit == nil {
			return false
		}
		if (*p.DocsLimit) != (*other.DocsLimit) { return false }
	}
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	if p.RequireNoWait != other.RequireNoWait { return false }
	return true
}

func (p *FetchTaggedRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchTaggedRequest(%+v)", *p)
}

func (p *FetchTaggedRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchTaggedRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchTaggedRequest)(nil)

func (p *FetchTaggedRequest) Validate() error {
	return nil
}

// Attributes:
//  - Elements
//  - Exhaustive
//  - WaitedIndex
//  - WaitedSeriesRead
// 
type FetchTaggedResult_ struct {
	Elements []*FetchTaggedIDResult_ `thrift:"elements,1,required" db:"elements" json:"elements"`
	Exhaustive bool `thrift:"exhaustive,2,required" db:"exhaustive" json:"exhaustive"`
	WaitedIndex *int64 `thrift:"waitedIndex,3" db:"waitedIndex" json:"waitedIndex,omitempty"`
	WaitedSeriesRead *int64 `thrift:"waitedSeriesRead,4" db:"waitedSeriesRead" json:"waitedSeriesRead,omitempty"`
}

func NewFetchTaggedResult_() *FetchTaggedResult_ {
	return &FetchTaggedResult_{}
}



func (p *FetchTaggedResult_) GetElements() []*FetchTaggedIDResult_ {
	return p.Elements
}



func (p *FetchTaggedResult_) GetExhaustive() bool {
	return p.Exhaustive
}

var FetchTaggedResult__WaitedIndex_DEFAULT int64

func (p *FetchTaggedResult_) GetWaitedIndex() int64 {
	if !p.IsSetWaitedIndex() {
		return FetchTaggedResult__WaitedIndex_DEFAULT
	}
	return *p.WaitedIndex
}

var FetchTaggedResult__WaitedSeriesRead_DEFAULT int64

func (p *FetchTaggedResult_) GetWaitedSeriesRead() int64 {
	if !p.IsSetWaitedSeriesRead() {
		return FetchTaggedResult__WaitedSeriesRead_DEFAULT
	}
	return *p.WaitedSeriesRead
}

func (p *FetchTaggedResult_) IsSetWaitedIndex() bool {
	return p.WaitedIndex != nil
}

func (p *FetchTaggedResult_) IsSetWaitedSeriesRead() bool {
	return p.WaitedSeriesRead != nil
}

func (p *FetchTaggedResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false;
	var issetExhaustive bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetExhaustive = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	if !issetExhaustive{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Exhaustive is not set"));
	}
	return nil
}

func (p *FetchTaggedResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FetchTaggedIDResult_, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem18 := &FetchTaggedIDResult_{}
		if err := _elem18.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem18), err)
		}
		p.Elements = append(p.Elements, _elem18)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchTaggedResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Exhaustive = v
	}
	return nil
}

func (p *FetchTaggedResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.WaitedIndex = &v
	}
	return nil
}

func (p *FetchTaggedResult_) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.WaitedSeriesRead = &v
	}
	return nil
}

func (p *FetchTaggedResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchTaggedResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchTaggedResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *FetchTaggedResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "exhaustive", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:exhaustive: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Exhaustive)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.exhaustive (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:exhaustive: ", p), err)
	}
	return err
}

func (p *FetchTaggedResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetWaitedIndex() {
		if err := oprot.WriteFieldBegin(ctx, "waitedIndex", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:waitedIndex: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.WaitedIndex)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.waitedIndex (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:waitedIndex: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetWaitedSeriesRead() {
		if err := oprot.WriteFieldBegin(ctx, "waitedSeriesRead", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:waitedSeriesRead: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.WaitedSeriesRead)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.waitedSeriesRead (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:waitedSeriesRead: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedResult_) Equals(other *FetchTaggedResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src19 := other.Elements[i]
		if !_tgt.Equals(_src19) { return false }
	}
	if p.Exhaustive != other.Exhaustive { return false }
	if p.WaitedIndex != other.WaitedIndex {
		if p.WaitedIndex == nil || other.WaitedIndex == nil {
			return false
		}
		if (*p.WaitedIndex) != (*other.WaitedIndex) { return false }
	}
	if p.WaitedSeriesRead != other.WaitedSeriesRead {
		if p.WaitedSeriesRead == nil || other.WaitedSeriesRead == nil {
			return false
		}
		if (*p.WaitedSeriesRead) != (*other.WaitedSeriesRead) { return false }
	}
	return true
}

func (p *FetchTaggedResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchTaggedResult_(%+v)", *p)
}

func (p *FetchTaggedResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchTaggedResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchTaggedResult_)(nil)

func (p *FetchTaggedResult_) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - NameSpace
//  - EncodedTags
//  - Segments
//  - Err
// 
type FetchTaggedIDResult_ struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	NameSpace []byte `thrift:"nameSpace,2,required" db:"nameSpace" json:"nameSpace"`
	EncodedTags []byte `thrift:"encodedTags,3,required" db:"encodedTags" json:"encodedTags"`
	Segments []*Segments `thrift:"segments,4" db:"segments" json:"segments,omitempty"`
	Err *Error `thrift:"err,5" db:"err" json:"err,omitempty"`
}

func NewFetchTaggedIDResult_() *FetchTaggedIDResult_ {
	return &FetchTaggedIDResult_{}
}



func (p *FetchTaggedIDResult_) GetID() []byte {
	return p.ID
}



func (p *FetchTaggedIDResult_) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *FetchTaggedIDResult_) GetEncodedTags() []byte {
	return p.EncodedTags
}

var FetchTaggedIDResult__Segments_DEFAULT []*Segments


func (p *FetchTaggedIDResult_) GetSegments() []*Segments {
	return p.Segments
}

var FetchTaggedIDResult__Err_DEFAULT *Error

func (p *FetchTaggedIDResult_) GetErr() *Error {
	if !p.IsSetErr() {
		return FetchTaggedIDResult__Err_DEFAULT
	}
	return p.Err
}

func (p *FetchTaggedIDResult_) IsSetSegments() bool {
	return p.Segments != nil
}

func (p *FetchTaggedIDResult_) IsSetErr() bool {
	return p.Err != nil
}

func (p *FetchTaggedIDResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetNameSpace bool = false;
	var issetEncodedTags bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetEncodedTags = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetEncodedTags{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EncodedTags is not set"));
	}
	return nil
}

func (p *FetchTaggedIDResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *FetchTaggedIDResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchTaggedIDResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.EncodedTags = v
	}
	return nil
}

func (p *FetchTaggedIDResult_) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Segments, 0, size)
	p.Segments = tSlice
	for i := 0; i < size; i++ {
		_elem20 := &Segments{}
		if err := _elem20.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem20), err)
		}
		p.Segments = append(p.Segments, _elem20)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchTaggedIDResult_) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *FetchTaggedIDResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchTaggedIDResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchTaggedIDResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *FetchTaggedIDResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchTaggedIDResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "encodedTags", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:encodedTags: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.EncodedTags); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.encodedTags (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:encodedTags: ", p), err)
	}
	return err
}

func (p *FetchTaggedIDResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSegments() {
		if err := oprot.WriteFieldBegin(ctx, "segments", thrift.LIST, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:segments: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Segments)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Segments {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:segments: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedIDResult_) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:err: ", p), err)
		}
	}
	return err
}

func (p *FetchTaggedIDResult_) Equals(other *FetchTaggedIDResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if bytes.Compare(p.EncodedTags, other.EncodedTags) != 0 { return false }
	if len(p.Segments) != len(other.Segments) { return false }
	for i, _tgt := range p.Segments {
		_src21 := other.Segments[i]
		if !_tgt.Equals(_src21) { return false }
	}
	if !p.Err.Equals(other.Err) { return false }
	return true
}

func (p *FetchTaggedIDResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchTaggedIDResult_(%+v)", *p)
}

func (p *FetchTaggedIDResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchTaggedIDResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchTaggedIDResult_)(nil)

func (p *FetchTaggedIDResult_) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - Shard
//  - Elements
//  - Source
// 
type FetchBlocksRawRequest struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	Shard int32 `thrift:"shard,2,required" db:"shard" json:"shard"`
	Elements []*FetchBlocksRawRequestElement `thrift:"elements,3,required" db:"elements" json:"elements"`
	Source []byte `thrift:"source,4" db:"source" json:"source,omitempty"`
}

func NewFetchBlocksRawRequest() *FetchBlocksRawRequest {
	return &FetchBlocksRawRequest{}
}



func (p *FetchBlocksRawRequest) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *FetchBlocksRawRequest) GetShard() int32 {
	return p.Shard
}



func (p *FetchBlocksRawRequest) GetElements() []*FetchBlocksRawRequestElement {
	return p.Elements
}

var FetchBlocksRawRequest_Source_DEFAULT []byte


func (p *FetchBlocksRawRequest) GetSource() []byte {
	return p.Source
}

func (p *FetchBlocksRawRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *FetchBlocksRawRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetShard bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetShard = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetShard{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Shard is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *FetchBlocksRawRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchBlocksRawRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Shard = v
	}
	return nil
}

func (p *FetchBlocksRawRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*FetchBlocksRawRequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem22 := &FetchBlocksRawRequestElement{}
		if err := _elem22.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem22), err)
		}
		p.Elements = append(p.Elements, _elem22)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBlocksRawRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *FetchBlocksRawRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBlocksRawRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBlocksRawRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "shard", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:shard: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Shard)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.shard (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:shard: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:elements: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:source: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksRawRequest) Equals(other *FetchBlocksRawRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if p.Shard != other.Shard { return false }
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src23 := other.Elements[i]
		if !_tgt.Equals(_src23) { return false }
	}
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	return true
}

func (p *FetchBlocksRawRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBlocksRawRequest(%+v)", *p)
}

func (p *FetchBlocksRawRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBlocksRawRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBlocksRawRequest)(nil)

func (p *FetchBlocksRawRequest) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Starts
// 
type FetchBlocksRawRequestElement struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	Starts []int64 `thrift:"starts,2,required" db:"starts" json:"starts"`
}

func NewFetchBlocksRawRequestElement() *FetchBlocksRawRequestElement {
	return &FetchBlocksRawRequestElement{}
}



func (p *FetchBlocksRawRequestElement) GetID() []byte {
	return p.ID
}



func (p *FetchBlocksRawRequestElement) GetStarts() []int64 {
	return p.Starts
}

func (p *FetchBlocksRawRequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetStarts bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetStarts = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetStarts{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Starts is not set"));
	}
	return nil
}

func (p *FetchBlocksRawRequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *FetchBlocksRawRequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]int64, 0, size)
	p.Starts = tSlice
	for i := 0; i < size; i++ {
		var _elem24 int64
		if v, err := iprot.ReadI64(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem24 = v
		}
		p.Starts = append(p.Starts, _elem24)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBlocksRawRequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBlocksRawRequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBlocksRawRequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawRequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "starts", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:starts: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.I64, len(p.Starts)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Starts {
		if err := oprot.WriteI64(ctx, int64(v)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:starts: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawRequestElement) Equals(other *FetchBlocksRawRequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if len(p.Starts) != len(other.Starts) { return false }
	for i, _tgt := range p.Starts {
		_src25 := other.Starts[i]
		if _tgt != _src25 { return false }
	}
	return true
}

func (p *FetchBlocksRawRequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBlocksRawRequestElement(%+v)", *p)
}

func (p *FetchBlocksRawRequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBlocksRawRequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBlocksRawRequestElement)(nil)

func (p *FetchBlocksRawRequestElement) Validate() error {
	return nil
}

// Attributes:
//  - Elements
// 
type FetchBlocksRawResult_ struct {
	Elements []*Blocks `thrift:"elements,1,required" db:"elements" json:"elements"`
}

func NewFetchBlocksRawResult_() *FetchBlocksRawResult_ {
	return &FetchBlocksRawResult_{}
}



func (p *FetchBlocksRawResult_) GetElements() []*Blocks {
	return p.Elements
}

func (p *FetchBlocksRawResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *FetchBlocksRawResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Blocks, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem26 := &Blocks{}
		if err := _elem26.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem26), err)
		}
		p.Elements = append(p.Elements, _elem26)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBlocksRawResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBlocksRawResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBlocksRawResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *FetchBlocksRawResult_) Equals(other *FetchBlocksRawResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src27 := other.Elements[i]
		if !_tgt.Equals(_src27) { return false }
	}
	return true
}

func (p *FetchBlocksRawResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBlocksRawResult_(%+v)", *p)
}

func (p *FetchBlocksRawResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBlocksRawResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBlocksRawResult_)(nil)

func (p *FetchBlocksRawResult_) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Blocks
// 
type Blocks struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	Blocks []*Block `thrift:"blocks,2,required" db:"blocks" json:"blocks"`
}

func NewBlocks() *Blocks {
	return &Blocks{}
}



func (p *Blocks) GetID() []byte {
	return p.ID
}



func (p *Blocks) GetBlocks() []*Block {
	return p.Blocks
}

func (p *Blocks) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetBlocks bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetBlocks = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetBlocks{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Blocks is not set"));
	}
	return nil
}

func (p *Blocks) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *Blocks) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Block, 0, size)
	p.Blocks = tSlice
	for i := 0; i < size; i++ {
		_elem28 := &Block{}
		if err := _elem28.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem28), err)
		}
		p.Blocks = append(p.Blocks, _elem28)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *Blocks) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Blocks"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Blocks) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *Blocks) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "blocks", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:blocks: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Blocks)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Blocks {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:blocks: ", p), err)
	}
	return err
}

func (p *Blocks) Equals(other *Blocks) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if len(p.Blocks) != len(other.Blocks) { return false }
	for i, _tgt := range p.Blocks {
		_src29 := other.Blocks[i]
		if !_tgt.Equals(_src29) { return false }
	}
	return true
}

func (p *Blocks) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Blocks(%+v)", *p)
}

func (p *Blocks) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Blocks",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Blocks)(nil)

func (p *Blocks) Validate() error {
	return nil
}

// Attributes:
//  - Start
//  - Segments
//  - Err
//  - Checksum
// 
type Block struct {
	Start int64 `thrift:"start,1,required" db:"start" json:"start"`
	Segments *Segments `thrift:"segments,2" db:"segments" json:"segments,omitempty"`
	Err *Error `thrift:"err,3" db:"err" json:"err,omitempty"`
	Checksum *int64 `thrift:"checksum,4" db:"checksum" json:"checksum,omitempty"`
}

func NewBlock() *Block {
	return &Block{}
}



func (p *Block) GetStart() int64 {
	return p.Start
}

var Block_Segments_DEFAULT *Segments

func (p *Block) GetSegments() *Segments {
	if !p.IsSetSegments() {
		return Block_Segments_DEFAULT
	}
	return p.Segments
}

var Block_Err_DEFAULT *Error

func (p *Block) GetErr() *Error {
	if !p.IsSetErr() {
		return Block_Err_DEFAULT
	}
	return p.Err
}

var Block_Checksum_DEFAULT int64

func (p *Block) GetChecksum() int64 {
	if !p.IsSetChecksum() {
		return Block_Checksum_DEFAULT
	}
	return *p.Checksum
}

func (p *Block) IsSetSegments() bool {
	return p.Segments != nil
}

func (p *Block) IsSetErr() bool {
	return p.Err != nil
}

func (p *Block) IsSetChecksum() bool {
	return p.Checksum != nil
}

func (p *Block) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetStart bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Start is not set"));
	}
	return nil
}

func (p *Block) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *Block) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Segments = &Segments{}
	if err := p.Segments.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Segments), err)
	}
	return nil
}

func (p *Block) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *Block) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Checksum = &v
	}
	return nil
}

func (p *Block) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Block"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Block) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "start", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:start: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Start)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:start: ", p), err)
	}
	return err
}

func (p *Block) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSegments() {
		if err := oprot.WriteFieldBegin(ctx, "segments", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:segments: ", p), err)
		}
		if err := p.Segments.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Segments), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:segments: ", p), err)
		}
	}
	return err
}

func (p *Block) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:err: ", p), err)
		}
	}
	return err
}

func (p *Block) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetChecksum() {
		if err := oprot.WriteFieldBegin(ctx, "checksum", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:checksum: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Checksum)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.checksum (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:checksum: ", p), err)
		}
	}
	return err
}

func (p *Block) Equals(other *Block) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Start != other.Start { return false }
	if !p.Segments.Equals(other.Segments) { return false }
	if !p.Err.Equals(other.Err) { return false }
	if p.Checksum != other.Checksum {
		if p.Checksum == nil || other.Checksum == nil {
			return false
		}
		if (*p.Checksum) != (*other.Checksum) { return false }
	}
	return true
}

func (p *Block) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Block(%+v)", *p)
}

func (p *Block) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Block",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Block)(nil)

func (p *Block) Validate() error {
	return nil
}

// Attributes:
//  - Name
//  - Value
// 
type Tag struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
	Value string `thrift:"value,2,required" db:"value" json:"value"`
}

func NewTag() *Tag {
	return &Tag{}
}



func (p *Tag) GetName() string {
	return p.Name
}



func (p *Tag) GetValue() string {
	return p.Value
}

func (p *Tag) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false;
	var issetValue bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetValue = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
	}
	if !issetValue{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Value is not set"));
	}
	return nil
}

func (p *Tag) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *Tag) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *Tag) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Tag"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Tag) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *Tag) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "value", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:value: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Value)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.value (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:value: ", p), err)
	}
	return err
}

func (p *Tag) Equals(other *Tag) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Name != other.Name { return false }
	if p.Value != other.Value { return false }
	return true
}

func (p *Tag) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Tag(%+v)", *p)
}

func (p *Tag) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Tag",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Tag)(nil)

func (p *Tag) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - Shard
//  - RangeStart
//  - RangeEnd
//  - Limit
//  - PageToken
//  - IncludeSizes
//  - IncludeChecksums
//  - IncludeLastRead
// 
type FetchBlocksMetadataRawV2Request struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	Shard int32 `thrift:"shard,2,required" db:"shard" json:"shard"`
	RangeStart int64 `thrift:"rangeStart,3,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,4,required" db:"rangeEnd" json:"rangeEnd"`
	Limit int64 `thrift:"limit,5,required" db:"limit" json:"limit"`
	PageToken []byte `thrift:"pageToken,6" db:"pageToken" json:"pageToken,omitempty"`
	IncludeSizes *bool `thrift:"includeSizes,7" db:"includeSizes" json:"includeSizes,omitempty"`
	IncludeChecksums *bool `thrift:"includeChecksums,8" db:"includeChecksums" json:"includeChecksums,omitempty"`
	IncludeLastRead *bool `thrift:"includeLastRead,9" db:"includeLastRead" json:"includeLastRead,omitempty"`
}

func NewFetchBlocksMetadataRawV2Request() *FetchBlocksMetadataRawV2Request {
	return &FetchBlocksMetadataRawV2Request{}
}



func (p *FetchBlocksMetadataRawV2Request) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *FetchBlocksMetadataRawV2Request) GetShard() int32 {
	return p.Shard
}



func (p *FetchBlocksMetadataRawV2Request) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *FetchBlocksMetadataRawV2Request) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *FetchBlocksMetadataRawV2Request) GetLimit() int64 {
	return p.Limit
}

var FetchBlocksMetadataRawV2Request_PageToken_DEFAULT []byte


func (p *FetchBlocksMetadataRawV2Request) GetPageToken() []byte {
	return p.PageToken
}

var FetchBlocksMetadataRawV2Request_IncludeSizes_DEFAULT bool

func (p *FetchBlocksMetadataRawV2Request) GetIncludeSizes() bool {
	if !p.IsSetIncludeSizes() {
		return FetchBlocksMetadataRawV2Request_IncludeSizes_DEFAULT
	}
	return *p.IncludeSizes
}

var FetchBlocksMetadataRawV2Request_IncludeChecksums_DEFAULT bool

func (p *FetchBlocksMetadataRawV2Request) GetIncludeChecksums() bool {
	if !p.IsSetIncludeChecksums() {
		return FetchBlocksMetadataRawV2Request_IncludeChecksums_DEFAULT
	}
	return *p.IncludeChecksums
}

var FetchBlocksMetadataRawV2Request_IncludeLastRead_DEFAULT bool

func (p *FetchBlocksMetadataRawV2Request) GetIncludeLastRead() bool {
	if !p.IsSetIncludeLastRead() {
		return FetchBlocksMetadataRawV2Request_IncludeLastRead_DEFAULT
	}
	return *p.IncludeLastRead
}

func (p *FetchBlocksMetadataRawV2Request) IsSetPageToken() bool {
	return p.PageToken != nil
}

func (p *FetchBlocksMetadataRawV2Request) IsSetIncludeSizes() bool {
	return p.IncludeSizes != nil
}

func (p *FetchBlocksMetadataRawV2Request) IsSetIncludeChecksums() bool {
	return p.IncludeChecksums != nil
}

func (p *FetchBlocksMetadataRawV2Request) IsSetIncludeLastRead() bool {
	return p.IncludeLastRead != nil
}

func (p *FetchBlocksMetadataRawV2Request) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetShard bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetLimit bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetShard = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
				issetLimit = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetShard{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Shard is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetLimit{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Limit is not set"));
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Shard = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Limit = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.PageToken = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.IncludeSizes = &v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.IncludeChecksums = &v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.IncludeLastRead = &v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBlocksMetadataRawV2Request"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Request) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "shard", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:shard: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.Shard)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.shard (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:shard: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeStart: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rangeEnd: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:limit: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Limit)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.limit (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:limit: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetPageToken() {
		if err := oprot.WriteFieldBegin(ctx, "pageToken", thrift.STRING, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:pageToken: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.PageToken); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.pageToken (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:pageToken: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIncludeSizes() {
		if err := oprot.WriteFieldBegin(ctx, "includeSizes", thrift.BOOL, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:includeSizes: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.IncludeSizes)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.includeSizes (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:includeSizes: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIncludeChecksums() {
		if err := oprot.WriteFieldBegin(ctx, "includeChecksums", thrift.BOOL, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:includeChecksums: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.IncludeChecksums)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.includeChecksums (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:includeChecksums: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetIncludeLastRead() {
		if err := oprot.WriteFieldBegin(ctx, "includeLastRead", thrift.BOOL, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:includeLastRead: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.IncludeLastRead)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.includeLastRead (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:includeLastRead: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Request) Equals(other *FetchBlocksMetadataRawV2Request) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if p.Shard != other.Shard { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.Limit != other.Limit { return false }
	if bytes.Compare(p.PageToken, other.PageToken) != 0 { return false }
	if p.IncludeSizes != other.IncludeSizes {
		if p.IncludeSizes == nil || other.IncludeSizes == nil {
			return false
		}
		if (*p.IncludeSizes) != (*other.IncludeSizes) { return false }
	}
	if p.IncludeChecksums != other.IncludeChecksums {
		if p.IncludeChecksums == nil || other.IncludeChecksums == nil {
			return false
		}
		if (*p.IncludeChecksums) != (*other.IncludeChecksums) { return false }
	}
	if p.IncludeLastRead != other.IncludeLastRead {
		if p.IncludeLastRead == nil || other.IncludeLastRead == nil {
			return false
		}
		if (*p.IncludeLastRead) != (*other.IncludeLastRead) { return false }
	}
	return true
}

func (p *FetchBlocksMetadataRawV2Request) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBlocksMetadataRawV2Request(%+v)", *p)
}

func (p *FetchBlocksMetadataRawV2Request) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBlocksMetadataRawV2Request",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBlocksMetadataRawV2Request)(nil)

func (p *FetchBlocksMetadataRawV2Request) Validate() error {
	return nil
}

// Attributes:
//  - Elements
//  - NextPageToken
// 
type FetchBlocksMetadataRawV2Result_ struct {
	Elements []*BlockMetadataV2 `thrift:"elements,1,required" db:"elements" json:"elements"`
	NextPageToken []byte `thrift:"nextPageToken,2" db:"nextPageToken" json:"nextPageToken,omitempty"`
}

func NewFetchBlocksMetadataRawV2Result_() *FetchBlocksMetadataRawV2Result_ {
	return &FetchBlocksMetadataRawV2Result_{}
}



func (p *FetchBlocksMetadataRawV2Result_) GetElements() []*BlockMetadataV2 {
	return p.Elements
}

var FetchBlocksMetadataRawV2Result__NextPageToken_DEFAULT []byte


func (p *FetchBlocksMetadataRawV2Result_) GetNextPageToken() []byte {
	return p.NextPageToken
}

func (p *FetchBlocksMetadataRawV2Result_) IsSetNextPageToken() bool {
	return p.NextPageToken != nil
}

func (p *FetchBlocksMetadataRawV2Result_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Result_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*BlockMetadataV2, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem30 := &BlockMetadataV2{
			LastReadTimeType: 0,
		}
		if err := _elem30.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem30), err)
		}
		p.Elements = append(p.Elements, _elem30)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Result_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.NextPageToken = v
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Result_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FetchBlocksMetadataRawV2Result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FetchBlocksMetadataRawV2Result_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:elements: ", p), err)
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Result_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetNextPageToken() {
		if err := oprot.WriteFieldBegin(ctx, "nextPageToken", thrift.STRING, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:nextPageToken: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.NextPageToken); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.nextPageToken (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:nextPageToken: ", p), err)
		}
	}
	return err
}

func (p *FetchBlocksMetadataRawV2Result_) Equals(other *FetchBlocksMetadataRawV2Result_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src31 := other.Elements[i]
		if !_tgt.Equals(_src31) { return false }
	}
	if bytes.Compare(p.NextPageToken, other.NextPageToken) != 0 { return false }
	return true
}

func (p *FetchBlocksMetadataRawV2Result_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchBlocksMetadataRawV2Result_(%+v)", *p)
}

func (p *FetchBlocksMetadataRawV2Result_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FetchBlocksMetadataRawV2Result_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FetchBlocksMetadataRawV2Result_)(nil)

func (p *FetchBlocksMetadataRawV2Result_) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Start
//  - Err
//  - Size
//  - Checksum
//  - LastRead
//  - LastReadTimeType
//  - EncodedTags
// 
type BlockMetadataV2 struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	Start int64 `thrift:"start,2,required" db:"start" json:"start"`
	Err *Error `thrift:"err,3" db:"err" json:"err,omitempty"`
	Size *int64 `thrift:"size,4" db:"size" json:"size,omitempty"`
	Checksum *int64 `thrift:"checksum,5" db:"checksum" json:"checksum,omitempty"`
	LastRead *int64 `thrift:"lastRead,6" db:"lastRead" json:"lastRead,omitempty"`
	LastReadTimeType TimeType `thrift:"lastReadTimeType,7" db:"lastReadTimeType" json:"lastReadTimeType"`
	EncodedTags []byte `thrift:"encodedTags,8" db:"encodedTags" json:"encodedTags,omitempty"`
}

func NewBlockMetadataV2() *BlockMetadataV2 {
	return &BlockMetadataV2{
		LastReadTimeType: 0,
	}
}



func (p *BlockMetadataV2) GetID() []byte {
	return p.ID
}



func (p *BlockMetadataV2) GetStart() int64 {
	return p.Start
}

var BlockMetadataV2_Err_DEFAULT *Error

func (p *BlockMetadataV2) GetErr() *Error {
	if !p.IsSetErr() {
		return BlockMetadataV2_Err_DEFAULT
	}
	return p.Err
}

var BlockMetadataV2_Size_DEFAULT int64

func (p *BlockMetadataV2) GetSize() int64 {
	if !p.IsSetSize() {
		return BlockMetadataV2_Size_DEFAULT
	}
	return *p.Size
}

var BlockMetadataV2_Checksum_DEFAULT int64

func (p *BlockMetadataV2) GetChecksum() int64 {
	if !p.IsSetChecksum() {
		return BlockMetadataV2_Checksum_DEFAULT
	}
	return *p.Checksum
}

var BlockMetadataV2_LastRead_DEFAULT int64

func (p *BlockMetadataV2) GetLastRead() int64 {
	if !p.IsSetLastRead() {
		return BlockMetadataV2_LastRead_DEFAULT
	}
	return *p.LastRead
}

var BlockMetadataV2_LastReadTimeType_DEFAULT TimeType = 0


func (p *BlockMetadataV2) GetLastReadTimeType() TimeType {
	return p.LastReadTimeType
}

var BlockMetadataV2_EncodedTags_DEFAULT []byte


func (p *BlockMetadataV2) GetEncodedTags() []byte {
	return p.EncodedTags
}

func (p *BlockMetadataV2) IsSetErr() bool {
	return p.Err != nil
}

func (p *BlockMetadataV2) IsSetSize() bool {
	return p.Size != nil
}

func (p *BlockMetadataV2) IsSetChecksum() bool {
	return p.Checksum != nil
}

func (p *BlockMetadataV2) IsSetLastRead() bool {
	return p.LastRead != nil
}

func (p *BlockMetadataV2) IsSetLastReadTimeType() bool {
	return p.LastReadTimeType != BlockMetadataV2_LastReadTimeType_DEFAULT
}

func (p *BlockMetadataV2) IsSetEncodedTags() bool {
	return p.EncodedTags != nil
}

func (p *BlockMetadataV2) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetStart bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Start is not set"));
	}
	return nil
}

func (p *BlockMetadataV2) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *BlockMetadataV2) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Start = v
	}
	return nil
}

func (p *BlockMetadataV2) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *BlockMetadataV2) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Size = &v
	}
	return nil
}

func (p *BlockMetadataV2) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Checksum = &v
	}
	return nil
}

func (p *BlockMetadataV2) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.LastRead = &v
	}
	return nil
}

func (p *BlockMetadataV2) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := TimeType(v)
		p.LastReadTimeType = temp
	}
	return nil
}

func (p *BlockMetadataV2) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.EncodedTags = v
	}
	return nil
}

func (p *BlockMetadataV2) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "BlockMetadataV2"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *BlockMetadataV2) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *BlockMetadataV2) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "start", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:start: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Start)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.start (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:start: ", p), err)
	}
	return err
}

func (p *BlockMetadataV2) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:err: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSize() {
		if err := oprot.WriteFieldBegin(ctx, "size", thrift.I64, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:size: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Size)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.size (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:size: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetChecksum() {
		if err := oprot.WriteFieldBegin(ctx, "checksum", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:checksum: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Checksum)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.checksum (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:checksum: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLastRead() {
		if err := oprot.WriteFieldBegin(ctx, "lastRead", thrift.I64, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:lastRead: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.LastRead)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.lastRead (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:lastRead: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLastReadTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "lastReadTimeType", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:lastReadTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.LastReadTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.lastReadTimeType (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:lastReadTimeType: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetEncodedTags() {
		if err := oprot.WriteFieldBegin(ctx, "encodedTags", thrift.STRING, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:encodedTags: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.EncodedTags); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.encodedTags (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:encodedTags: ", p), err)
		}
	}
	return err
}

func (p *BlockMetadataV2) Equals(other *BlockMetadataV2) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if p.Start != other.Start { return false }
	if !p.Err.Equals(other.Err) { return false }
	if p.Size != other.Size {
		if p.Size == nil || other.Size == nil {
			return false
		}
		if (*p.Size) != (*other.Size) { return false }
	}
	if p.Checksum != other.Checksum {
		if p.Checksum == nil || other.Checksum == nil {
			return false
		}
		if (*p.Checksum) != (*other.Checksum) { return false }
	}
	if p.LastRead != other.LastRead {
		if p.LastRead == nil || other.LastRead == nil {
			return false
		}
		if (*p.LastRead) != (*other.LastRead) { return false }
	}
	if p.LastReadTimeType != other.LastReadTimeType { return false }
	if bytes.Compare(p.EncodedTags, other.EncodedTags) != 0 { return false }
	return true
}

func (p *BlockMetadataV2) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BlockMetadataV2(%+v)", *p)
}

func (p *BlockMetadataV2) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.BlockMetadataV2",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*BlockMetadataV2)(nil)

func (p *BlockMetadataV2) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - Elements
// 
type WriteBatchRawRequest struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	Elements []*WriteBatchRawRequestElement `thrift:"elements,2,required" db:"elements" json:"elements"`
}

func NewWriteBatchRawRequest() *WriteBatchRawRequest {
	return &WriteBatchRawRequest{}
}



func (p *WriteBatchRawRequest) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *WriteBatchRawRequest) GetElements() []*WriteBatchRawRequestElement {
	return p.Elements
}

func (p *WriteBatchRawRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *WriteBatchRawRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteBatchRawRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteBatchRawRequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem32 := &WriteBatchRawRequestElement{}
		if err := _elem32.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem32), err)
		}
		p.Elements = append(p.Elements, _elem32)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchRawRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteBatchRawRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:elements: ", p), err)
	}
	return err
}

func (p *WriteBatchRawRequest) Equals(other *WriteBatchRawRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src33 := other.Elements[i]
		if !_tgt.Equals(_src33) { return false }
	}
	return true
}

func (p *WriteBatchRawRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawRequest(%+v)", *p)
}

func (p *WriteBatchRawRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawRequest)(nil)

func (p *WriteBatchRawRequest) Validate() error {
	return nil
}

// Attributes:
//  - NameSpaces
//  - Elements
// 
type WriteBatchRawV2Request struct {
	NameSpaces [][]byte `thrift:"nameSpaces,1,required" db:"nameSpaces" json:"nameSpaces"`
	Elements []*WriteBatchRawV2RequestElement `thrift:"elements,2,required" db:"elements" json:"elements"`
}

func NewWriteBatchRawV2Request() *WriteBatchRawV2Request {
	return &WriteBatchRawV2Request{}
}



func (p *WriteBatchRawV2Request) GetNameSpaces() [][]byte {
	return p.NameSpaces
}



func (p *WriteBatchRawV2Request) GetElements() []*WriteBatchRawV2RequestElement {
	return p.Elements
}

func (p *WriteBatchRawV2Request) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpaces bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpaces = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpaces{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpaces is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *WriteBatchRawV2Request) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.NameSpaces = tSlice
	for i := 0; i < size; i++ {
		var _elem34 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem34 = v
		}
		p.NameSpaces = append(p.NameSpaces, _elem34)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchRawV2Request) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteBatchRawV2RequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem35 := &WriteBatchRawV2RequestElement{}
		if err := _elem35.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem35), err)
		}
		p.Elements = append(p.Elements, _elem35)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteBatchRawV2Request) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawV2Request"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawV2Request) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpaces", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpaces: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.NameSpaces)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.NameSpaces {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpaces: ", p), err)
	}
	return err
}

func (p *WriteBatchRawV2Request) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:elements: ", p), err)
	}
	return err
}

func (p *WriteBatchRawV2Request) Equals(other *WriteBatchRawV2Request) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.NameSpaces) != len(other.NameSpaces) { return false }
	for i, _tgt := range p.NameSpaces {
		_src36 := other.NameSpaces[i]
		if bytes.Compare(_tgt, _src36) != 0 { return false }
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src37 := other.Elements[i]
		if !_tgt.Equals(_src37) { return false }
	}
	return true
}

func (p *WriteBatchRawV2Request) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawV2Request(%+v)", *p)
}

func (p *WriteBatchRawV2Request) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawV2Request",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawV2Request)(nil)

func (p *WriteBatchRawV2Request) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Datapoint
// 
type WriteBatchRawRequestElement struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	Datapoint *Datapoint `thrift:"datapoint,2,required" db:"datapoint" json:"datapoint"`
}

func NewWriteBatchRawRequestElement() *WriteBatchRawRequestElement {
	return &WriteBatchRawRequestElement{}
}



func (p *WriteBatchRawRequestElement) GetID() []byte {
	return p.ID
}

var WriteBatchRawRequestElement_Datapoint_DEFAULT *Datapoint

func (p *WriteBatchRawRequestElement) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteBatchRawRequestElement_Datapoint_DEFAULT
	}
	return p.Datapoint
}

func (p *WriteBatchRawRequestElement) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteBatchRawRequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetDatapoint bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	return nil
}

func (p *WriteBatchRawRequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteBatchRawRequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteBatchRawRequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawRequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawRequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *WriteBatchRawRequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:datapoint: ", p), err)
	}
	return err
}

func (p *WriteBatchRawRequestElement) Equals(other *WriteBatchRawRequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	return true
}

func (p *WriteBatchRawRequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawRequestElement(%+v)", *p)
}

func (p *WriteBatchRawRequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawRequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawRequestElement)(nil)

func (p *WriteBatchRawRequestElement) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Datapoint
//  - NameSpace
// 
type WriteBatchRawV2RequestElement struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	Datapoint *Datapoint `thrift:"datapoint,2,required" db:"datapoint" json:"datapoint"`
	NameSpace int64 `thrift:"nameSpace,3,required" db:"nameSpace" json:"nameSpace"`
}

func NewWriteBatchRawV2RequestElement() *WriteBatchRawV2RequestElement {
	return &WriteBatchRawV2RequestElement{}
}



func (p *WriteBatchRawV2RequestElement) GetID() []byte {
	return p.ID
}

var WriteBatchRawV2RequestElement_Datapoint_DEFAULT *Datapoint

func (p *WriteBatchRawV2RequestElement) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteBatchRawV2RequestElement_Datapoint_DEFAULT
	}
	return p.Datapoint
}



func (p *WriteBatchRawV2RequestElement) GetNameSpace() int64 {
	return p.NameSpace
}

func (p *WriteBatchRawV2RequestElement) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteBatchRawV2RequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetDatapoint bool = false;
	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *WriteBatchRawV2RequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteBatchRawV2RequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteBatchRawV2RequestElement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteBatchRawV2RequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawV2RequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawV2RequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *WriteBatchRawV2RequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:datapoint: ", p), err)
	}
	return err
}

func (p *WriteBatchRawV2RequestElement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:nameSpace: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteBatchRawV2RequestElement) Equals(other *WriteBatchRawV2RequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	if p.NameSpace != other.NameSpace { return false }
	return true
}

func (p *WriteBatchRawV2RequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawV2RequestElement(%+v)", *p)
}

func (p *WriteBatchRawV2RequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawV2RequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawV2RequestElement)(nil)

func (p *WriteBatchRawV2RequestElement) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
//  - Elements
// 
type WriteTaggedBatchRawRequest struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
	Elements []*WriteTaggedBatchRawRequestElement `thrift:"elements,2,required" db:"elements" json:"elements"`
}

func NewWriteTaggedBatchRawRequest() *WriteTaggedBatchRawRequest {
	return &WriteTaggedBatchRawRequest{}
}



func (p *WriteTaggedBatchRawRequest) GetNameSpace() []byte {
	return p.NameSpace
}



func (p *WriteTaggedBatchRawRequest) GetElements() []*WriteTaggedBatchRawRequestElement {
	return p.Elements
}

func (p *WriteTaggedBatchRawRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *WriteTaggedBatchRawRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteTaggedBatchRawRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteTaggedBatchRawRequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem38 := &WriteTaggedBatchRawRequestElement{}
		if err := _elem38.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem38), err)
		}
		p.Elements = append(p.Elements, _elem38)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteTaggedBatchRawRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:elements: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawRequest) Equals(other *WriteTaggedBatchRawRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src39 := other.Elements[i]
		if !_tgt.Equals(_src39) { return false }
	}
	return true
}

func (p *WriteTaggedBatchRawRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteTaggedBatchRawRequest(%+v)", *p)
}

func (p *WriteTaggedBatchRawRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteTaggedBatchRawRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteTaggedBatchRawRequest)(nil)

func (p *WriteTaggedBatchRawRequest) Validate() error {
	return nil
}

// Attributes:
//  - NameSpaces
//  - Elements
// 
type WriteTaggedBatchRawV2Request struct {
	NameSpaces [][]byte `thrift:"nameSpaces,1,required" db:"nameSpaces" json:"nameSpaces"`
	Elements []*WriteTaggedBatchRawV2RequestElement `thrift:"elements,2,required" db:"elements" json:"elements"`
}

func NewWriteTaggedBatchRawV2Request() *WriteTaggedBatchRawV2Request {
	return &WriteTaggedBatchRawV2Request{}
}



func (p *WriteTaggedBatchRawV2Request) GetNameSpaces() [][]byte {
	return p.NameSpaces
}



func (p *WriteTaggedBatchRawV2Request) GetElements() []*WriteTaggedBatchRawV2RequestElement {
	return p.Elements
}

func (p *WriteTaggedBatchRawV2Request) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpaces bool = false;
	var issetElements bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpaces = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetElements = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpaces{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpaces is not set"));
	}
	if !issetElements{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Elements is not set"));
	}
	return nil
}

func (p *WriteTaggedBatchRawV2Request) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.NameSpaces = tSlice
	for i := 0; i < size; i++ {
		var _elem40 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem40 = v
		}
		p.NameSpaces = append(p.NameSpaces, _elem40)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawV2Request) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*WriteTaggedBatchRawV2RequestElement, 0, size)
	p.Elements = tSlice
	for i := 0; i < size; i++ {
		_elem41 := &WriteTaggedBatchRawV2RequestElement{}
		if err := _elem41.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem41), err)
		}
		p.Elements = append(p.Elements, _elem41)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawV2Request) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteTaggedBatchRawV2Request"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawV2Request) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpaces", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpaces: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.NameSpaces)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.NameSpaces {
		if err := oprot.WriteBinary(ctx, v); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpaces: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2Request) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "elements", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:elements: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Elements)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Elements {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:elements: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2Request) Equals(other *WriteTaggedBatchRawV2Request) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.NameSpaces) != len(other.NameSpaces) { return false }
	for i, _tgt := range p.NameSpaces {
		_src42 := other.NameSpaces[i]
		if bytes.Compare(_tgt, _src42) != 0 { return false }
	}
	if len(p.Elements) != len(other.Elements) { return false }
	for i, _tgt := range p.Elements {
		_src43 := other.Elements[i]
		if !_tgt.Equals(_src43) { return false }
	}
	return true
}

func (p *WriteTaggedBatchRawV2Request) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteTaggedBatchRawV2Request(%+v)", *p)
}

func (p *WriteTaggedBatchRawV2Request) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteTaggedBatchRawV2Request",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteTaggedBatchRawV2Request)(nil)

func (p *WriteTaggedBatchRawV2Request) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - EncodedTags
//  - Datapoint
// 
type WriteTaggedBatchRawRequestElement struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	EncodedTags []byte `thrift:"encodedTags,2,required" db:"encodedTags" json:"encodedTags"`
	Datapoint *Datapoint `thrift:"datapoint,3,required" db:"datapoint" json:"datapoint"`
}

func NewWriteTaggedBatchRawRequestElement() *WriteTaggedBatchRawRequestElement {
	return &WriteTaggedBatchRawRequestElement{}
}



func (p *WriteTaggedBatchRawRequestElement) GetID() []byte {
	return p.ID
}



func (p *WriteTaggedBatchRawRequestElement) GetEncodedTags() []byte {
	return p.EncodedTags
}

var WriteTaggedBatchRawRequestElement_Datapoint_DEFAULT *Datapoint

func (p *WriteTaggedBatchRawRequestElement) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteTaggedBatchRawRequestElement_Datapoint_DEFAULT
	}
	return p.Datapoint
}

func (p *WriteTaggedBatchRawRequestElement) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteTaggedBatchRawRequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetEncodedTags bool = false;
	var issetDatapoint bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetEncodedTags = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetEncodedTags{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EncodedTags is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	return nil
}

func (p *WriteTaggedBatchRawRequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteTaggedBatchRawRequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EncodedTags = v
	}
	return nil
}

func (p *WriteTaggedBatchRawRequestElement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteTaggedBatchRawRequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteTaggedBatchRawRequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawRequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawRequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "encodedTags", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:encodedTags: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.EncodedTags); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.encodedTags (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:encodedTags: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawRequestElement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:datapoint: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawRequestElement) Equals(other *WriteTaggedBatchRawRequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if bytes.Compare(p.EncodedTags, other.EncodedTags) != 0 { return false }
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	return true
}

func (p *WriteTaggedBatchRawRequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteTaggedBatchRawRequestElement(%+v)", *p)
}

func (p *WriteTaggedBatchRawRequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteTaggedBatchRawRequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteTaggedBatchRawRequestElement)(nil)

func (p *WriteTaggedBatchRawRequestElement) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - EncodedTags
//  - Datapoint
//  - NameSpace
// 
type WriteTaggedBatchRawV2RequestElement struct {
	ID []byte `thrift:"id,1,required" db:"id" json:"id"`
	EncodedTags []byte `thrift:"encodedTags,2,required" db:"encodedTags" json:"encodedTags"`
	Datapoint *Datapoint `thrift:"datapoint,3,required" db:"datapoint" json:"datapoint"`
	NameSpace int64 `thrift:"nameSpace,4,required" db:"nameSpace" json:"nameSpace"`
}

func NewWriteTaggedBatchRawV2RequestElement() *WriteTaggedBatchRawV2RequestElement {
	return &WriteTaggedBatchRawV2RequestElement{}
}



func (p *WriteTaggedBatchRawV2RequestElement) GetID() []byte {
	return p.ID
}



func (p *WriteTaggedBatchRawV2RequestElement) GetEncodedTags() []byte {
	return p.EncodedTags
}

var WriteTaggedBatchRawV2RequestElement_Datapoint_DEFAULT *Datapoint

func (p *WriteTaggedBatchRawV2RequestElement) GetDatapoint() *Datapoint {
	if !p.IsSetDatapoint() {
		return WriteTaggedBatchRawV2RequestElement_Datapoint_DEFAULT
	}
	return p.Datapoint
}



func (p *WriteTaggedBatchRawV2RequestElement) GetNameSpace() int64 {
	return p.NameSpace
}

func (p *WriteTaggedBatchRawV2RequestElement) IsSetDatapoint() bool {
	return p.Datapoint != nil
}

func (p *WriteTaggedBatchRawV2RequestElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetEncodedTags bool = false;
	var issetDatapoint bool = false;
	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetEncodedTags = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetDatapoint = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetEncodedTags{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field EncodedTags is not set"));
	}
	if !issetDatapoint{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoint is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EncodedTags = v
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Datapoint = &Datapoint{
		TimestampTimeType: 0,
	}
	if err := p.Datapoint.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Datapoint), err)
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteTaggedBatchRawV2RequestElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteTaggedBatchRawV2RequestElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.ID); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2RequestElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "encodedTags", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:encodedTags: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.EncodedTags); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.encodedTags (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:encodedTags: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2RequestElement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoint", thrift.STRUCT, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:datapoint: ", p), err)
	}
	if err := p.Datapoint.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Datapoint), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:datapoint: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2RequestElement) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:nameSpace: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:nameSpace: ", p), err)
	}
	return err
}

func (p *WriteTaggedBatchRawV2RequestElement) Equals(other *WriteTaggedBatchRawV2RequestElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.ID, other.ID) != 0 { return false }
	if bytes.Compare(p.EncodedTags, other.EncodedTags) != 0 { return false }
	if !p.Datapoint.Equals(other.Datapoint) { return false }
	if p.NameSpace != other.NameSpace { return false }
	return true
}

func (p *WriteTaggedBatchRawV2RequestElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteTaggedBatchRawV2RequestElement(%+v)", *p)
}

func (p *WriteTaggedBatchRawV2RequestElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteTaggedBatchRawV2RequestElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteTaggedBatchRawV2RequestElement)(nil)

func (p *WriteTaggedBatchRawV2RequestElement) Validate() error {
	return nil
}

// Attributes:
//  - Index
//  - Err
// 
type WriteBatchRawError struct {
	Index int64 `thrift:"index,1,required" db:"index" json:"index"`
	Err *Error `thrift:"err,2,required" db:"err" json:"err"`
}

func NewWriteBatchRawError() *WriteBatchRawError {
	return &WriteBatchRawError{}
}



func (p *WriteBatchRawError) GetIndex() int64 {
	return p.Index
}

var WriteBatchRawError_Err_DEFAULT *Error

func (p *WriteBatchRawError) GetErr() *Error {
	if !p.IsSetErr() {
		return WriteBatchRawError_Err_DEFAULT
	}
	return p.Err
}

func (p *WriteBatchRawError) IsSetErr() bool {
	return p.Err != nil
}

func (p *WriteBatchRawError) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetIndex bool = false;
	var issetErr bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetIndex = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetErr = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetIndex{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Index is not set"));
	}
	if !issetErr{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Err is not set"));
	}
	return nil
}

func (p *WriteBatchRawError) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Index = v
	}
	return nil
}

func (p *WriteBatchRawError) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *WriteBatchRawError) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "WriteBatchRawError"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *WriteBatchRawError) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "index", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:index: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.Index)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.index (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:index: ", p), err)
	}
	return err
}

func (p *WriteBatchRawError) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:err: ", p), err)
	}
	if err := p.Err.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:err: ", p), err)
	}
	return err
}

func (p *WriteBatchRawError) Equals(other *WriteBatchRawError) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Index != other.Index { return false }
	if !p.Err.Equals(other.Err) { return false }
	return true
}

func (p *WriteBatchRawError) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("WriteBatchRawError(%+v)", *p)
}

func (p *WriteBatchRawError) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.WriteBatchRawError",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*WriteBatchRawError)(nil)

func (p *WriteBatchRawError) Validate() error {
	return nil
}

// Attributes:
//  - NameSpace
// 
type TruncateRequest struct {
	NameSpace []byte `thrift:"nameSpace,1,required" db:"nameSpace" json:"nameSpace"`
}

func NewTruncateRequest() *TruncateRequest {
	return &TruncateRequest{}
}



func (p *TruncateRequest) GetNameSpace() []byte {
	return p.NameSpace
}

func (p *TruncateRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *TruncateRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *TruncateRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TruncateRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TruncateRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:nameSpace: ", p), err)
	}
	return err
}

func (p *TruncateRequest) Equals(other *TruncateRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	return true
}

func (p *TruncateRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateRequest(%+v)", *p)
}

func (p *TruncateRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.TruncateRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TruncateRequest)(nil)

func (p *TruncateRequest) Validate() error {
	return nil
}

// Attributes:
//  - NumSeries
// 
type TruncateResult_ struct {
	NumSeries int64 `thrift:"numSeries,1,required" db:"numSeries" json:"numSeries"`
}

func NewTruncateResult_() *TruncateResult_ {
	return &TruncateResult_{}
}



func (p *TruncateResult_) GetNumSeries() int64 {
	return p.NumSeries
}

func (p *TruncateResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetNumSeries bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetNumSeries = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetNumSeries{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NumSeries is not set"));
	}
	return nil
}

func (p *TruncateResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.NumSeries = v
	}
	return nil
}

func (p *TruncateResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TruncateResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TruncateResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "numSeries", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:numSeries: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.NumSeries)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.numSeries (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:numSeries: ", p), err)
	}
	return err
}

func (p *TruncateResult_) Equals(other *TruncateResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.NumSeries != other.NumSeries { return false }
	return true
}

func (p *TruncateResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateResult_(%+v)", *p)
}

func (p *TruncateResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.TruncateResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TruncateResult_)(nil)

func (p *TruncateResult_) Validate() error {
	return nil
}

// Attributes:
//  - Ok
//  - Status
//  - Bootstrapped
//  - Metadata
// 
type NodeHealthResult_ struct {
	Ok bool `thrift:"ok,1,required" db:"ok" json:"ok"`
	Status string `thrift:"status,2,required" db:"status" json:"status"`
	Bootstrapped bool `thrift:"bootstrapped,3,required" db:"bootstrapped" json:"bootstrapped"`
	Metadata map[string]string `thrift:"metadata,4" db:"metadata" json:"metadata,omitempty"`
}

func NewNodeHealthResult_() *NodeHealthResult_ {
	return &NodeHealthResult_{}
}



func (p *NodeHealthResult_) GetOk() bool {
	return p.Ok
}



func (p *NodeHealthResult_) GetStatus() string {
	return p.Status
}



func (p *NodeHealthResult_) GetBootstrapped() bool {
	return p.Bootstrapped
}

var NodeHealthResult__Metadata_DEFAULT map[string]string


func (p *NodeHealthResult_) GetMetadata() map[string]string {
	return p.Metadata
}

func (p *NodeHealthResult_) IsSetMetadata() bool {
	return p.Metadata != nil
}

func (p *NodeHealthResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetOk bool = false;
	var issetStatus bool = false;
	var issetBootstrapped bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetOk = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetStatus = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetBootstrapped = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.MAP {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetOk{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ok is not set"));
	}
	if !issetStatus{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Status is not set"));
	}
	if !issetBootstrapped{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Bootstrapped is not set"));
	}
	return nil
}

func (p *NodeHealthResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Ok = v
	}
	return nil
}

func (p *NodeHealthResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Status = v
	}
	return nil
}

func (p *NodeHealthResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Bootstrapped = v
	}
	return nil
}

func (p *NodeHealthResult_) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading map begin: ", err)
	}
	tMap := make(map[string]string, size)
	p.Metadata = tMap
	for i := 0; i < size; i++ {
		var _key44 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_key44 = v
		}
		var _val45 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_val45 = v
		}
		p.Metadata[_key44] = _val45
	}
	if err := iprot.ReadMapEnd(ctx); err != nil {
		return thrift.PrependError("error reading map end: ", err)
	}
	return nil
}

func (p *NodeHealthResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeHealthResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeHealthResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ok", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ok: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Ok)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ok (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ok: ", p), err)
	}
	return err
}

func (p *NodeHealthResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "status", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Status)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err)
	}
	return err
}

func (p *NodeHealthResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "bootstrapped", thrift.BOOL, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:bootstrapped: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Bootstrapped)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.bootstrapped (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:bootstrapped: ", p), err)
	}
	return err
}

func (p *NodeHealthResult_) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetMetadata() {
		if err := oprot.WriteFieldBegin(ctx, "metadata", thrift.MAP, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:metadata: ", p), err)
		}
		if err := oprot.WriteMapBegin(ctx, thrift.STRING, thrift.STRING, len(p.Metadata)); err != nil {
			return thrift.PrependError("error writing map begin: ", err)
		}
		for k, v := range p.Metadata {
			if err := oprot.WriteString(ctx, string(k)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteMapEnd(ctx); err != nil {
			return thrift.PrependError("error writing map end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:metadata: ", p), err)
		}
	}
	return err
}

func (p *NodeHealthResult_) Equals(other *NodeHealthResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Ok != other.Ok { return false }
	if p.Status != other.Status { return false }
	if p.Bootstrapped != other.Bootstrapped { return false }
	if len(p.Metadata) != len(other.Metadata) { return false }
	for k, _tgt := range p.Metadata {
		_src46 := other.Metadata[k]
		if _tgt != _src46 { return false }
	}
	return true
}

func (p *NodeHealthResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeHealthResult_(%+v)", *p)
}

func (p *NodeHealthResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeHealthResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeHealthResult_)(nil)

func (p *NodeHealthResult_) Validate() error {
	return nil
}

type NodeBootstrappedResult_ struct {
}

func NewNodeBootstrappedResult_() *NodeBootstrappedResult_ {
	return &NodeBootstrappedResult_{}
}

func (p *NodeBootstrappedResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeBootstrappedResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedResult_) Equals(other *NodeBootstrappedResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *NodeBootstrappedResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedResult_(%+v)", *p)
}

func (p *NodeBootstrappedResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedResult_)(nil)

func (p *NodeBootstrappedResult_) Validate() error {
	return nil
}

type NodeBootstrappedInPlacementOrNoPlacementResult_ struct {
}

func NewNodeBootstrappedInPlacementOrNoPlacementResult_() *NodeBootstrappedInPlacementOrNoPlacementResult_ {
	return &NodeBootstrappedInPlacementOrNoPlacementResult_{}
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeBootstrappedInPlacementOrNoPlacementResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) Equals(other *NodeBootstrappedInPlacementOrNoPlacementResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedInPlacementOrNoPlacementResult_(%+v)", *p)
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedInPlacementOrNoPlacementResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedInPlacementOrNoPlacementResult_)(nil)

func (p *NodeBootstrappedInPlacementOrNoPlacementResult_) Validate() error {
	return nil
}

// Attributes:
//  - LimitEnabled
//  - LimitMbps
//  - LimitCheckEvery
// 
type NodePersistRateLimitResult_ struct {
	LimitEnabled bool `thrift:"limitEnabled,1,required" db:"limitEnabled" json:"limitEnabled"`
	LimitMbps float64 `thrift:"limitMbps,2,required" db:"limitMbps" json:"limitMbps"`
	LimitCheckEvery int64 `thrift:"limitCheckEvery,3,required" db:"limitCheckEvery" json:"limitCheckEvery"`
}

func NewNodePersistRateLimitResult_() *NodePersistRateLimitResult_ {
	return &NodePersistRateLimitResult_{}
}



func (p *NodePersistRateLimitResult_) GetLimitEnabled() bool {
	return p.LimitEnabled
}



func (p *NodePersistRateLimitResult_) GetLimitMbps() float64 {
	return p.LimitMbps
}



func (p *NodePersistRateLimitResult_) GetLimitCheckEvery() int64 {
	return p.LimitCheckEvery
}

func (p *NodePersistRateLimitResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetLimitEnabled bool = false;
	var issetLimitMbps bool = false;
	var issetLimitCheckEvery bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetLimitEnabled = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetLimitMbps = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetLimitCheckEvery = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetLimitEnabled{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field LimitEnabled is not set"));
	}
	if !issetLimitMbps{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field LimitMbps is not set"));
	}
	if !issetLimitCheckEvery{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field LimitCheckEvery is not set"));
	}
	return nil
}

func (p *NodePersistRateLimitResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.LimitEnabled = v
	}
	return nil
}

func (p *NodePersistRateLimitResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.LimitMbps = v
	}
	return nil
}

func (p *NodePersistRateLimitResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.LimitCheckEvery = v
	}
	return nil
}

func (p *NodePersistRateLimitResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodePersistRateLimitResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodePersistRateLimitResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "limitEnabled", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:limitEnabled: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.LimitEnabled)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.limitEnabled (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:limitEnabled: ", p), err)
	}
	return err
}

func (p *NodePersistRateLimitResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "limitMbps", thrift.DOUBLE, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:limitMbps: ", p), err)
	}
	if err := oprot.WriteDouble(ctx, float64(p.LimitMbps)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.limitMbps (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:limitMbps: ", p), err)
	}
	return err
}

func (p *NodePersistRateLimitResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "limitCheckEvery", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:limitCheckEvery: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.LimitCheckEvery)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.limitCheckEvery (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:limitCheckEvery: ", p), err)
	}
	return err
}

func (p *NodePersistRateLimitResult_) Equals(other *NodePersistRateLimitResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.LimitEnabled != other.LimitEnabled { return false }
	if p.LimitMbps != other.LimitMbps { return false }
	if p.LimitCheckEvery != other.LimitCheckEvery { return false }
	return true
}

func (p *NodePersistRateLimitResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodePersistRateLimitResult_(%+v)", *p)
}

func (p *NodePersistRateLimitResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodePersistRateLimitResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodePersistRateLimitResult_)(nil)

func (p *NodePersistRateLimitResult_) Validate() error {
	return nil
}

// Attributes:
//  - LimitEnabled
//  - LimitMbps
//  - LimitCheckEvery
// 
type NodeSetPersistRateLimitRequest struct {
	LimitEnabled *bool `thrift:"limitEnabled,1" db:"limitEnabled" json:"limitEnabled,omitempty"`
	LimitMbps *float64 `thrift:"limitMbps,2" db:"limitMbps" json:"limitMbps,omitempty"`
	LimitCheckEvery *int64 `thrift:"limitCheckEvery,3" db:"limitCheckEvery" json:"limitCheckEvery,omitempty"`
}

func NewNodeSetPersistRateLimitRequest() *NodeSetPersistRateLimitRequest {
	return &NodeSetPersistRateLimitRequest{}
}

var NodeSetPersistRateLimitRequest_LimitEnabled_DEFAULT bool

func (p *NodeSetPersistRateLimitRequest) GetLimitEnabled() bool {
	if !p.IsSetLimitEnabled() {
		return NodeSetPersistRateLimitRequest_LimitEnabled_DEFAULT
	}
	return *p.LimitEnabled
}

var NodeSetPersistRateLimitRequest_LimitMbps_DEFAULT float64

func (p *NodeSetPersistRateLimitRequest) GetLimitMbps() float64 {
	if !p.IsSetLimitMbps() {
		return NodeSetPersistRateLimitRequest_LimitMbps_DEFAULT
	}
	return *p.LimitMbps
}

var NodeSetPersistRateLimitRequest_LimitCheckEvery_DEFAULT int64

func (p *NodeSetPersistRateLimitRequest) GetLimitCheckEvery() int64 {
	if !p.IsSetLimitCheckEvery() {
		return NodeSetPersistRateLimitRequest_LimitCheckEvery_DEFAULT
	}
	return *p.LimitCheckEvery
}

func (p *NodeSetPersistRateLimitRequest) IsSetLimitEnabled() bool {
	return p.LimitEnabled != nil
}

func (p *NodeSetPersistRateLimitRequest) IsSetLimitMbps() bool {
	return p.LimitMbps != nil
}

func (p *NodeSetPersistRateLimitRequest) IsSetLimitCheckEvery() bool {
	return p.LimitCheckEvery != nil
}

func (p *NodeSetPersistRateLimitRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.DOUBLE {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.LimitEnabled = &v
	}
	return nil
}

func (p *NodeSetPersistRateLimitRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.LimitMbps = &v
	}
	return nil
}

func (p *NodeSetPersistRateLimitRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.LimitCheckEvery = &v
	}
	return nil
}

func (p *NodeSetPersistRateLimitRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeSetPersistRateLimitRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLimitEnabled() {
		if err := oprot.WriteFieldBegin(ctx, "limitEnabled", thrift.BOOL, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:limitEnabled: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.LimitEnabled)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limitEnabled (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:limitEnabled: ", p), err)
		}
	}
	return err
}

func (p *NodeSetPersistRateLimitRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLimitMbps() {
		if err := oprot.WriteFieldBegin(ctx, "limitMbps", thrift.DOUBLE, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:limitMbps: ", p), err)
		}
		if err := oprot.WriteDouble(ctx, float64(*p.LimitMbps)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limitMbps (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:limitMbps: ", p), err)
		}
	}
	return err
}

func (p *NodeSetPersistRateLimitRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLimitCheckEvery() {
		if err := oprot.WriteFieldBegin(ctx, "limitCheckEvery", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:limitCheckEvery: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.LimitCheckEvery)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limitCheckEvery (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:limitCheckEvery: ", p), err)
		}
	}
	return err
}

func (p *NodeSetPersistRateLimitRequest) Equals(other *NodeSetPersistRateLimitRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.LimitEnabled != other.LimitEnabled {
		if p.LimitEnabled == nil || other.LimitEnabled == nil {
			return false
		}
		if (*p.LimitEnabled) != (*other.LimitEnabled) { return false }
	}
	if p.LimitMbps != other.LimitMbps {
		if p.LimitMbps == nil || other.LimitMbps == nil {
			return false
		}
		if (*p.LimitMbps) != (*other.LimitMbps) { return false }
	}
	if p.LimitCheckEvery != other.LimitCheckEvery {
		if p.LimitCheckEvery == nil || other.LimitCheckEvery == nil {
			return false
		}
		if (*p.LimitCheckEvery) != (*other.LimitCheckEvery) { return false }
	}
	return true
}

func (p *NodeSetPersistRateLimitRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetPersistRateLimitRequest(%+v)", *p)
}

func (p *NodeSetPersistRateLimitRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetPersistRateLimitRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetPersistRateLimitRequest)(nil)

func (p *NodeSetPersistRateLimitRequest) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesAsync
// 
type NodeWriteNewSeriesAsyncResult_ struct {
	WriteNewSeriesAsync bool `thrift:"writeNewSeriesAsync,1,required" db:"writeNewSeriesAsync" json:"writeNewSeriesAsync"`
}

func NewNodeWriteNewSeriesAsyncResult_() *NodeWriteNewSeriesAsyncResult_ {
	return &NodeWriteNewSeriesAsyncResult_{}
}



func (p *NodeWriteNewSeriesAsyncResult_) GetWriteNewSeriesAsync() bool {
	return p.WriteNewSeriesAsync
}

func (p *NodeWriteNewSeriesAsyncResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesAsync bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesAsync = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesAsync{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesAsync is not set"));
	}
	return nil
}

func (p *NodeWriteNewSeriesAsyncResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesAsync = v
	}
	return nil
}

func (p *NodeWriteNewSeriesAsyncResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeWriteNewSeriesAsyncResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteNewSeriesAsyncResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesAsync", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesAsync: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WriteNewSeriesAsync)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesAsync (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesAsync: ", p), err)
	}
	return err
}

func (p *NodeWriteNewSeriesAsyncResult_) Equals(other *NodeWriteNewSeriesAsyncResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesAsync != other.WriteNewSeriesAsync { return false }
	return true
}

func (p *NodeWriteNewSeriesAsyncResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteNewSeriesAsyncResult_(%+v)", *p)
}

func (p *NodeWriteNewSeriesAsyncResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteNewSeriesAsyncResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteNewSeriesAsyncResult_)(nil)

func (p *NodeWriteNewSeriesAsyncResult_) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesAsync
// 
type NodeSetWriteNewSeriesAsyncRequest struct {
	WriteNewSeriesAsync bool `thrift:"writeNewSeriesAsync,1,required" db:"writeNewSeriesAsync" json:"writeNewSeriesAsync"`
}

func NewNodeSetWriteNewSeriesAsyncRequest() *NodeSetWriteNewSeriesAsyncRequest {
	return &NodeSetWriteNewSeriesAsyncRequest{}
}



func (p *NodeSetWriteNewSeriesAsyncRequest) GetWriteNewSeriesAsync() bool {
	return p.WriteNewSeriesAsync
}

func (p *NodeSetWriteNewSeriesAsyncRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesAsync bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesAsync = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesAsync{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesAsync is not set"));
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesAsync = v
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeSetWriteNewSeriesAsyncRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesAsync", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesAsync: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.WriteNewSeriesAsync)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesAsync (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesAsync: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesAsyncRequest) Equals(other *NodeSetWriteNewSeriesAsyncRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesAsync != other.WriteNewSeriesAsync { return false }
	return true
}

func (p *NodeSetWriteNewSeriesAsyncRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesAsyncRequest(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesAsyncRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesAsyncRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesAsyncRequest)(nil)

func (p *NodeSetWriteNewSeriesAsyncRequest) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesBackoffDuration
//  - DurationType
// 
type NodeWriteNewSeriesBackoffDurationResult_ struct {
	WriteNewSeriesBackoffDuration int64 `thrift:"writeNewSeriesBackoffDuration,1,required" db:"writeNewSeriesBackoffDuration" json:"writeNewSeriesBackoffDuration"`
	DurationType TimeType `thrift:"durationType,2,required" db:"durationType" json:"durationType"`
}

func NewNodeWriteNewSeriesBackoffDurationResult_() *NodeWriteNewSeriesBackoffDurationResult_ {
	return &NodeWriteNewSeriesBackoffDurationResult_{}
}



func (p *NodeWriteNewSeriesBackoffDurationResult_) GetWriteNewSeriesBackoffDuration() int64 {
	return p.WriteNewSeriesBackoffDuration
}



func (p *NodeWriteNewSeriesBackoffDurationResult_) GetDurationType() TimeType {
	return p.DurationType
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesBackoffDuration bool = false;
	var issetDurationType bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesBackoffDuration = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetDurationType = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesBackoffDuration{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesBackoffDuration is not set"));
	}
	if !issetDurationType{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field DurationType is not set"));
	}
	return nil
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesBackoffDuration = v
	}
	return nil
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := TimeType(v)
		p.DurationType = temp
	}
	return nil
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeWriteNewSeriesBackoffDurationResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesBackoffDuration", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesBackoffDuration: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.WriteNewSeriesBackoffDuration)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesBackoffDuration (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesBackoffDuration: ", p), err)
	}
	return err
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "durationType", thrift.I32, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:durationType: ", p), err)
	}
	if err := oprot.WriteI32(ctx, int32(p.DurationType)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.durationType (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:durationType: ", p), err)
	}
	return err
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) Equals(other *NodeWriteNewSeriesBackoffDurationResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesBackoffDuration != other.WriteNewSeriesBackoffDuration { return false }
	if p.DurationType != other.DurationType { return false }
	return true
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteNewSeriesBackoffDurationResult_(%+v)", *p)
}

func (p *NodeWriteNewSeriesBackoffDurationResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteNewSeriesBackoffDurationResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteNewSeriesBackoffDurationResult_)(nil)

func (p *NodeWriteNewSeriesBackoffDurationResult_) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesBackoffDuration
//  - DurationType
// 
type NodeSetWriteNewSeriesBackoffDurationRequest struct {
	WriteNewSeriesBackoffDuration int64 `thrift:"writeNewSeriesBackoffDuration,1,required" db:"writeNewSeriesBackoffDuration" json:"writeNewSeriesBackoffDuration"`
	DurationType TimeType `thrift:"durationType,2" db:"durationType" json:"durationType"`
}

func NewNodeSetWriteNewSeriesBackoffDurationRequest() *NodeSetWriteNewSeriesBackoffDurationRequest {
	return &NodeSetWriteNewSeriesBackoffDurationRequest{
		DurationType: 2,
	}
}



func (p *NodeSetWriteNewSeriesBackoffDurationRequest) GetWriteNewSeriesBackoffDuration() int64 {
	return p.WriteNewSeriesBackoffDuration
}

var NodeSetWriteNewSeriesBackoffDurationRequest_DurationType_DEFAULT TimeType = 2


func (p *NodeSetWriteNewSeriesBackoffDurationRequest) GetDurationType() TimeType {
	return p.DurationType
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) IsSetDurationType() bool {
	return p.DurationType != NodeSetWriteNewSeriesBackoffDurationRequest_DurationType_DEFAULT
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesBackoffDuration bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesBackoffDuration = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesBackoffDuration{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesBackoffDuration is not set"));
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesBackoffDuration = v
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := TimeType(v)
		p.DurationType = temp
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeSetWriteNewSeriesBackoffDurationRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesBackoffDuration", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesBackoffDuration: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.WriteNewSeriesBackoffDuration)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesBackoffDuration (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesBackoffDuration: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDurationType() {
		if err := oprot.WriteFieldBegin(ctx, "durationType", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:durationType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.DurationType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.durationType (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:durationType: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) Equals(other *NodeSetWriteNewSeriesBackoffDurationRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesBackoffDuration != other.WriteNewSeriesBackoffDuration { return false }
	if p.DurationType != other.DurationType { return false }
	return true
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesBackoffDurationRequest(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesBackoffDurationRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesBackoffDurationRequest)(nil)

func (p *NodeSetWriteNewSeriesBackoffDurationRequest) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesLimitPerShardPerSecond
// 
type NodeWriteNewSeriesLimitPerShardPerSecondResult_ struct {
	WriteNewSeriesLimitPerShardPerSecond int64 `thrift:"writeNewSeriesLimitPerShardPerSecond,1,required" db:"writeNewSeriesLimitPerShardPerSecond" json:"writeNewSeriesLimitPerShardPerSecond"`
}

func NewNodeWriteNewSeriesLimitPerShardPerSecondResult_() *NodeWriteNewSeriesLimitPerShardPerSecondResult_ {
	return &NodeWriteNewSeriesLimitPerShardPerSecondResult_{}
}



func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) GetWriteNewSeriesLimitPerShardPerSecond() int64 {
	return p.WriteNewSeriesLimitPerShardPerSecond
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesLimitPerShardPerSecond bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesLimitPerShardPerSecond = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesLimitPerShardPerSecond{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesLimitPerShardPerSecond is not set"));
	}
	return nil
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesLimitPerShardPerSecond = v
	}
	return nil
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeWriteNewSeriesLimitPerShardPerSecondResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesLimitPerShardPerSecond", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesLimitPerShardPerSecond: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.WriteNewSeriesLimitPerShardPerSecond)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesLimitPerShardPerSecond (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesLimitPerShardPerSecond: ", p), err)
	}
	return err
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) Equals(other *NodeWriteNewSeriesLimitPerShardPerSecondResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesLimitPerShardPerSecond != other.WriteNewSeriesLimitPerShardPerSecond { return false }
	return true
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteNewSeriesLimitPerShardPerSecondResult_(%+v)", *p)
}

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteNewSeriesLimitPerShardPerSecondResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteNewSeriesLimitPerShardPerSecondResult_)(nil)

func (p *NodeWriteNewSeriesLimitPerShardPerSecondResult_) Validate() error {
	return nil
}

// Attributes:
//  - WriteNewSeriesLimitPerShardPerSecond
// 
type NodeSetWriteNewSeriesLimitPerShardPerSecondRequest struct {
	WriteNewSeriesLimitPerShardPerSecond int64 `thrift:"writeNewSeriesLimitPerShardPerSecond,1,required" db:"writeNewSeriesLimitPerShardPerSecond" json:"writeNewSeriesLimitPerShardPerSecond"`
}

func NewNodeSetWriteNewSeriesLimitPerShardPerSecondRequest() *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest {
	return &NodeSetWriteNewSeriesLimitPerShardPerSecondRequest{}
}



func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) GetWriteNewSeriesLimitPerShardPerSecond() int64 {
	return p.WriteNewSeriesLimitPerShardPerSecond
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetWriteNewSeriesLimitPerShardPerSecond bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetWriteNewSeriesLimitPerShardPerSecond = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetWriteNewSeriesLimitPerShardPerSecond{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field WriteNewSeriesLimitPerShardPerSecond is not set"));
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.WriteNewSeriesLimitPerShardPerSecond = v
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NodeSetWriteNewSeriesLimitPerShardPerSecondRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "writeNewSeriesLimitPerShardPerSecond", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:writeNewSeriesLimitPerShardPerSecond: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.WriteNewSeriesLimitPerShardPerSecond)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.writeNewSeriesLimitPerShardPerSecond (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:writeNewSeriesLimitPerShardPerSecond: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) Equals(other *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.WriteNewSeriesLimitPerShardPerSecond != other.WriteNewSeriesLimitPerShardPerSecond { return false }
	return true
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesLimitPerShardPerSecondRequest(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesLimitPerShardPerSecondRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesLimitPerShardPerSecondRequest)(nil)

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) Validate() error {
	return nil
}

// Attributes:
//  - Ok
//  - Status
// 
type HealthResult_ struct {
	Ok bool `thrift:"ok,1,required" db:"ok" json:"ok"`
	Status string `thrift:"status,2,required" db:"status" json:"status"`
}

func NewHealthResult_() *HealthResult_ {
	return &HealthResult_{}
}



func (p *HealthResult_) GetOk() bool {
	return p.Ok
}



func (p *HealthResult_) GetStatus() string {
	return p.Status
}

func (p *HealthResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetOk bool = false;
	var issetStatus bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetOk = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetStatus = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetOk{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Ok is not set"));
	}
	if !issetStatus{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Status is not set"));
	}
	return nil
}

func (p *HealthResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Ok = v
	}
	return nil
}

func (p *HealthResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Status = v
	}
	return nil
}

func (p *HealthResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "HealthResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *HealthResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "ok", thrift.BOOL, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:ok: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Ok)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.ok (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:ok: ", p), err)
	}
	return err
}

func (p *HealthResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "status", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:status: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Status)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.status (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:status: ", p), err)
	}
	return err
}

func (p *HealthResult_) Equals(other *HealthResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Ok != other.Ok { return false }
	if p.Status != other.Status { return false }
	return true
}

func (p *HealthResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("HealthResult_(%+v)", *p)
}

func (p *HealthResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.HealthResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*HealthResult_)(nil)

func (p *HealthResult_) Validate() error {
	return nil
}

// Attributes:
//  - Query
//  - RangeStart
//  - RangeEnd
//  - NameSpace
//  - SeriesLimit
//  - TagNameFilter
//  - AggregateQueryType
//  - RangeType
//  - Source
//  - DocsLimit
//  - RequireExhaustive
//  - RequireNoWait
// 
type AggregateQueryRawRequest struct {
	Query []byte `thrift:"query,1,required" db:"query" json:"query"`
	RangeStart int64 `thrift:"rangeStart,2,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,3,required" db:"rangeEnd" json:"rangeEnd"`
	NameSpace []byte `thrift:"nameSpace,4,required" db:"nameSpace" json:"nameSpace"`
	SeriesLimit *int64 `thrift:"seriesLimit,5" db:"seriesLimit" json:"seriesLimit,omitempty"`
	TagNameFilter [][]byte `thrift:"tagNameFilter,6" db:"tagNameFilter" json:"tagNameFilter,omitempty"`
	AggregateQueryType AggregateQueryType `thrift:"aggregateQueryType,7" db:"aggregateQueryType" json:"aggregateQueryType"`
	RangeType TimeType `thrift:"rangeType,8" db:"rangeType" json:"rangeType"`
	Source []byte `thrift:"source,9" db:"source" json:"source,omitempty"`
	DocsLimit *int64 `thrift:"docsLimit,10" db:"docsLimit" json:"docsLimit,omitempty"`
	RequireExhaustive *bool `thrift:"requireExhaustive,11" db:"requireExhaustive" json:"requireExhaustive,omitempty"`
	RequireNoWait *bool `thrift:"requireNoWait,12" db:"requireNoWait" json:"requireNoWait,omitempty"`
}

func NewAggregateQueryRawRequest() *AggregateQueryRawRequest {
	return &AggregateQueryRawRequest{
		AggregateQueryType: 1,
		RangeType: 0,
	}
}



func (p *AggregateQueryRawRequest) GetQuery() []byte {
	return p.Query
}



func (p *AggregateQueryRawRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *AggregateQueryRawRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *AggregateQueryRawRequest) GetNameSpace() []byte {
	return p.NameSpace
}

var AggregateQueryRawRequest_SeriesLimit_DEFAULT int64

func (p *AggregateQueryRawRequest) GetSeriesLimit() int64 {
	if !p.IsSetSeriesLimit() {
		return AggregateQueryRawRequest_SeriesLimit_DEFAULT
	}
	return *p.SeriesLimit
}

var AggregateQueryRawRequest_TagNameFilter_DEFAULT [][]byte


func (p *AggregateQueryRawRequest) GetTagNameFilter() [][]byte {
	return p.TagNameFilter
}

var AggregateQueryRawRequest_AggregateQueryType_DEFAULT AggregateQueryType = 1


func (p *AggregateQueryRawRequest) GetAggregateQueryType() AggregateQueryType {
	return p.AggregateQueryType
}

var AggregateQueryRawRequest_RangeType_DEFAULT TimeType = 0


func (p *AggregateQueryRawRequest) GetRangeType() TimeType {
	return p.RangeType
}

var AggregateQueryRawRequest_Source_DEFAULT []byte


func (p *AggregateQueryRawRequest) GetSource() []byte {
	return p.Source
}

var AggregateQueryRawRequest_DocsLimit_DEFAULT int64

func (p *AggregateQueryRawRequest) GetDocsLimit() int64 {
	if !p.IsSetDocsLimit() {
		return AggregateQueryRawRequest_DocsLimit_DEFAULT
	}
	return *p.DocsLimit
}

var AggregateQueryRawRequest_RequireExhaustive_DEFAULT bool

func (p *AggregateQueryRawRequest) GetRequireExhaustive() bool {
	if !p.IsSetRequireExhaustive() {
		return AggregateQueryRawRequest_RequireExhaustive_DEFAULT
	}
	return *p.RequireExhaustive
}

var AggregateQueryRawRequest_RequireNoWait_DEFAULT bool

func (p *AggregateQueryRawRequest) GetRequireNoWait() bool {
	if !p.IsSetRequireNoWait() {
		return AggregateQueryRawRequest_RequireNoWait_DEFAULT
	}
	return *p.RequireNoWait
}

func (p *AggregateQueryRawRequest) IsSetSeriesLimit() bool {
	return p.SeriesLimit != nil
}

func (p *AggregateQueryRawRequest) IsSetTagNameFilter() bool {
	return p.TagNameFilter != nil
}

func (p *AggregateQueryRawRequest) IsSetAggregateQueryType() bool {
	return p.AggregateQueryType != AggregateQueryRawRequest_AggregateQueryType_DEFAULT
}

func (p *AggregateQueryRawRequest) IsSetRangeType() bool {
	return p.RangeType != AggregateQueryRawRequest_RangeType_DEFAULT
}

func (p *AggregateQueryRawRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *AggregateQueryRawRequest) IsSetDocsLimit() bool {
	return p.DocsLimit != nil
}

func (p *AggregateQueryRawRequest) IsSetRequireExhaustive() bool {
	return p.RequireExhaustive != nil
}

func (p *AggregateQueryRawRequest) IsSetRequireNoWait() bool {
	return p.RequireNoWait != nil
}

func (p *AggregateQueryRawRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetQuery = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Query = v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.SeriesLimit = &v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([][]byte, 0, size)
	p.TagNameFilter = tSlice
	for i := 0; i < size; i++ {
		var _elem47 []byte
		if v, err := iprot.ReadBinary(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem47 = v
		}
		p.TagNameFilter = append(p.TagNameFilter, _elem47)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := AggregateQueryType(v)
		p.AggregateQueryType = temp
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.DocsLimit = &v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.RequireExhaustive = &v
	}
	return nil
}

func (p *AggregateQueryRawRequest) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.RequireNoWait = &v
	}
	return nil
}

func (p *AggregateQueryRawRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryRawRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
		if err := p.writeField12(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryRawRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.Query); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.query (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeStart: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeEnd: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:nameSpace: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.NameSpace); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:nameSpace: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSeriesLimit() {
		if err := oprot.WriteFieldBegin(ctx, "seriesLimit", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:seriesLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.SeriesLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.seriesLimit (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:seriesLimit: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTagNameFilter() {
		if err := oprot.WriteFieldBegin(ctx, "tagNameFilter", thrift.LIST, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tagNameFilter: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.TagNameFilter)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.TagNameFilter {
			if err := oprot.WriteBinary(ctx, v); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tagNameFilter: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAggregateQueryType() {
		if err := oprot.WriteFieldBegin(ctx, "aggregateQueryType", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:aggregateQueryType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.AggregateQueryType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.aggregateQueryType (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:aggregateQueryType: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeType", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:rangeType: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:source: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDocsLimit() {
		if err := oprot.WriteFieldBegin(ctx, "docsLimit", thrift.I64, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:docsLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.DocsLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.docsLimit (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:docsLimit: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireExhaustive() {
		if err := oprot.WriteFieldBegin(ctx, "requireExhaustive", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:requireExhaustive: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.RequireExhaustive)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireExhaustive (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:requireExhaustive: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireNoWait() {
		if err := oprot.WriteFieldBegin(ctx, "requireNoWait", thrift.BOOL, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:requireNoWait: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.RequireNoWait)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireNoWait (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:requireNoWait: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawRequest) Equals(other *AggregateQueryRawRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.Query, other.Query) != 0 { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if bytes.Compare(p.NameSpace, other.NameSpace) != 0 { return false }
	if p.SeriesLimit != other.SeriesLimit {
		if p.SeriesLimit == nil || other.SeriesLimit == nil {
			return false
		}
		if (*p.SeriesLimit) != (*other.SeriesLimit) { return false }
	}
	if len(p.TagNameFilter) != len(other.TagNameFilter) { return false }
	for i, _tgt := range p.TagNameFilter {
		_src48 := other.TagNameFilter[i]
		if bytes.Compare(_tgt, _src48) != 0 { return false }
	}
	if p.AggregateQueryType != other.AggregateQueryType { return false }
	if p.RangeType != other.RangeType { return false }
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	if p.DocsLimit != other.DocsLimit {
		if p.DocsLimit == nil || other.DocsLimit == nil {
			return false
		}
		if (*p.DocsLimit) != (*other.DocsLimit) { return false }
	}
	if p.RequireExhaustive != other.RequireExhaustive {
		if p.RequireExhaustive == nil || other.RequireExhaustive == nil {
			return false
		}
		if (*p.RequireExhaustive) != (*other.RequireExhaustive) { return false }
	}
	if p.RequireNoWait != other.RequireNoWait {
		if p.RequireNoWait == nil || other.RequireNoWait == nil {
			return false
		}
		if (*p.RequireNoWait) != (*other.RequireNoWait) { return false }
	}
	return true
}

func (p *AggregateQueryRawRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryRawRequest(%+v)", *p)
}

func (p *AggregateQueryRawRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryRawRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryRawRequest)(nil)

func (p *AggregateQueryRawRequest) Validate() error {
	return nil
}

// Attributes:
//  - Results
//  - Exhaustive
//  - WaitedIndex
// 
type AggregateQueryRawResult_ struct {
	Results []*AggregateQueryRawResultTagNameElement `thrift:"results,1,required" db:"results" json:"results"`
	Exhaustive bool `thrift:"exhaustive,2,required" db:"exhaustive" json:"exhaustive"`
	WaitedIndex *int64 `thrift:"waitedIndex,3" db:"waitedIndex" json:"waitedIndex,omitempty"`
}

func NewAggregateQueryRawResult_() *AggregateQueryRawResult_ {
	return &AggregateQueryRawResult_{}
}



func (p *AggregateQueryRawResult_) GetResults() []*AggregateQueryRawResultTagNameElement {
	return p.Results
}



func (p *AggregateQueryRawResult_) GetExhaustive() bool {
	return p.Exhaustive
}

var AggregateQueryRawResult__WaitedIndex_DEFAULT int64

func (p *AggregateQueryRawResult_) GetWaitedIndex() int64 {
	if !p.IsSetWaitedIndex() {
		return AggregateQueryRawResult__WaitedIndex_DEFAULT
	}
	return *p.WaitedIndex
}

func (p *AggregateQueryRawResult_) IsSetWaitedIndex() bool {
	return p.WaitedIndex != nil
}

func (p *AggregateQueryRawResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetResults bool = false;
	var issetExhaustive bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetResults = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetExhaustive = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetResults{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Results is not set"));
	}
	if !issetExhaustive{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Exhaustive is not set"));
	}
	return nil
}

func (p *AggregateQueryRawResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*AggregateQueryRawResultTagNameElement, 0, size)
	p.Results = tSlice
	for i := 0; i < size; i++ {
		_elem49 := &AggregateQueryRawResultTagNameElement{}
		if err := _elem49.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem49), err)
		}
		p.Results = append(p.Results, _elem49)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryRawResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Exhaustive = v
	}
	return nil
}

func (p *AggregateQueryRawResult_) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.WaitedIndex = &v
	}
	return nil
}

func (p *AggregateQueryRawResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryRawResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryRawResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "results", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:results: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Results)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Results {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:results: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "exhaustive", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:exhaustive: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Exhaustive)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.exhaustive (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:exhaustive: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawResult_) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetWaitedIndex() {
		if err := oprot.WriteFieldBegin(ctx, "waitedIndex", thrift.I64, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:waitedIndex: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.WaitedIndex)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.waitedIndex (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:waitedIndex: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawResult_) Equals(other *AggregateQueryRawResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Results) != len(other.Results) { return false }
	for i, _tgt := range p.Results {
		_src50 := other.Results[i]
		if !_tgt.Equals(_src50) { return false }
	}
	if p.Exhaustive != other.Exhaustive { return false }
	if p.WaitedIndex != other.WaitedIndex {
		if p.WaitedIndex == nil || other.WaitedIndex == nil {
			return false
		}
		if (*p.WaitedIndex) != (*other.WaitedIndex) { return false }
	}
	return true
}

func (p *AggregateQueryRawResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryRawResult_(%+v)", *p)
}

func (p *AggregateQueryRawResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryRawResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryRawResult_)(nil)

func (p *AggregateQueryRawResult_) Validate() error {
	return nil
}

// Attributes:
//  - TagName
//  - TagValues
// 
type AggregateQueryRawResultTagNameElement struct {
	TagName []byte `thrift:"tagName,1,required" db:"tagName" json:"tagName"`
	TagValues []*AggregateQueryRawResultTagValueElement `thrift:"tagValues,2" db:"tagValues" json:"tagValues,omitempty"`
}

func NewAggregateQueryRawResultTagNameElement() *AggregateQueryRawResultTagNameElement {
	return &AggregateQueryRawResultTagNameElement{}
}



func (p *AggregateQueryRawResultTagNameElement) GetTagName() []byte {
	return p.TagName
}

var AggregateQueryRawResultTagNameElement_TagValues_DEFAULT []*AggregateQueryRawResultTagValueElement


func (p *AggregateQueryRawResultTagNameElement) GetTagValues() []*AggregateQueryRawResultTagValueElement {
	return p.TagValues
}

func (p *AggregateQueryRawResultTagNameElement) IsSetTagValues() bool {
	return p.TagValues != nil
}

func (p *AggregateQueryRawResultTagNameElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTagName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTagName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTagName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TagName is not set"));
	}
	return nil
}

func (p *AggregateQueryRawResultTagNameElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.TagName = v
	}
	return nil
}

func (p *AggregateQueryRawResultTagNameElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*AggregateQueryRawResultTagValueElement, 0, size)
	p.TagValues = tSlice
	for i := 0; i < size; i++ {
		_elem51 := &AggregateQueryRawResultTagValueElement{}
		if err := _elem51.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem51), err)
		}
		p.TagValues = append(p.TagValues, _elem51)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryRawResultTagNameElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryRawResultTagNameElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryRawResultTagNameElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tagName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tagName: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.TagName); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tagName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tagName: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawResultTagNameElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTagValues() {
		if err := oprot.WriteFieldBegin(ctx, "tagValues", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tagValues: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.TagValues)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.TagValues {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tagValues: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRawResultTagNameElement) Equals(other *AggregateQueryRawResultTagNameElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.TagName, other.TagName) != 0 { return false }
	if len(p.TagValues) != len(other.TagValues) { return false }
	for i, _tgt := range p.TagValues {
		_src52 := other.TagValues[i]
		if !_tgt.Equals(_src52) { return false }
	}
	return true
}

func (p *AggregateQueryRawResultTagNameElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryRawResultTagNameElement(%+v)", *p)
}

func (p *AggregateQueryRawResultTagNameElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryRawResultTagNameElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryRawResultTagNameElement)(nil)

func (p *AggregateQueryRawResultTagNameElement) Validate() error {
	return nil
}

// Attributes:
//  - TagValue
// 
type AggregateQueryRawResultTagValueElement struct {
	TagValue []byte `thrift:"tagValue,1,required" db:"tagValue" json:"tagValue"`
}

func NewAggregateQueryRawResultTagValueElement() *AggregateQueryRawResultTagValueElement {
	return &AggregateQueryRawResultTagValueElement{}
}



func (p *AggregateQueryRawResultTagValueElement) GetTagValue() []byte {
	return p.TagValue
}

func (p *AggregateQueryRawResultTagValueElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTagValue bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTagValue = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTagValue{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TagValue is not set"));
	}
	return nil
}

func (p *AggregateQueryRawResultTagValueElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.TagValue = v
	}
	return nil
}

func (p *AggregateQueryRawResultTagValueElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryRawResultTagValueElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryRawResultTagValueElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tagValue", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tagValue: ", p), err)
	}
	if err := oprot.WriteBinary(ctx, p.TagValue); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tagValue (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tagValue: ", p), err)
	}
	return err
}

func (p *AggregateQueryRawResultTagValueElement) Equals(other *AggregateQueryRawResultTagValueElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if bytes.Compare(p.TagValue, other.TagValue) != 0 { return false }
	return true
}

func (p *AggregateQueryRawResultTagValueElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryRawResultTagValueElement(%+v)", *p)
}

func (p *AggregateQueryRawResultTagValueElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryRawResultTagValueElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryRawResultTagValueElement)(nil)

func (p *AggregateQueryRawResultTagValueElement) Validate() error {
	return nil
}

// Attributes:
//  - Query
//  - RangeStart
//  - RangeEnd
//  - NameSpace
//  - SeriesLimit
//  - TagNameFilter
//  - AggregateQueryType
//  - RangeType
//  - Source
//  - DocsLimit
//  - RequireExhaustive
//  - RequireNoWait
// 
type AggregateQueryRequest struct {
	Query *Query `thrift:"query,1" db:"query" json:"query,omitempty"`
	RangeStart int64 `thrift:"rangeStart,2,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,3,required" db:"rangeEnd" json:"rangeEnd"`
	NameSpace string `thrift:"nameSpace,4,required" db:"nameSpace" json:"nameSpace"`
	SeriesLimit *int64 `thrift:"seriesLimit,5" db:"seriesLimit" json:"seriesLimit,omitempty"`
	TagNameFilter []string `thrift:"tagNameFilter,6" db:"tagNameFilter" json:"tagNameFilter,omitempty"`
	AggregateQueryType AggregateQueryType `thrift:"aggregateQueryType,7" db:"aggregateQueryType" json:"aggregateQueryType"`
	RangeType TimeType `thrift:"rangeType,8" db:"rangeType" json:"rangeType"`
	Source []byte `thrift:"source,9" db:"source" json:"source,omitempty"`
	DocsLimit *int64 `thrift:"docsLimit,10" db:"docsLimit" json:"docsLimit,omitempty"`
	RequireExhaustive *bool `thrift:"requireExhaustive,11" db:"requireExhaustive" json:"requireExhaustive,omitempty"`
	RequireNoWait *bool `thrift:"requireNoWait,12" db:"requireNoWait" json:"requireNoWait,omitempty"`
}

func NewAggregateQueryRequest() *AggregateQueryRequest {
	return &AggregateQueryRequest{
		AggregateQueryType: 1,
		RangeType: 0,
	}
}

var AggregateQueryRequest_Query_DEFAULT *Query

func (p *AggregateQueryRequest) GetQuery() *Query {
	if !p.IsSetQuery() {
		return AggregateQueryRequest_Query_DEFAULT
	}
	return p.Query
}



func (p *AggregateQueryRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *AggregateQueryRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *AggregateQueryRequest) GetNameSpace() string {
	return p.NameSpace
}

var AggregateQueryRequest_SeriesLimit_DEFAULT int64

func (p *AggregateQueryRequest) GetSeriesLimit() int64 {
	if !p.IsSetSeriesLimit() {
		return AggregateQueryRequest_SeriesLimit_DEFAULT
	}
	return *p.SeriesLimit
}

var AggregateQueryRequest_TagNameFilter_DEFAULT []string


func (p *AggregateQueryRequest) GetTagNameFilter() []string {
	return p.TagNameFilter
}

var AggregateQueryRequest_AggregateQueryType_DEFAULT AggregateQueryType = 1


func (p *AggregateQueryRequest) GetAggregateQueryType() AggregateQueryType {
	return p.AggregateQueryType
}

var AggregateQueryRequest_RangeType_DEFAULT TimeType = 0


func (p *AggregateQueryRequest) GetRangeType() TimeType {
	return p.RangeType
}

var AggregateQueryRequest_Source_DEFAULT []byte


func (p *AggregateQueryRequest) GetSource() []byte {
	return p.Source
}

var AggregateQueryRequest_DocsLimit_DEFAULT int64

func (p *AggregateQueryRequest) GetDocsLimit() int64 {
	if !p.IsSetDocsLimit() {
		return AggregateQueryRequest_DocsLimit_DEFAULT
	}
	return *p.DocsLimit
}

var AggregateQueryRequest_RequireExhaustive_DEFAULT bool

func (p *AggregateQueryRequest) GetRequireExhaustive() bool {
	if !p.IsSetRequireExhaustive() {
		return AggregateQueryRequest_RequireExhaustive_DEFAULT
	}
	return *p.RequireExhaustive
}

var AggregateQueryRequest_RequireNoWait_DEFAULT bool

func (p *AggregateQueryRequest) GetRequireNoWait() bool {
	if !p.IsSetRequireNoWait() {
		return AggregateQueryRequest_RequireNoWait_DEFAULT
	}
	return *p.RequireNoWait
}

func (p *AggregateQueryRequest) IsSetQuery() bool {
	return p.Query != nil
}

func (p *AggregateQueryRequest) IsSetSeriesLimit() bool {
	return p.SeriesLimit != nil
}

func (p *AggregateQueryRequest) IsSetTagNameFilter() bool {
	return p.TagNameFilter != nil
}

func (p *AggregateQueryRequest) IsSetAggregateQueryType() bool {
	return p.AggregateQueryType != AggregateQueryRequest_AggregateQueryType_DEFAULT
}

func (p *AggregateQueryRequest) IsSetRangeType() bool {
	return p.RangeType != AggregateQueryRequest_RangeType_DEFAULT
}

func (p *AggregateQueryRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *AggregateQueryRequest) IsSetDocsLimit() bool {
	return p.DocsLimit != nil
}

func (p *AggregateQueryRequest) IsSetRequireExhaustive() bool {
	return p.RequireExhaustive != nil
}

func (p *AggregateQueryRequest) IsSetRequireNoWait() bool {
	return p.RequireNoWait != nil
}

func (p *AggregateQueryRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 11:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField11(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 12:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField12(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.SeriesLimit = &v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]string, 0, size)
	p.TagNameFilter = tSlice
	for i := 0; i < size; i++ {
		var _elem53 string
		if v, err := iprot.ReadString(ctx); err != nil {
			return thrift.PrependError("error reading field 0: ", err)
		} else {
			_elem53 = v
		}
		p.TagNameFilter = append(p.TagNameFilter, _elem53)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := AggregateQueryType(v)
		p.AggregateQueryType = temp
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 10: ", err)
	} else {
		p.DocsLimit = &v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField11(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 11: ", err)
	} else {
		p.RequireExhaustive = &v
	}
	return nil
}

func (p *AggregateQueryRequest) ReadField12(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 12: ", err)
	} else {
		p.RequireNoWait = &v
	}
	return nil
}

func (p *AggregateQueryRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
		if err := p.writeField11(ctx, oprot); err != nil { return err }
		if err := p.writeField12(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetQuery() {
		if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
		}
		if err := p.Query.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeStart: ", p), err)
	}
	return err
}

func (p *AggregateQueryRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeEnd: ", p), err)
	}
	return err
}

func (p *AggregateQueryRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:nameSpace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:nameSpace: ", p), err)
	}
	return err
}

func (p *AggregateQueryRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSeriesLimit() {
		if err := oprot.WriteFieldBegin(ctx, "seriesLimit", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:seriesLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.SeriesLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.seriesLimit (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:seriesLimit: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTagNameFilter() {
		if err := oprot.WriteFieldBegin(ctx, "tagNameFilter", thrift.LIST, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:tagNameFilter: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRING, len(p.TagNameFilter)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.TagNameFilter {
			if err := oprot.WriteString(ctx, string(v)); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T. (0) field write error: ", p), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:tagNameFilter: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAggregateQueryType() {
		if err := oprot.WriteFieldBegin(ctx, "aggregateQueryType", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:aggregateQueryType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.AggregateQueryType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.aggregateQueryType (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:aggregateQueryType: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeType", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:rangeType: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:source: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDocsLimit() {
		if err := oprot.WriteFieldBegin(ctx, "docsLimit", thrift.I64, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:docsLimit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.DocsLimit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.docsLimit (10) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:docsLimit: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField11(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireExhaustive() {
		if err := oprot.WriteFieldBegin(ctx, "requireExhaustive", thrift.BOOL, 11); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 11:requireExhaustive: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.RequireExhaustive)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireExhaustive (11) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 11:requireExhaustive: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) writeField12(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRequireNoWait() {
		if err := oprot.WriteFieldBegin(ctx, "requireNoWait", thrift.BOOL, 12); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 12:requireNoWait: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.RequireNoWait)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.requireNoWait (12) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 12:requireNoWait: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryRequest) Equals(other *AggregateQueryRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Query.Equals(other.Query) { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.NameSpace != other.NameSpace { return false }
	if p.SeriesLimit != other.SeriesLimit {
		if p.SeriesLimit == nil || other.SeriesLimit == nil {
			return false
		}
		if (*p.SeriesLimit) != (*other.SeriesLimit) { return false }
	}
	if len(p.TagNameFilter) != len(other.TagNameFilter) { return false }
	for i, _tgt := range p.TagNameFilter {
		_src54 := other.TagNameFilter[i]
		if _tgt != _src54 { return false }
	}
	if p.AggregateQueryType != other.AggregateQueryType { return false }
	if p.RangeType != other.RangeType { return false }
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	if p.DocsLimit != other.DocsLimit {
		if p.DocsLimit == nil || other.DocsLimit == nil {
			return false
		}
		if (*p.DocsLimit) != (*other.DocsLimit) { return false }
	}
	if p.RequireExhaustive != other.RequireExhaustive {
		if p.RequireExhaustive == nil || other.RequireExhaustive == nil {
			return false
		}
		if (*p.RequireExhaustive) != (*other.RequireExhaustive) { return false }
	}
	if p.RequireNoWait != other.RequireNoWait {
		if p.RequireNoWait == nil || other.RequireNoWait == nil {
			return false
		}
		if (*p.RequireNoWait) != (*other.RequireNoWait) { return false }
	}
	return true
}

func (p *AggregateQueryRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryRequest(%+v)", *p)
}

func (p *AggregateQueryRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryRequest)(nil)

func (p *AggregateQueryRequest) Validate() error {
	return nil
}

// Attributes:
//  - Results
//  - Exhaustive
// 
type AggregateQueryResult_ struct {
	Results []*AggregateQueryResultTagNameElement `thrift:"results,1,required" db:"results" json:"results"`
	Exhaustive bool `thrift:"exhaustive,2,required" db:"exhaustive" json:"exhaustive"`
}

func NewAggregateQueryResult_() *AggregateQueryResult_ {
	return &AggregateQueryResult_{}
}



func (p *AggregateQueryResult_) GetResults() []*AggregateQueryResultTagNameElement {
	return p.Results
}



func (p *AggregateQueryResult_) GetExhaustive() bool {
	return p.Exhaustive
}

func (p *AggregateQueryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetResults bool = false;
	var issetExhaustive bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetResults = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetExhaustive = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetResults{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Results is not set"));
	}
	if !issetExhaustive{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Exhaustive is not set"));
	}
	return nil
}

func (p *AggregateQueryResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*AggregateQueryResultTagNameElement, 0, size)
	p.Results = tSlice
	for i := 0; i < size; i++ {
		_elem55 := &AggregateQueryResultTagNameElement{}
		if err := _elem55.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem55), err)
		}
		p.Results = append(p.Results, _elem55)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Exhaustive = v
	}
	return nil
}

func (p *AggregateQueryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "results", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:results: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Results)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Results {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:results: ", p), err)
	}
	return err
}

func (p *AggregateQueryResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "exhaustive", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:exhaustive: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Exhaustive)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.exhaustive (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:exhaustive: ", p), err)
	}
	return err
}

func (p *AggregateQueryResult_) Equals(other *AggregateQueryResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Results) != len(other.Results) { return false }
	for i, _tgt := range p.Results {
		_src56 := other.Results[i]
		if !_tgt.Equals(_src56) { return false }
	}
	if p.Exhaustive != other.Exhaustive { return false }
	return true
}

func (p *AggregateQueryResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryResult_(%+v)", *p)
}

func (p *AggregateQueryResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryResult_)(nil)

func (p *AggregateQueryResult_) Validate() error {
	return nil
}

// Attributes:
//  - TagName
//  - TagValues
// 
type AggregateQueryResultTagNameElement struct {
	TagName string `thrift:"tagName,1,required" db:"tagName" json:"tagName"`
	TagValues []*AggregateQueryResultTagValueElement `thrift:"tagValues,2" db:"tagValues" json:"tagValues,omitempty"`
}

func NewAggregateQueryResultTagNameElement() *AggregateQueryResultTagNameElement {
	return &AggregateQueryResultTagNameElement{}
}



func (p *AggregateQueryResultTagNameElement) GetTagName() string {
	return p.TagName
}

var AggregateQueryResultTagNameElement_TagValues_DEFAULT []*AggregateQueryResultTagValueElement


func (p *AggregateQueryResultTagNameElement) GetTagValues() []*AggregateQueryResultTagValueElement {
	return p.TagValues
}

func (p *AggregateQueryResultTagNameElement) IsSetTagValues() bool {
	return p.TagValues != nil
}

func (p *AggregateQueryResultTagNameElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTagName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTagName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTagName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TagName is not set"));
	}
	return nil
}

func (p *AggregateQueryResultTagNameElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.TagName = v
	}
	return nil
}

func (p *AggregateQueryResultTagNameElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*AggregateQueryResultTagValueElement, 0, size)
	p.TagValues = tSlice
	for i := 0; i < size; i++ {
		_elem57 := &AggregateQueryResultTagValueElement{}
		if err := _elem57.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem57), err)
		}
		p.TagValues = append(p.TagValues, _elem57)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *AggregateQueryResultTagNameElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryResultTagNameElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryResultTagNameElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tagName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tagName: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.TagName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tagName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tagName: ", p), err)
	}
	return err
}

func (p *AggregateQueryResultTagNameElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTagValues() {
		if err := oprot.WriteFieldBegin(ctx, "tagValues", thrift.LIST, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tagValues: ", p), err)
		}
		if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.TagValues)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.TagValues {
			if err := v.Write(ctx, oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(ctx); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tagValues: ", p), err)
		}
	}
	return err
}

func (p *AggregateQueryResultTagNameElement) Equals(other *AggregateQueryResultTagNameElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.TagName != other.TagName { return false }
	if len(p.TagValues) != len(other.TagValues) { return false }
	for i, _tgt := range p.TagValues {
		_src58 := other.TagValues[i]
		if !_tgt.Equals(_src58) { return false }
	}
	return true
}

func (p *AggregateQueryResultTagNameElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryResultTagNameElement(%+v)", *p)
}

func (p *AggregateQueryResultTagNameElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryResultTagNameElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryResultTagNameElement)(nil)

func (p *AggregateQueryResultTagNameElement) Validate() error {
	return nil
}

// Attributes:
//  - TagValue
// 
type AggregateQueryResultTagValueElement struct {
	TagValue string `thrift:"tagValue,1,required" db:"tagValue" json:"tagValue"`
}

func NewAggregateQueryResultTagValueElement() *AggregateQueryResultTagValueElement {
	return &AggregateQueryResultTagValueElement{}
}



func (p *AggregateQueryResultTagValueElement) GetTagValue() string {
	return p.TagValue
}

func (p *AggregateQueryResultTagValueElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetTagValue bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetTagValue = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetTagValue{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TagValue is not set"));
	}
	return nil
}

func (p *AggregateQueryResultTagValueElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.TagValue = v
	}
	return nil
}

func (p *AggregateQueryResultTagValueElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateQueryResultTagValueElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateQueryResultTagValueElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tagValue", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:tagValue: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.TagValue)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.tagValue (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:tagValue: ", p), err)
	}
	return err
}

func (p *AggregateQueryResultTagValueElement) Equals(other *AggregateQueryResultTagValueElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.TagValue != other.TagValue { return false }
	return true
}

func (p *AggregateQueryResultTagValueElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateQueryResultTagValueElement(%+v)", *p)
}

func (p *AggregateQueryResultTagValueElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateQueryResultTagValueElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateQueryResultTagValueElement)(nil)

func (p *AggregateQueryResultTagValueElement) Validate() error {
	return nil
}

// Attributes:
//  - Query
//  - RangeStart
//  - RangeEnd
//  - NameSpace
//  - Limit
//  - NoData
//  - RangeType
//  - ResultTimeType
//  - Source
//  - ClusterOptions
// 
type QueryRequest struct {
	Query *Query `thrift:"query,1,required" db:"query" json:"query"`
	RangeStart int64 `thrift:"rangeStart,2,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,3,required" db:"rangeEnd" json:"rangeEnd"`
	NameSpace string `thrift:"nameSpace,4,required" db:"nameSpace" json:"nameSpace"`
	Limit *int64 `thrift:"limit,5" db:"limit" json:"limit,omitempty"`
	NoData *bool `thrift:"noData,6" db:"noData" json:"noData,omitempty"`
	RangeType TimeType `thrift:"rangeType,7" db:"rangeType" json:"rangeType"`
	ResultTimeType TimeType `thrift:"resultTimeType,8" db:"resultTimeType" json:"resultTimeType"`
	Source []byte `thrift:"source,9" db:"source" json:"source,omitempty"`
	ClusterOptions *ClusterQueryOptions `thrift:"clusterOptions,10" db:"clusterOptions" json:"clusterOptions,omitempty"`
}

func NewQueryRequest() *QueryRequest {
	return &QueryRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
}

var QueryRequest_Query_DEFAULT *Query

func (p *QueryRequest) GetQuery() *Query {
	if !p.IsSetQuery() {
		return QueryRequest_Query_DEFAULT
	}
	return p.Query
}



func (p *QueryRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *QueryRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *QueryRequest) GetNameSpace() string {
	return p.NameSpace
}

var QueryRequest_Limit_DEFAULT int64

func (p *QueryRequest) GetLimit() int64 {
	if !p.IsSetLimit() {
		return QueryRequest_Limit_DEFAULT
	}
	return *p.Limit
}

var QueryRequest_NoData_DEFAULT bool

func (p *QueryRequest) GetNoData() bool {
	if !p.IsSetNoData() {
		return QueryRequest_NoData_DEFAULT
	}
	return *p.NoData
}

var QueryRequest_RangeType_DEFAULT TimeType = 0


func (p *QueryRequest) GetRangeType() TimeType {
	return p.RangeType
}

var QueryRequest_ResultTimeType_DEFAULT TimeType = 0


func (p *QueryRequest) GetResultTimeType() TimeType {
	return p.ResultTimeType
}

var QueryRequest_Source_DEFAULT []byte


func (p *QueryRequest) GetSource() []byte {
	return p.Source
}

var QueryRequest_ClusterOptions_DEFAULT *ClusterQueryOptions

func (p *QueryRequest) GetClusterOptions() *ClusterQueryOptions {
	if !p.IsSetClusterOptions() {
		return QueryRequest_ClusterOptions_DEFAULT
	}
	return p.ClusterOptions
}

func (p *QueryRequest) IsSetQuery() bool {
	return p.Query != nil
}

func (p *QueryRequest) IsSetLimit() bool {
	return p.Limit != nil
}

func (p *QueryRequest) IsSetNoData() bool {
	return p.NoData != nil
}

func (p *QueryRequest) IsSetRangeType() bool {
	return p.RangeType != QueryRequest_RangeType_DEFAULT
}

func (p *QueryRequest) IsSetResultTimeType() bool {
	return p.ResultTimeType != QueryRequest_ResultTimeType_DEFAULT
}

func (p *QueryRequest) IsSetSource() bool {
	return p.Source != nil
}

func (p *QueryRequest) IsSetClusterOptions() bool {
	return p.ClusterOptions != nil
}

func (p *QueryRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetNameSpace bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetQuery = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetNameSpace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 9:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField9(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 10:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField10(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetNameSpace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field NameSpace is not set"));
	}
	return nil
}

func (p *QueryRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *QueryRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *QueryRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *QueryRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.NameSpace = v
	}
	return nil
}

func (p *QueryRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Limit = &v
	}
	return nil
}

func (p *QueryRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.NoData = &v
	}
	return nil
}

func (p *QueryRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *QueryRequest) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		temp := TimeType(v)
		p.ResultTimeType = temp
	}
	return nil
}

func (p *QueryRequest) ReadField9(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(ctx); err != nil {
		return thrift.PrependError("error reading field 9: ", err)
	} else {
		p.Source = v
	}
	return nil
}

func (p *QueryRequest) ReadField10(ctx context.Context, iprot thrift.TProtocol) error {
	p.ClusterOptions = &ClusterQueryOptions{}
	if err := p.ClusterOptions.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.ClusterOptions), err)
	}
	return nil
}

func (p *QueryRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "QueryRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
		if err := p.writeField9(ctx, oprot); err != nil { return err }
		if err := p.writeField10(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *QueryRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := p.Query.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *QueryRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:rangeStart: ", p), err)
	}
	return err
}

func (p *QueryRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeEnd: ", p), err)
	}
	return err
}

func (p *QueryRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "nameSpace", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:nameSpace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.NameSpace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.nameSpace (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:nameSpace: ", p), err)
	}
	return err
}

func (p *QueryRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetLimit() {
		if err := oprot.WriteFieldBegin(ctx, "limit", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:limit: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Limit)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.limit (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:limit: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetNoData() {
		if err := oprot.WriteFieldBegin(ctx, "noData", thrift.BOOL, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:noData: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.NoData)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.noData (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:noData: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeType", thrift.I32, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:rangeType: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetResultTimeType() {
		if err := oprot.WriteFieldBegin(ctx, "resultTimeType", thrift.I32, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:resultTimeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.ResultTimeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.resultTimeType (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:resultTimeType: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) writeField9(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSource() {
		if err := oprot.WriteFieldBegin(ctx, "source", thrift.STRING, 9); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 9:source: ", p), err)
		}
		if err := oprot.WriteBinary(ctx, p.Source); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.source (9) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 9:source: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) writeField10(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetClusterOptions() {
		if err := oprot.WriteFieldBegin(ctx, "clusterOptions", thrift.STRUCT, 10); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 10:clusterOptions: ", p), err)
		}
		if err := p.ClusterOptions.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.ClusterOptions), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 10:clusterOptions: ", p), err)
		}
	}
	return err
}

func (p *QueryRequest) Equals(other *QueryRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Query.Equals(other.Query) { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.NameSpace != other.NameSpace { return false }
	if p.Limit != other.Limit {
		if p.Limit == nil || other.Limit == nil {
			return false
		}
		if (*p.Limit) != (*other.Limit) { return false }
	}
	if p.NoData != other.NoData {
		if p.NoData == nil || other.NoData == nil {
			return false
		}
		if (*p.NoData) != (*other.NoData) { return false }
	}
	if p.RangeType != other.RangeType { return false }
	if p.ResultTimeType != other.ResultTimeType { return false }
	if bytes.Compare(p.Source, other.Source) != 0 { return false }
	if !p.ClusterOptions.Equals(other.ClusterOptions) { return false }
	return true
}

func (p *QueryRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryRequest(%+v)", *p)
}

func (p *QueryRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.QueryRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*QueryRequest)(nil)

func (p *QueryRequest) Validate() error {
	return nil
}

// Attributes:
//  - ReadConsistency
//  - ConflictResolutionStrategy
// 
type ClusterQueryOptions struct {
	ReadConsistency *ReadConsistency `thrift:"readConsistency,1" db:"readConsistency" json:"readConsistency,omitempty"`
	ConflictResolutionStrategy *EqualTimestampStrategy `thrift:"conflictResolutionStrategy,2" db:"conflictResolutionStrategy" json:"conflictResolutionStrategy,omitempty"`
}

func NewClusterQueryOptions() *ClusterQueryOptions {
	return &ClusterQueryOptions{}
}

var ClusterQueryOptions_ReadConsistency_DEFAULT ReadConsistency

func (p *ClusterQueryOptions) GetReadConsistency() ReadConsistency {
	if !p.IsSetReadConsistency() {
		return ClusterQueryOptions_ReadConsistency_DEFAULT
	}
	return *p.ReadConsistency
}

var ClusterQueryOptions_ConflictResolutionStrategy_DEFAULT EqualTimestampStrategy

func (p *ClusterQueryOptions) GetConflictResolutionStrategy() EqualTimestampStrategy {
	if !p.IsSetConflictResolutionStrategy() {
		return ClusterQueryOptions_ConflictResolutionStrategy_DEFAULT
	}
	return *p.ConflictResolutionStrategy
}

func (p *ClusterQueryOptions) IsSetReadConsistency() bool {
	return p.ReadConsistency != nil
}

func (p *ClusterQueryOptions) IsSetConflictResolutionStrategy() bool {
	return p.ConflictResolutionStrategy != nil
}

func (p *ClusterQueryOptions) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterQueryOptions) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := ReadConsistency(v)
		p.ReadConsistency = &temp
	}
	return nil
}

func (p *ClusterQueryOptions) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		temp := EqualTimestampStrategy(v)
		p.ConflictResolutionStrategy = &temp
	}
	return nil
}

func (p *ClusterQueryOptions) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ClusterQueryOptions"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterQueryOptions) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetReadConsistency() {
		if err := oprot.WriteFieldBegin(ctx, "readConsistency", thrift.I32, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:readConsistency: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.ReadConsistency)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.readConsistency (1) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:readConsistency: ", p), err)
		}
	}
	return err
}

func (p *ClusterQueryOptions) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConflictResolutionStrategy() {
		if err := oprot.WriteFieldBegin(ctx, "conflictResolutionStrategy", thrift.I32, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:conflictResolutionStrategy: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(*p.ConflictResolutionStrategy)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.conflictResolutionStrategy (2) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:conflictResolutionStrategy: ", p), err)
		}
	}
	return err
}

func (p *ClusterQueryOptions) Equals(other *ClusterQueryOptions) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ReadConsistency != other.ReadConsistency {
		if p.ReadConsistency == nil || other.ReadConsistency == nil {
			return false
		}
		if (*p.ReadConsistency) != (*other.ReadConsistency) { return false }
	}
	if p.ConflictResolutionStrategy != other.ConflictResolutionStrategy {
		if p.ConflictResolutionStrategy == nil || other.ConflictResolutionStrategy == nil {
			return false
		}
		if (*p.ConflictResolutionStrategy) != (*other.ConflictResolutionStrategy) { return false }
	}
	return true
}

func (p *ClusterQueryOptions) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterQueryOptions(%+v)", *p)
}

func (p *ClusterQueryOptions) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterQueryOptions",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterQueryOptions)(nil)

func (p *ClusterQueryOptions) Validate() error {
	return nil
}

// Attributes:
//  - Results
//  - Exhaustive
// 
type QueryResult_ struct {
	Results []*QueryResultElement `thrift:"results,1,required" db:"results" json:"results"`
	Exhaustive bool `thrift:"exhaustive,2,required" db:"exhaustive" json:"exhaustive"`
}

func NewQueryResult_() *QueryResult_ {
	return &QueryResult_{}
}



func (p *QueryResult_) GetResults() []*QueryResultElement {
	return p.Results
}



func (p *QueryResult_) GetExhaustive() bool {
	return p.Exhaustive
}

func (p *QueryResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetResults bool = false;
	var issetExhaustive bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetResults = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetExhaustive = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetResults{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Results is not set"));
	}
	if !issetExhaustive{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Exhaustive is not set"));
	}
	return nil
}

func (p *QueryResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*QueryResultElement, 0, size)
	p.Results = tSlice
	for i := 0; i < size; i++ {
		_elem59 := &QueryResultElement{}
		if err := _elem59.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem59), err)
		}
		p.Results = append(p.Results, _elem59)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *QueryResult_) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Exhaustive = v
	}
	return nil
}

func (p *QueryResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "QueryResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *QueryResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "results", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:results: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Results)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Results {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:results: ", p), err)
	}
	return err
}

func (p *QueryResult_) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "exhaustive", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:exhaustive: ", p), err)
	}
	if err := oprot.WriteBool(ctx, bool(p.Exhaustive)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.exhaustive (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:exhaustive: ", p), err)
	}
	return err
}

func (p *QueryResult_) Equals(other *QueryResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Results) != len(other.Results) { return false }
	for i, _tgt := range p.Results {
		_src60 := other.Results[i]
		if !_tgt.Equals(_src60) { return false }
	}
	if p.Exhaustive != other.Exhaustive { return false }
	return true
}

func (p *QueryResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryResult_(%+v)", *p)
}

func (p *QueryResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.QueryResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*QueryResult_)(nil)

func (p *QueryResult_) Validate() error {
	return nil
}

// Attributes:
//  - ID
//  - Tags
//  - Datapoints
// 
type QueryResultElement struct {
	ID string `thrift:"id,1,required" db:"id" json:"id"`
	Tags []*Tag `thrift:"tags,2,required" db:"tags" json:"tags"`
	Datapoints []*Datapoint `thrift:"datapoints,3,required" db:"datapoints" json:"datapoints"`
}

func NewQueryResultElement() *QueryResultElement {
	return &QueryResultElement{}
}



func (p *QueryResultElement) GetID() string {
	return p.ID
}



func (p *QueryResultElement) GetTags() []*Tag {
	return p.Tags
}



func (p *QueryResultElement) GetDatapoints() []*Datapoint {
	return p.Datapoints
}

func (p *QueryResultElement) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetID bool = false;
	var issetTags bool = false;
	var issetDatapoints bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetID = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTags = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetDatapoints = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetID{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ID is not set"));
	}
	if !issetTags{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Tags is not set"));
	}
	if !issetDatapoints{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Datapoints is not set"));
	}
	return nil
}

func (p *QueryResultElement) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ID = v
	}
	return nil
}

func (p *QueryResultElement) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Tag, 0, size)
	p.Tags = tSlice
	for i := 0; i < size; i++ {
		_elem61 := &Tag{}
		if err := _elem61.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem61), err)
		}
		p.Tags = append(p.Tags, _elem61)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *QueryResultElement) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Datapoint, 0, size)
	p.Datapoints = tSlice
	for i := 0; i < size; i++ {
		_elem62 := &Datapoint{
			TimestampTimeType: 0,
		}
		if err := _elem62.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem62), err)
		}
		p.Datapoints = append(p.Datapoints, _elem62)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *QueryResultElement) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "QueryResultElement"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *QueryResultElement) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "id", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:id: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.ID)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.id (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:id: ", p), err)
	}
	return err
}

func (p *QueryResultElement) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "tags", thrift.LIST, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:tags: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Tags)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Tags {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:tags: ", p), err)
	}
	return err
}

func (p *QueryResultElement) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "datapoints", thrift.LIST, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:datapoints: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Datapoints)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Datapoints {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:datapoints: ", p), err)
	}
	return err
}

func (p *QueryResultElement) Equals(other *QueryResultElement) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ID != other.ID { return false }
	if len(p.Tags) != len(other.Tags) { return false }
	for i, _tgt := range p.Tags {
		_src63 := other.Tags[i]
		if !_tgt.Equals(_src63) { return false }
	}
	if len(p.Datapoints) != len(other.Datapoints) { return false }
	for i, _tgt := range p.Datapoints {
		_src64 := other.Datapoints[i]
		if !_tgt.Equals(_src64) { return false }
	}
	return true
}

func (p *QueryResultElement) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryResultElement(%+v)", *p)
}

func (p *QueryResultElement) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.QueryResultElement",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*QueryResultElement)(nil)

func (p *QueryResultElement) Validate() error {
	return nil
}

// Attributes:
//  - Field
//  - Term
// 
type TermQuery struct {
	Field string `thrift:"field,1,required" db:"field" json:"field"`
	Term string `thrift:"term,2,required" db:"term" json:"term"`
}

func NewTermQuery() *TermQuery {
	return &TermQuery{}
}



func (p *TermQuery) GetField() string {
	return p.Field
}



func (p *TermQuery) GetTerm() string {
	return p.Term
}

func (p *TermQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetField bool = false;
	var issetTerm bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetField = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTerm = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetField{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Field is not set"));
	}
	if !issetTerm{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Term is not set"));
	}
	return nil
}

func (p *TermQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Field = v
	}
	return nil
}

func (p *TermQuery) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Term = v
	}
	return nil
}

func (p *TermQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "TermQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *TermQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Field)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field: ", p), err)
	}
	return err
}

func (p *TermQuery) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "term", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:term: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Term)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.term (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:term: ", p), err)
	}
	return err
}

func (p *TermQuery) Equals(other *TermQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Field != other.Field { return false }
	if p.Term != other.Term { return false }
	return true
}

func (p *TermQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TermQuery(%+v)", *p)
}

func (p *TermQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.TermQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*TermQuery)(nil)

func (p *TermQuery) Validate() error {
	return nil
}

// Attributes:
//  - Field
//  - Regexp
// 
type RegexpQuery struct {
	Field string `thrift:"field,1,required" db:"field" json:"field"`
	Regexp string `thrift:"regexp,2,required" db:"regexp" json:"regexp"`
}

func NewRegexpQuery() *RegexpQuery {
	return &RegexpQuery{}
}



func (p *RegexpQuery) GetField() string {
	return p.Field
}



func (p *RegexpQuery) GetRegexp() string {
	return p.Regexp
}

func (p *RegexpQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetField bool = false;
	var issetRegexp bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetField = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetRegexp = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetField{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Field is not set"));
	}
	if !issetRegexp{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Regexp is not set"));
	}
	return nil
}

func (p *RegexpQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Field = v
	}
	return nil
}

func (p *RegexpQuery) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Regexp = v
	}
	return nil
}

func (p *RegexpQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "RegexpQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *RegexpQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Field)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field: ", p), err)
	}
	return err
}

func (p *RegexpQuery) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "regexp", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:regexp: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Regexp)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.regexp (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:regexp: ", p), err)
	}
	return err
}

func (p *RegexpQuery) Equals(other *RegexpQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Field != other.Field { return false }
	if p.Regexp != other.Regexp { return false }
	return true
}

func (p *RegexpQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RegexpQuery(%+v)", *p)
}

func (p *RegexpQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.RegexpQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*RegexpQuery)(nil)

func (p *RegexpQuery) Validate() error {
	return nil
}

// Attributes:
//  - Query
// 
type NegationQuery struct {
	Query *Query `thrift:"query,1,required" db:"query" json:"query"`
}

func NewNegationQuery() *NegationQuery {
	return &NegationQuery{}
}

var NegationQuery_Query_DEFAULT *Query

func (p *NegationQuery) GetQuery() *Query {
	if !p.IsSetQuery() {
		return NegationQuery_Query_DEFAULT
	}
	return p.Query
}

func (p *NegationQuery) IsSetQuery() bool {
	return p.Query != nil
}

func (p *NegationQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQuery bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetQuery = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQuery{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Query is not set"));
	}
	return nil
}

func (p *NegationQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Query), err)
	}
	return nil
}

func (p *NegationQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "NegationQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NegationQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "query", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:query: ", p), err)
	}
	if err := p.Query.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Query), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:query: ", p), err)
	}
	return err
}

func (p *NegationQuery) Equals(other *NegationQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Query.Equals(other.Query) { return false }
	return true
}

func (p *NegationQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NegationQuery(%+v)", *p)
}

func (p *NegationQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NegationQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NegationQuery)(nil)

func (p *NegationQuery) Validate() error {
	return nil
}

// Attributes:
//  - Queries
// 
type ConjunctionQuery struct {
	Queries []*Query `thrift:"queries,1,required" db:"queries" json:"queries"`
}

func NewConjunctionQuery() *ConjunctionQuery {
	return &ConjunctionQuery{}
}



func (p *ConjunctionQuery) GetQueries() []*Query {
	return p.Queries
}

func (p *ConjunctionQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQueries bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetQueries = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQueries{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Queries is not set"));
	}
	return nil
}

func (p *ConjunctionQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Query, 0, size)
	p.Queries = tSlice
	for i := 0; i < size; i++ {
		_elem65 := &Query{}
		if err := _elem65.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem65), err)
		}
		p.Queries = append(p.Queries, _elem65)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *ConjunctionQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "ConjunctionQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ConjunctionQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "queries", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:queries: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Queries)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Queries {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:queries: ", p), err)
	}
	return err
}

func (p *ConjunctionQuery) Equals(other *ConjunctionQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Queries) != len(other.Queries) { return false }
	for i, _tgt := range p.Queries {
		_src66 := other.Queries[i]
		if !_tgt.Equals(_src66) { return false }
	}
	return true
}

func (p *ConjunctionQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ConjunctionQuery(%+v)", *p)
}

func (p *ConjunctionQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ConjunctionQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ConjunctionQuery)(nil)

func (p *ConjunctionQuery) Validate() error {
	return nil
}

// Attributes:
//  - Queries
// 
type DisjunctionQuery struct {
	Queries []*Query `thrift:"queries,1,required" db:"queries" json:"queries"`
}

func NewDisjunctionQuery() *DisjunctionQuery {
	return &DisjunctionQuery{}
}



func (p *DisjunctionQuery) GetQueries() []*Query {
	return p.Queries
}

func (p *DisjunctionQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetQueries bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.LIST {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetQueries = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetQueries{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Queries is not set"));
	}
	return nil
}

func (p *DisjunctionQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin(ctx)
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*Query, 0, size)
	p.Queries = tSlice
	for i := 0; i < size; i++ {
		_elem67 := &Query{}
		if err := _elem67.Read(ctx, iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem67), err)
		}
		p.Queries = append(p.Queries, _elem67)
	}
	if err := iprot.ReadListEnd(ctx); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *DisjunctionQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DisjunctionQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DisjunctionQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "queries", thrift.LIST, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:queries: ", p), err)
	}
	if err := oprot.WriteListBegin(ctx, thrift.STRUCT, len(p.Queries)); err != nil {
		return thrift.PrependError("error writing list begin: ", err)
	}
	for _, v := range p.Queries {
		if err := v.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
		}
	}
	if err := oprot.WriteListEnd(ctx); err != nil {
		return thrift.PrependError("error writing list end: ", err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:queries: ", p), err)
	}
	return err
}

func (p *DisjunctionQuery) Equals(other *DisjunctionQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if len(p.Queries) != len(other.Queries) { return false }
	for i, _tgt := range p.Queries {
		_src68 := other.Queries[i]
		if !_tgt.Equals(_src68) { return false }
	}
	return true
}

func (p *DisjunctionQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisjunctionQuery(%+v)", *p)
}

func (p *DisjunctionQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DisjunctionQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DisjunctionQuery)(nil)

func (p *DisjunctionQuery) Validate() error {
	return nil
}

type AllQuery struct {
}

func NewAllQuery() *AllQuery {
	return &AllQuery{}
}

func (p *AllQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *AllQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AllQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AllQuery) Equals(other *AllQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *AllQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AllQuery(%+v)", *p)
}

func (p *AllQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AllQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AllQuery)(nil)

func (p *AllQuery) Validate() error {
	return nil
}

// Attributes:
//  - Field
// 
type FieldQuery struct {
	Field string `thrift:"field,1,required" db:"field" json:"field"`
}

func NewFieldQuery() *FieldQuery {
	return &FieldQuery{}
}



func (p *FieldQuery) GetField() string {
	return p.Field
}

func (p *FieldQuery) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetField bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetField = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetField{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Field is not set"));
	}
	return nil
}

func (p *FieldQuery) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Field = v
	}
	return nil
}

func (p *FieldQuery) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "FieldQuery"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *FieldQuery) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "field", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:field: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Field)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.field (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:field: ", p), err)
	}
	return err
}

func (p *FieldQuery) Equals(other *FieldQuery) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Field != other.Field { return false }
	return true
}

func (p *FieldQuery) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FieldQuery(%+v)", *p)
}

func (p *FieldQuery) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.FieldQuery",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*FieldQuery)(nil)

func (p *FieldQuery) Validate() error {
	return nil
}

// Attributes:
//  - Term
//  - Regexp
//  - Negation
//  - Conjunction
//  - Disjunction
//  - All
//  - Field
// 
type Query struct {
	Term *TermQuery `thrift:"term,1" db:"term" json:"term,omitempty"`
	Regexp *RegexpQuery `thrift:"regexp,2" db:"regexp" json:"regexp,omitempty"`
	Negation *NegationQuery `thrift:"negation,3" db:"negation" json:"negation,omitempty"`
	Conjunction *ConjunctionQuery `thrift:"conjunction,4" db:"conjunction" json:"conjunction,omitempty"`
	Disjunction *DisjunctionQuery `thrift:"disjunction,5" db:"disjunction" json:"disjunction,omitempty"`
	All *AllQuery `thrift:"all,6" db:"all" json:"all,omitempty"`
	Field *FieldQuery `thrift:"field,7" db:"field" json:"field,omitempty"`
}

func NewQuery() *Query {
	return &Query{}
}

var Query_Term_DEFAULT *TermQuery

func (p *Query) GetTerm() *TermQuery {
	if !p.IsSetTerm() {
		return Query_Term_DEFAULT
	}
	return p.Term
}

var Query_Regexp_DEFAULT *RegexpQuery

func (p *Query) GetRegexp() *RegexpQuery {
	if !p.IsSetRegexp() {
		return Query_Regexp_DEFAULT
	}
	return p.Regexp
}

var Query_Negation_DEFAULT *NegationQuery

func (p *Query) GetNegation() *NegationQuery {
	if !p.IsSetNegation() {
		return Query_Negation_DEFAULT
	}
	return p.Negation
}

var Query_Conjunction_DEFAULT *ConjunctionQuery

func (p *Query) GetConjunction() *ConjunctionQuery {
	if !p.IsSetConjunction() {
		return Query_Conjunction_DEFAULT
	}
	return p.Conjunction
}

var Query_Disjunction_DEFAULT *DisjunctionQuery

func (p *Query) GetDisjunction() *DisjunctionQuery {
	if !p.IsSetDisjunction() {
		return Query_Disjunction_DEFAULT
	}
	return p.Disjunction
}

var Query_All_DEFAULT *AllQuery

func (p *Query) GetAll() *AllQuery {
	if !p.IsSetAll() {
		return Query_All_DEFAULT
	}
	return p.All
}

var Query_Field_DEFAULT *FieldQuery

func (p *Query) GetField() *FieldQuery {
	if !p.IsSetField() {
		return Query_Field_DEFAULT
	}
	return p.Field
}

func (p *Query) IsSetTerm() bool {
	return p.Term != nil
}

func (p *Query) IsSetRegexp() bool {
	return p.Regexp != nil
}

func (p *Query) IsSetNegation() bool {
	return p.Negation != nil
}

func (p *Query) IsSetConjunction() bool {
	return p.Conjunction != nil
}

func (p *Query) IsSetDisjunction() bool {
	return p.Disjunction != nil
}

func (p *Query) IsSetAll() bool {
	return p.All != nil
}

func (p *Query) IsSetField() bool {
	return p.Field != nil
}

func (p *Query) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *Query) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Term = &TermQuery{}
	if err := p.Term.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Term), err)
	}
	return nil
}

func (p *Query) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	p.Regexp = &RegexpQuery{}
	if err := p.Regexp.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Regexp), err)
	}
	return nil
}

func (p *Query) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	p.Negation = &NegationQuery{}
	if err := p.Negation.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Negation), err)
	}
	return nil
}

func (p *Query) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	p.Conjunction = &ConjunctionQuery{}
	if err := p.Conjunction.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Conjunction), err)
	}
	return nil
}

func (p *Query) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	p.Disjunction = &DisjunctionQuery{}
	if err := p.Disjunction.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Disjunction), err)
	}
	return nil
}

func (p *Query) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	p.All = &AllQuery{}
	if err := p.All.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.All), err)
	}
	return nil
}

func (p *Query) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	p.Field = &FieldQuery{}
	if err := p.Field.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Field), err)
	}
	return nil
}

func (p *Query) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "Query"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *Query) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetTerm() {
		if err := oprot.WriteFieldBegin(ctx, "term", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:term: ", p), err)
		}
		if err := p.Term.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Term), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:term: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRegexp() {
		if err := oprot.WriteFieldBegin(ctx, "regexp", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:regexp: ", p), err)
		}
		if err := p.Regexp.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Regexp), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:regexp: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetNegation() {
		if err := oprot.WriteFieldBegin(ctx, "negation", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:negation: ", p), err)
		}
		if err := p.Negation.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Negation), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:negation: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConjunction() {
		if err := oprot.WriteFieldBegin(ctx, "conjunction", thrift.STRUCT, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:conjunction: ", p), err)
		}
		if err := p.Conjunction.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Conjunction), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:conjunction: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDisjunction() {
		if err := oprot.WriteFieldBegin(ctx, "disjunction", thrift.STRUCT, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:disjunction: ", p), err)
		}
		if err := p.Disjunction.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Disjunction), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:disjunction: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetAll() {
		if err := oprot.WriteFieldBegin(ctx, "all", thrift.STRUCT, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:all: ", p), err)
		}
		if err := p.All.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.All), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:all: ", p), err)
		}
	}
	return err
}

func (p *Query) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetField() {
		if err := oprot.WriteFieldBegin(ctx, "field", thrift.STRUCT, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:field: ", p), err)
		}
		if err := p.Field.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Field), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:field: ", p), err)
		}
	}
	return err
}

func (p *Query) Equals(other *Query) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if !p.Term.Equals(other.Term) { return false }
	if !p.Regexp.Equals(other.Regexp) { return false }
	if !p.Negation.Equals(other.Negation) { return false }
	if !p.Conjunction.Equals(other.Conjunction) { return false }
	if !p.Disjunction.Equals(other.Disjunction) { return false }
	if !p.All.Equals(other.All) { return false }
	if !p.Field.Equals(other.Field) { return false }
	return true
}

func (p *Query) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Query(%+v)", *p)
}

func (p *Query) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.Query",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*Query)(nil)

func (p *Query) Validate() error {
	return nil
}

// Attributes:
//  - SourceNamespace
//  - TargetNamespace
//  - RangeStart
//  - RangeEnd
//  - Step
//  - RangeType
// 
type AggregateTilesRequest struct {
	SourceNamespace string `thrift:"sourceNamespace,1,required" db:"sourceNamespace" json:"sourceNamespace"`
	TargetNamespace string `thrift:"targetNamespace,2,required" db:"targetNamespace" json:"targetNamespace"`
	RangeStart int64 `thrift:"rangeStart,3,required" db:"rangeStart" json:"rangeStart"`
	RangeEnd int64 `thrift:"rangeEnd,4,required" db:"rangeEnd" json:"rangeEnd"`
	Step string `thrift:"step,5,required" db:"step" json:"step"`
	RangeType TimeType `thrift:"rangeType,6" db:"rangeType" json:"rangeType"`
}

func NewAggregateTilesRequest() *AggregateTilesRequest {
	return &AggregateTilesRequest{
		RangeType: 0,
	}
}



func (p *AggregateTilesRequest) GetSourceNamespace() string {
	return p.SourceNamespace
}



func (p *AggregateTilesRequest) GetTargetNamespace() string {
	return p.TargetNamespace
}



func (p *AggregateTilesRequest) GetRangeStart() int64 {
	return p.RangeStart
}



func (p *AggregateTilesRequest) GetRangeEnd() int64 {
	return p.RangeEnd
}



func (p *AggregateTilesRequest) GetStep() string {
	return p.Step
}

var AggregateTilesRequest_RangeType_DEFAULT TimeType = 0


func (p *AggregateTilesRequest) GetRangeType() TimeType {
	return p.RangeType
}

func (p *AggregateTilesRequest) IsSetRangeType() bool {
	return p.RangeType != AggregateTilesRequest_RangeType_DEFAULT
}

func (p *AggregateTilesRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetSourceNamespace bool = false;
	var issetTargetNamespace bool = false;
	var issetRangeStart bool = false;
	var issetRangeEnd bool = false;
	var issetStep bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetSourceNamespace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetTargetNamespace = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
				issetRangeStart = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
				issetRangeEnd = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
				issetStep = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I32 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetSourceNamespace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field SourceNamespace is not set"));
	}
	if !issetTargetNamespace{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field TargetNamespace is not set"));
	}
	if !issetRangeStart{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeStart is not set"));
	}
	if !issetRangeEnd{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field RangeEnd is not set"));
	}
	if !issetStep{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Step is not set"));
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.SourceNamespace = v
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.TargetNamespace = v
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.RangeStart = v
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.RangeEnd = v
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Step = v
	}
	return nil
}

func (p *AggregateTilesRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		temp := TimeType(v)
		p.RangeType = temp
	}
	return nil
}

func (p *AggregateTilesRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateTilesRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateTilesRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "sourceNamespace", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:sourceNamespace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.SourceNamespace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.sourceNamespace (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:sourceNamespace: ", p), err)
	}
	return err
}

func (p *AggregateTilesRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "targetNamespace", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:targetNamespace: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.TargetNamespace)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.targetNamespace (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:targetNamespace: ", p), err)
	}
	return err
}

func (p *AggregateTilesRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeStart", thrift.I64, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:rangeStart: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeStart)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeStart (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:rangeStart: ", p), err)
	}
	return err
}

func (p *AggregateTilesRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "rangeEnd", thrift.I64, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:rangeEnd: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.RangeEnd)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.rangeEnd (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:rangeEnd: ", p), err)
	}
	return err
}

func (p *AggregateTilesRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "step", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:step: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Step)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.step (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:step: ", p), err)
	}
	return err
}

func (p *AggregateTilesRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetRangeType() {
		if err := oprot.WriteFieldBegin(ctx, "rangeType", thrift.I32, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:rangeType: ", p), err)
		}
		if err := oprot.WriteI32(ctx, int32(p.RangeType)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.rangeType (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:rangeType: ", p), err)
		}
	}
	return err
}

func (p *AggregateTilesRequest) Equals(other *AggregateTilesRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.SourceNamespace != other.SourceNamespace { return false }
	if p.TargetNamespace != other.TargetNamespace { return false }
	if p.RangeStart != other.RangeStart { return false }
	if p.RangeEnd != other.RangeEnd { return false }
	if p.Step != other.Step { return false }
	if p.RangeType != other.RangeType { return false }
	return true
}

func (p *AggregateTilesRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateTilesRequest(%+v)", *p)
}

func (p *AggregateTilesRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateTilesRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateTilesRequest)(nil)

func (p *AggregateTilesRequest) Validate() error {
	return nil
}

// Attributes:
//  - ProcessedTileCount
// 
type AggregateTilesResult_ struct {
	ProcessedTileCount int64 `thrift:"processedTileCount,1,required" db:"processedTileCount" json:"processedTileCount"`
}

func NewAggregateTilesResult_() *AggregateTilesResult_ {
	return &AggregateTilesResult_{}
}



func (p *AggregateTilesResult_) GetProcessedTileCount() int64 {
	return p.ProcessedTileCount
}

func (p *AggregateTilesResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetProcessedTileCount bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetProcessedTileCount = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetProcessedTileCount{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field ProcessedTileCount is not set"));
	}
	return nil
}

func (p *AggregateTilesResult_) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ProcessedTileCount = v
	}
	return nil
}

func (p *AggregateTilesResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "AggregateTilesResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *AggregateTilesResult_) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "processedTileCount", thrift.I64, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:processedTileCount: ", p), err)
	}
	if err := oprot.WriteI64(ctx, int64(p.ProcessedTileCount)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.processedTileCount (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:processedTileCount: ", p), err)
	}
	return err
}

func (p *AggregateTilesResult_) Equals(other *AggregateTilesResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.ProcessedTileCount != other.ProcessedTileCount { return false }
	return true
}

func (p *AggregateTilesResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AggregateTilesResult_(%+v)", *p)
}

func (p *AggregateTilesResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.AggregateTilesResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*AggregateTilesResult_)(nil)

func (p *AggregateTilesResult_) Validate() error {
	return nil
}

// Attributes:
//  - Name
//  - FilePathTemplate
//  - Interval
//  - Duration
//  - Debug
//  - ConditionalNumGoroutinesGreaterThan
//  - ConditionalNumGoroutinesLessThan
//  - ConditionalIsOverloaded
// 
type DebugProfileStartRequest struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
	FilePathTemplate string `thrift:"filePathTemplate,2,required" db:"filePathTemplate" json:"filePathTemplate"`
	Interval *string `thrift:"interval,3" db:"interval" json:"interval,omitempty"`
	Duration *string `thrift:"duration,4" db:"duration" json:"duration,omitempty"`
	Debug *int64 `thrift:"debug,5" db:"debug" json:"debug,omitempty"`
	ConditionalNumGoroutinesGreaterThan *int64 `thrift:"conditionalNumGoroutinesGreaterThan,6" db:"conditionalNumGoroutinesGreaterThan" json:"conditionalNumGoroutinesGreaterThan,omitempty"`
	ConditionalNumGoroutinesLessThan *int64 `thrift:"conditionalNumGoroutinesLessThan,7" db:"conditionalNumGoroutinesLessThan" json:"conditionalNumGoroutinesLessThan,omitempty"`
	ConditionalIsOverloaded *bool `thrift:"conditionalIsOverloaded,8" db:"conditionalIsOverloaded" json:"conditionalIsOverloaded,omitempty"`
}

func NewDebugProfileStartRequest() *DebugProfileStartRequest {
	return &DebugProfileStartRequest{}
}



func (p *DebugProfileStartRequest) GetName() string {
	return p.Name
}



func (p *DebugProfileStartRequest) GetFilePathTemplate() string {
	return p.FilePathTemplate
}

var DebugProfileStartRequest_Interval_DEFAULT string

func (p *DebugProfileStartRequest) GetInterval() string {
	if !p.IsSetInterval() {
		return DebugProfileStartRequest_Interval_DEFAULT
	}
	return *p.Interval
}

var DebugProfileStartRequest_Duration_DEFAULT string

func (p *DebugProfileStartRequest) GetDuration() string {
	if !p.IsSetDuration() {
		return DebugProfileStartRequest_Duration_DEFAULT
	}
	return *p.Duration
}

var DebugProfileStartRequest_Debug_DEFAULT int64

func (p *DebugProfileStartRequest) GetDebug() int64 {
	if !p.IsSetDebug() {
		return DebugProfileStartRequest_Debug_DEFAULT
	}
	return *p.Debug
}

var DebugProfileStartRequest_ConditionalNumGoroutinesGreaterThan_DEFAULT int64

func (p *DebugProfileStartRequest) GetConditionalNumGoroutinesGreaterThan() int64 {
	if !p.IsSetConditionalNumGoroutinesGreaterThan() {
		return DebugProfileStartRequest_ConditionalNumGoroutinesGreaterThan_DEFAULT
	}
	return *p.ConditionalNumGoroutinesGreaterThan
}

var DebugProfileStartRequest_ConditionalNumGoroutinesLessThan_DEFAULT int64

func (p *DebugProfileStartRequest) GetConditionalNumGoroutinesLessThan() int64 {
	if !p.IsSetConditionalNumGoroutinesLessThan() {
		return DebugProfileStartRequest_ConditionalNumGoroutinesLessThan_DEFAULT
	}
	return *p.ConditionalNumGoroutinesLessThan
}

var DebugProfileStartRequest_ConditionalIsOverloaded_DEFAULT bool

func (p *DebugProfileStartRequest) GetConditionalIsOverloaded() bool {
	if !p.IsSetConditionalIsOverloaded() {
		return DebugProfileStartRequest_ConditionalIsOverloaded_DEFAULT
	}
	return *p.ConditionalIsOverloaded
}

func (p *DebugProfileStartRequest) IsSetInterval() bool {
	return p.Interval != nil
}

func (p *DebugProfileStartRequest) IsSetDuration() bool {
	return p.Duration != nil
}

func (p *DebugProfileStartRequest) IsSetDebug() bool {
	return p.Debug != nil
}

func (p *DebugProfileStartRequest) IsSetConditionalNumGoroutinesGreaterThan() bool {
	return p.ConditionalNumGoroutinesGreaterThan != nil
}

func (p *DebugProfileStartRequest) IsSetConditionalNumGoroutinesLessThan() bool {
	return p.ConditionalNumGoroutinesLessThan != nil
}

func (p *DebugProfileStartRequest) IsSetConditionalIsOverloaded() bool {
	return p.ConditionalIsOverloaded != nil
}

func (p *DebugProfileStartRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false;
	var issetFilePathTemplate bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 2:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField2(ctx, iprot); err != nil {
					return err
				}
				issetFilePathTemplate = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 3:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField3(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 4:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField4(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 5:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField5(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 6:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField6(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 7:
			if fieldTypeId == thrift.I64 {
				if err := p.ReadField7(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 8:
			if fieldTypeId == thrift.BOOL {
				if err := p.ReadField8(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
	}
	if !issetFilePathTemplate{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field FilePathTemplate is not set"));
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField2(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.FilePathTemplate = v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField3(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.Interval = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField4(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.Duration = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField5(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.Debug = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField6(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.ConditionalNumGoroutinesGreaterThan = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField7(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(ctx); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.ConditionalNumGoroutinesLessThan = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) ReadField8(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(ctx); err != nil {
		return thrift.PrependError("error reading field 8: ", err)
	} else {
		p.ConditionalIsOverloaded = &v
	}
	return nil
}

func (p *DebugProfileStartRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugProfileStartRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
		if err := p.writeField2(ctx, oprot); err != nil { return err }
		if err := p.writeField3(ctx, oprot); err != nil { return err }
		if err := p.writeField4(ctx, oprot); err != nil { return err }
		if err := p.writeField5(ctx, oprot); err != nil { return err }
		if err := p.writeField6(ctx, oprot); err != nil { return err }
		if err := p.writeField7(ctx, oprot); err != nil { return err }
		if err := p.writeField8(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugProfileStartRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *DebugProfileStartRequest) writeField2(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "filePathTemplate", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:filePathTemplate: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.FilePathTemplate)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.filePathTemplate (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:filePathTemplate: ", p), err)
	}
	return err
}

func (p *DebugProfileStartRequest) writeField3(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetInterval() {
		if err := oprot.WriteFieldBegin(ctx, "interval", thrift.STRING, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:interval: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Interval)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.interval (3) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:interval: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) writeField4(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDuration() {
		if err := oprot.WriteFieldBegin(ctx, "duration", thrift.STRING, 4); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:duration: ", p), err)
		}
		if err := oprot.WriteString(ctx, string(*p.Duration)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.duration (4) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 4:duration: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) writeField5(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetDebug() {
		if err := oprot.WriteFieldBegin(ctx, "debug", thrift.I64, 5); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:debug: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.Debug)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.debug (5) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 5:debug: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) writeField6(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConditionalNumGoroutinesGreaterThan() {
		if err := oprot.WriteFieldBegin(ctx, "conditionalNumGoroutinesGreaterThan", thrift.I64, 6); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:conditionalNumGoroutinesGreaterThan: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ConditionalNumGoroutinesGreaterThan)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.conditionalNumGoroutinesGreaterThan (6) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 6:conditionalNumGoroutinesGreaterThan: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) writeField7(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConditionalNumGoroutinesLessThan() {
		if err := oprot.WriteFieldBegin(ctx, "conditionalNumGoroutinesLessThan", thrift.I64, 7); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:conditionalNumGoroutinesLessThan: ", p), err)
		}
		if err := oprot.WriteI64(ctx, int64(*p.ConditionalNumGoroutinesLessThan)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.conditionalNumGoroutinesLessThan (7) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 7:conditionalNumGoroutinesLessThan: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) writeField8(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetConditionalIsOverloaded() {
		if err := oprot.WriteFieldBegin(ctx, "conditionalIsOverloaded", thrift.BOOL, 8); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 8:conditionalIsOverloaded: ", p), err)
		}
		if err := oprot.WriteBool(ctx, bool(*p.ConditionalIsOverloaded)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.conditionalIsOverloaded (8) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 8:conditionalIsOverloaded: ", p), err)
		}
	}
	return err
}

func (p *DebugProfileStartRequest) Equals(other *DebugProfileStartRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Name != other.Name { return false }
	if p.FilePathTemplate != other.FilePathTemplate { return false }
	if p.Interval != other.Interval {
		if p.Interval == nil || other.Interval == nil {
			return false
		}
		if (*p.Interval) != (*other.Interval) { return false }
	}
	if p.Duration != other.Duration {
		if p.Duration == nil || other.Duration == nil {
			return false
		}
		if (*p.Duration) != (*other.Duration) { return false }
	}
	if p.Debug != other.Debug {
		if p.Debug == nil || other.Debug == nil {
			return false
		}
		if (*p.Debug) != (*other.Debug) { return false }
	}
	if p.ConditionalNumGoroutinesGreaterThan != other.ConditionalNumGoroutinesGreaterThan {
		if p.ConditionalNumGoroutinesGreaterThan == nil || other.ConditionalNumGoroutinesGreaterThan == nil {
			return false
		}
		if (*p.ConditionalNumGoroutinesGreaterThan) != (*other.ConditionalNumGoroutinesGreaterThan) { return false }
	}
	if p.ConditionalNumGoroutinesLessThan != other.ConditionalNumGoroutinesLessThan {
		if p.ConditionalNumGoroutinesLessThan == nil || other.ConditionalNumGoroutinesLessThan == nil {
			return false
		}
		if (*p.ConditionalNumGoroutinesLessThan) != (*other.ConditionalNumGoroutinesLessThan) { return false }
	}
	if p.ConditionalIsOverloaded != other.ConditionalIsOverloaded {
		if p.ConditionalIsOverloaded == nil || other.ConditionalIsOverloaded == nil {
			return false
		}
		if (*p.ConditionalIsOverloaded) != (*other.ConditionalIsOverloaded) { return false }
	}
	return true
}

func (p *DebugProfileStartRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugProfileStartRequest(%+v)", *p)
}

func (p *DebugProfileStartRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugProfileStartRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugProfileStartRequest)(nil)

func (p *DebugProfileStartRequest) Validate() error {
	return nil
}

type DebugProfileStartResult_ struct {
}

func NewDebugProfileStartResult_() *DebugProfileStartResult_ {
	return &DebugProfileStartResult_{}
}

func (p *DebugProfileStartResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *DebugProfileStartResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugProfileStartResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugProfileStartResult_) Equals(other *DebugProfileStartResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *DebugProfileStartResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugProfileStartResult_(%+v)", *p)
}

func (p *DebugProfileStartResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugProfileStartResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugProfileStartResult_)(nil)

func (p *DebugProfileStartResult_) Validate() error {
	return nil
}

// Attributes:
//  - Name
// 
type DebugProfileStopRequest struct {
	Name string `thrift:"name,1,required" db:"name" json:"name"`
}

func NewDebugProfileStopRequest() *DebugProfileStopRequest {
	return &DebugProfileStopRequest{}
}



func (p *DebugProfileStopRequest) GetName() string {
	return p.Name
}

func (p *DebugProfileStopRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetName bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetName = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetName{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Name is not set"));
	}
	return nil
}

func (p *DebugProfileStopRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Name = v
	}
	return nil
}

func (p *DebugProfileStopRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugProfileStopRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugProfileStopRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "name", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:name: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Name)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.name (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:name: ", p), err)
	}
	return err
}

func (p *DebugProfileStopRequest) Equals(other *DebugProfileStopRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Name != other.Name { return false }
	return true
}

func (p *DebugProfileStopRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugProfileStopRequest(%+v)", *p)
}

func (p *DebugProfileStopRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugProfileStopRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugProfileStopRequest)(nil)

func (p *DebugProfileStopRequest) Validate() error {
	return nil
}

type DebugProfileStopResult_ struct {
}

func NewDebugProfileStopResult_() *DebugProfileStopResult_ {
	return &DebugProfileStopResult_{}
}

func (p *DebugProfileStopResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *DebugProfileStopResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugProfileStopResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugProfileStopResult_) Equals(other *DebugProfileStopResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *DebugProfileStopResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugProfileStopResult_(%+v)", *p)
}

func (p *DebugProfileStopResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugProfileStopResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugProfileStopResult_)(nil)

func (p *DebugProfileStopResult_) Validate() error {
	return nil
}

// Attributes:
//  - Directory
// 
type DebugIndexMemorySegmentsRequest struct {
	Directory string `thrift:"directory,1,required" db:"directory" json:"directory"`
}

func NewDebugIndexMemorySegmentsRequest() *DebugIndexMemorySegmentsRequest {
	return &DebugIndexMemorySegmentsRequest{}
}



func (p *DebugIndexMemorySegmentsRequest) GetDirectory() string {
	return p.Directory
}

func (p *DebugIndexMemorySegmentsRequest) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	var issetDirectory bool = false;

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRING {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
				issetDirectory = true
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	if !issetDirectory{
		return thrift.NewTProtocolExceptionWithType(thrift.INVALID_DATA, fmt.Errorf("Required field Directory is not set"));
	}
	return nil
}

func (p *DebugIndexMemorySegmentsRequest) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(ctx); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Directory = v
	}
	return nil
}

func (p *DebugIndexMemorySegmentsRequest) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugIndexMemorySegmentsRequest"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugIndexMemorySegmentsRequest) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "directory", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:directory: ", p), err)
	}
	if err := oprot.WriteString(ctx, string(p.Directory)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.directory (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:directory: ", p), err)
	}
	return err
}

func (p *DebugIndexMemorySegmentsRequest) Equals(other *DebugIndexMemorySegmentsRequest) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	if p.Directory != other.Directory { return false }
	return true
}

func (p *DebugIndexMemorySegmentsRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugIndexMemorySegmentsRequest(%+v)", *p)
}

func (p *DebugIndexMemorySegmentsRequest) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugIndexMemorySegmentsRequest",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugIndexMemorySegmentsRequest)(nil)

func (p *DebugIndexMemorySegmentsRequest) Validate() error {
	return nil
}

type DebugIndexMemorySegmentsResult_ struct {
}

func NewDebugIndexMemorySegmentsResult_() *DebugIndexMemorySegmentsResult_ {
	return &DebugIndexMemorySegmentsResult_{}
}

func (p *DebugIndexMemorySegmentsResult_) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *DebugIndexMemorySegmentsResult_) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "DebugIndexMemorySegmentsResult"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *DebugIndexMemorySegmentsResult_) Equals(other *DebugIndexMemorySegmentsResult_) bool {
	if p == other {
		return true
	} else if p == nil || other == nil {
		return false
	}
	return true
}

func (p *DebugIndexMemorySegmentsResult_) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DebugIndexMemorySegmentsResult_(%+v)", *p)
}

func (p *DebugIndexMemorySegmentsResult_) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.DebugIndexMemorySegmentsResult_",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*DebugIndexMemorySegmentsResult_)(nil)

func (p *DebugIndexMemorySegmentsResult_) Validate() error {
	return nil
}

type Node interface {
	// Parameters:
	//  - Req
	// 
	Query(ctx context.Context, req *QueryRequest) (_r *QueryResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Aggregate(ctx context.Context, req *AggregateQueryRequest) (_r *AggregateQueryResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Fetch(ctx context.Context, req *FetchRequest) (_r *FetchResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Write(ctx context.Context, req *WriteRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	WriteTagged(ctx context.Context, req *WriteTaggedRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	AggregateRaw(ctx context.Context, req *AggregateQueryRawRequest) (_r *AggregateQueryRawResult_, _err error)
	// Parameters:
	//  - Req
	// 
	FetchBatchRaw(ctx context.Context, req *FetchBatchRawRequest) (_r *FetchBatchRawResult_, _err error)
	// Parameters:
	//  - Req
	// 
	FetchBatchRawV2(ctx context.Context, req *FetchBatchRawV2Request) (_r *FetchBatchRawResult_, _err error)
	// Parameters:
	//  - Req
	// 
	FetchBlocksRaw(ctx context.Context, req *FetchBlocksRawRequest) (_r *FetchBlocksRawResult_, _err error)
	// Parameters:
	//  - Req
	// 
	FetchTagged(ctx context.Context, req *FetchTaggedRequest) (_r *FetchTaggedResult_, _err error)
	// Parameters:
	//  - Req
	// 
	FetchBlocksMetadataRawV2(ctx context.Context, req *FetchBlocksMetadataRawV2Request) (_r *FetchBlocksMetadataRawV2Result_, _err error)
	// Parameters:
	//  - Req
	// 
	WriteBatchRaw(ctx context.Context, req *WriteBatchRawRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	WriteBatchRawV2(ctx context.Context, req *WriteBatchRawV2Request) (_err error)
	// Parameters:
	//  - Req
	// 
	WriteTaggedBatchRaw(ctx context.Context, req *WriteTaggedBatchRawRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	WriteTaggedBatchRawV2(ctx context.Context, req *WriteTaggedBatchRawV2Request) (_err error)
	Repair(ctx context.Context) (_err error)
	// Parameters:
	//  - Req
	// 
	Truncate(ctx context.Context, req *TruncateRequest) (_r *TruncateResult_, _err error)
	// Parameters:
	//  - Req
	// 
	AggregateTiles(ctx context.Context, req *AggregateTilesRequest) (_r *AggregateTilesResult_, _err error)
	Health(ctx context.Context) (_r *NodeHealthResult_, _err error)
	Bootstrapped(ctx context.Context) (_r *NodeBootstrappedResult_, _err error)
	BootstrappedInPlacementOrNoPlacement(ctx context.Context) (_r *NodeBootstrappedInPlacementOrNoPlacementResult_, _err error)
	GetPersistRateLimit(ctx context.Context) (_r *NodePersistRateLimitResult_, _err error)
	// Parameters:
	//  - Req
	// 
	SetPersistRateLimit(ctx context.Context, req *NodeSetPersistRateLimitRequest) (_r *NodePersistRateLimitResult_, _err error)
	GetWriteNewSeriesAsync(ctx context.Context) (_r *NodeWriteNewSeriesAsyncResult_, _err error)
	// Parameters:
	//  - Req
	// 
	SetWriteNewSeriesAsync(ctx context.Context, req *NodeSetWriteNewSeriesAsyncRequest) (_r *NodeWriteNewSeriesAsyncResult_, _err error)
	GetWriteNewSeriesBackoffDuration(ctx context.Context) (_r *NodeWriteNewSeriesBackoffDurationResult_, _err error)
	// Parameters:
	//  - Req
	// 
	SetWriteNewSeriesBackoffDuration(ctx context.Context, req *NodeSetWriteNewSeriesBackoffDurationRequest) (_r *NodeWriteNewSeriesBackoffDurationResult_, _err error)
	GetWriteNewSeriesLimitPerShardPerSecond(ctx context.Context) (_r *NodeWriteNewSeriesLimitPerShardPerSecondResult_, _err error)
	// Parameters:
	//  - Req
	// 
	SetWriteNewSeriesLimitPerShardPerSecond(ctx context.Context, req *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) (_r *NodeWriteNewSeriesLimitPerShardPerSecondResult_, _err error)
	// Parameters:
	//  - Req
	// 
	DebugProfileStart(ctx context.Context, req *DebugProfileStartRequest) (_r *DebugProfileStartResult_, _err error)
	// Parameters:
	//  - Req
	// 
	DebugProfileStop(ctx context.Context, req *DebugProfileStopRequest) (_r *DebugProfileStopResult_, _err error)
	// Parameters:
	//  - Req
	// 
	DebugIndexMemorySegments(ctx context.Context, req *DebugIndexMemorySegmentsRequest) (_r *DebugIndexMemorySegmentsResult_, _err error)
}

type NodeClient struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewNodeClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *NodeClient {
	return &NodeClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewNodeClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *NodeClient {
	return &NodeClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewNodeClient(c thrift.TClient) *NodeClient {
	return &NodeClient{
		c: c,
	}
}

func (p *NodeClient) Client_() thrift.TClient {
	return p.c
}

func (p *NodeClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *NodeClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

// Parameters:
//  - Req
// 
func (p *NodeClient) Query(ctx context.Context, req *QueryRequest) (_r *QueryResult_, _err error) {
	var _args69 NodeQueryArgs
	_args69.Req = req
	var _result71 NodeQueryResult
	var _meta70 thrift.ResponseMeta
	_meta70, _err = p.Client_().Call(ctx, "query", &_args69, &_result71)
	p.SetLastResponseMeta_(_meta70)
	if _err != nil {
		return
	}
	switch {
	case _result71.Err!= nil:
		return _r, _result71.Err
	}

	return _result71.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) Aggregate(ctx context.Context, req *AggregateQueryRequest) (_r *AggregateQueryResult_, _err error) {
	var _args72 NodeAggregateArgs
	_args72.Req = req
	var _result74 NodeAggregateResult
	var _meta73 thrift.ResponseMeta
	_meta73, _err = p.Client_().Call(ctx, "aggregate", &_args72, &_result74)
	p.SetLastResponseMeta_(_meta73)
	if _err != nil {
		return
	}
	switch {
	case _result74.Err!= nil:
		return _r, _result74.Err
	}

	return _result74.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) Fetch(ctx context.Context, req *FetchRequest) (_r *FetchResult_, _err error) {
	var _args75 NodeFetchArgs
	_args75.Req = req
	var _result77 NodeFetchResult
	var _meta76 thrift.ResponseMeta
	_meta76, _err = p.Client_().Call(ctx, "fetch", &_args75, &_result77)
	p.SetLastResponseMeta_(_meta76)
	if _err != nil {
		return
	}
	switch {
	case _result77.Err!= nil:
		return _r, _result77.Err
	}

	return _result77.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) Write(ctx context.Context, req *WriteRequest) (_err error) {
	var _args78 NodeWriteArgs
	_args78.Req = req
	var _result80 NodeWriteResult
	var _meta79 thrift.ResponseMeta
	_meta79, _err = p.Client_().Call(ctx, "write", &_args78, &_result80)
	p.SetLastResponseMeta_(_meta79)
	if _err != nil {
		return
	}
	switch {
	case _result80.Err!= nil:
		return _result80.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) WriteTagged(ctx context.Context, req *WriteTaggedRequest) (_err error) {
	var _args81 NodeWriteTaggedArgs
	_args81.Req = req
	var _result83 NodeWriteTaggedResult
	var _meta82 thrift.ResponseMeta
	_meta82, _err = p.Client_().Call(ctx, "writeTagged", &_args81, &_result83)
	p.SetLastResponseMeta_(_meta82)
	if _err != nil {
		return
	}
	switch {
	case _result83.Err!= nil:
		return _result83.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) AggregateRaw(ctx context.Context, req *AggregateQueryRawRequest) (_r *AggregateQueryRawResult_, _err error) {
	var _args84 NodeAggregateRawArgs
	_args84.Req = req
	var _result86 NodeAggregateRawResult
	var _meta85 thrift.ResponseMeta
	_meta85, _err = p.Client_().Call(ctx, "aggregateRaw", &_args84, &_result86)
	p.SetLastResponseMeta_(_meta85)
	if _err != nil {
		return
	}
	switch {
	case _result86.Err!= nil:
		return _r, _result86.Err
	}

	return _result86.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) FetchBatchRaw(ctx context.Context, req *FetchBatchRawRequest) (_r *FetchBatchRawResult_, _err error) {
	var _args87 NodeFetchBatchRawArgs
	_args87.Req = req
	var _result89 NodeFetchBatchRawResult
	var _meta88 thrift.ResponseMeta
	_meta88, _err = p.Client_().Call(ctx, "fetchBatchRaw", &_args87, &_result89)
	p.SetLastResponseMeta_(_meta88)
	if _err != nil {
		return
	}
	switch {
	case _result89.Err!= nil:
		return _r, _result89.Err
	}

	return _result89.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) FetchBatchRawV2(ctx context.Context, req *FetchBatchRawV2Request) (_r *FetchBatchRawResult_, _err error) {
	var _args90 NodeFetchBatchRawV2Args
	_args90.Req = req
	var _result92 NodeFetchBatchRawV2Result
	var _meta91 thrift.ResponseMeta
	_meta91, _err = p.Client_().Call(ctx, "fetchBatchRawV2", &_args90, &_result92)
	p.SetLastResponseMeta_(_meta91)
	if _err != nil {
		return
	}
	switch {
	case _result92.Err!= nil:
		return _r, _result92.Err
	}

	return _result92.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) FetchBlocksRaw(ctx context.Context, req *FetchBlocksRawRequest) (_r *FetchBlocksRawResult_, _err error) {
	var _args93 NodeFetchBlocksRawArgs
	_args93.Req = req
	var _result95 NodeFetchBlocksRawResult
	var _meta94 thrift.ResponseMeta
	_meta94, _err = p.Client_().Call(ctx, "fetchBlocksRaw", &_args93, &_result95)
	p.SetLastResponseMeta_(_meta94)
	if _err != nil {
		return
	}
	switch {
	case _result95.Err!= nil:
		return _r, _result95.Err
	}

	return _result95.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) FetchTagged(ctx context.Context, req *FetchTaggedRequest) (_r *FetchTaggedResult_, _err error) {
	var _args96 NodeFetchTaggedArgs
	_args96.Req = req
	var _result98 NodeFetchTaggedResult
	var _meta97 thrift.ResponseMeta
	_meta97, _err = p.Client_().Call(ctx, "fetchTagged", &_args96, &_result98)
	p.SetLastResponseMeta_(_meta97)
	if _err != nil {
		return
	}
	switch {
	case _result98.Err!= nil:
		return _r, _result98.Err
	}

	return _result98.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) FetchBlocksMetadataRawV2(ctx context.Context, req *FetchBlocksMetadataRawV2Request) (_r *FetchBlocksMetadataRawV2Result_, _err error) {
	var _args99 NodeFetchBlocksMetadataRawV2Args
	_args99.Req = req
	var _result101 NodeFetchBlocksMetadataRawV2Result
	var _meta100 thrift.ResponseMeta
	_meta100, _err = p.Client_().Call(ctx, "fetchBlocksMetadataRawV2", &_args99, &_result101)
	p.SetLastResponseMeta_(_meta100)
	if _err != nil {
		return
	}
	switch {
	case _result101.Err!= nil:
		return _r, _result101.Err
	}

	return _result101.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) WriteBatchRaw(ctx context.Context, req *WriteBatchRawRequest) (_err error) {
	var _args102 NodeWriteBatchRawArgs
	_args102.Req = req
	var _result104 NodeWriteBatchRawResult
	var _meta103 thrift.ResponseMeta
	_meta103, _err = p.Client_().Call(ctx, "writeBatchRaw", &_args102, &_result104)
	p.SetLastResponseMeta_(_meta103)
	if _err != nil {
		return
	}
	switch {
	case _result104.Err!= nil:
		return _result104.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) WriteBatchRawV2(ctx context.Context, req *WriteBatchRawV2Request) (_err error) {
	var _args105 NodeWriteBatchRawV2Args
	_args105.Req = req
	var _result107 NodeWriteBatchRawV2Result
	var _meta106 thrift.ResponseMeta
	_meta106, _err = p.Client_().Call(ctx, "writeBatchRawV2", &_args105, &_result107)
	p.SetLastResponseMeta_(_meta106)
	if _err != nil {
		return
	}
	switch {
	case _result107.Err!= nil:
		return _result107.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) WriteTaggedBatchRaw(ctx context.Context, req *WriteTaggedBatchRawRequest) (_err error) {
	var _args108 NodeWriteTaggedBatchRawArgs
	_args108.Req = req
	var _result110 NodeWriteTaggedBatchRawResult
	var _meta109 thrift.ResponseMeta
	_meta109, _err = p.Client_().Call(ctx, "writeTaggedBatchRaw", &_args108, &_result110)
	p.SetLastResponseMeta_(_meta109)
	if _err != nil {
		return
	}
	switch {
	case _result110.Err!= nil:
		return _result110.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) WriteTaggedBatchRawV2(ctx context.Context, req *WriteTaggedBatchRawV2Request) (_err error) {
	var _args111 NodeWriteTaggedBatchRawV2Args
	_args111.Req = req
	var _result113 NodeWriteTaggedBatchRawV2Result
	var _meta112 thrift.ResponseMeta
	_meta112, _err = p.Client_().Call(ctx, "writeTaggedBatchRawV2", &_args111, &_result113)
	p.SetLastResponseMeta_(_meta112)
	if _err != nil {
		return
	}
	switch {
	case _result113.Err!= nil:
		return _result113.Err
	}

	return nil
}

func (p *NodeClient) Repair(ctx context.Context) (_err error) {
	var _args114 NodeRepairArgs
	var _result116 NodeRepairResult
	var _meta115 thrift.ResponseMeta
	_meta115, _err = p.Client_().Call(ctx, "repair", &_args114, &_result116)
	p.SetLastResponseMeta_(_meta115)
	if _err != nil {
		return
	}
	switch {
	case _result116.Err!= nil:
		return _result116.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) Truncate(ctx context.Context, req *TruncateRequest) (_r *TruncateResult_, _err error) {
	var _args117 NodeTruncateArgs
	_args117.Req = req
	var _result119 NodeTruncateResult
	var _meta118 thrift.ResponseMeta
	_meta118, _err = p.Client_().Call(ctx, "truncate", &_args117, &_result119)
	p.SetLastResponseMeta_(_meta118)
	if _err != nil {
		return
	}
	switch {
	case _result119.Err!= nil:
		return _r, _result119.Err
	}

	return _result119.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) AggregateTiles(ctx context.Context, req *AggregateTilesRequest) (_r *AggregateTilesResult_, _err error) {
	var _args120 NodeAggregateTilesArgs
	_args120.Req = req
	var _result122 NodeAggregateTilesResult
	var _meta121 thrift.ResponseMeta
	_meta121, _err = p.Client_().Call(ctx, "aggregateTiles", &_args120, &_result122)
	p.SetLastResponseMeta_(_meta121)
	if _err != nil {
		return
	}
	switch {
	case _result122.Err!= nil:
		return _r, _result122.Err
	}

	return _result122.GetSuccess(), nil
}

func (p *NodeClient) Health(ctx context.Context) (_r *NodeHealthResult_, _err error) {
	var _args123 NodeHealthArgs
	var _result125 NodeHealthResult
	var _meta124 thrift.ResponseMeta
	_meta124, _err = p.Client_().Call(ctx, "health", &_args123, &_result125)
	p.SetLastResponseMeta_(_meta124)
	if _err != nil {
		return
	}
	switch {
	case _result125.Err!= nil:
		return _r, _result125.Err
	}

	return _result125.GetSuccess(), nil
}

func (p *NodeClient) Bootstrapped(ctx context.Context) (_r *NodeBootstrappedResult_, _err error) {
	var _args126 NodeBootstrappedArgs
	var _result128 NodeBootstrappedResult
	var _meta127 thrift.ResponseMeta
	_meta127, _err = p.Client_().Call(ctx, "bootstrapped", &_args126, &_result128)
	p.SetLastResponseMeta_(_meta127)
	if _err != nil {
		return
	}
	switch {
	case _result128.Err!= nil:
		return _r, _result128.Err
	}

	return _result128.GetSuccess(), nil
}

func (p *NodeClient) BootstrappedInPlacementOrNoPlacement(ctx context.Context) (_r *NodeBootstrappedInPlacementOrNoPlacementResult_, _err error) {
	var _args129 NodeBootstrappedInPlacementOrNoPlacementArgs
	var _result131 NodeBootstrappedInPlacementOrNoPlacementResult
	var _meta130 thrift.ResponseMeta
	_meta130, _err = p.Client_().Call(ctx, "bootstrappedInPlacementOrNoPlacement", &_args129, &_result131)
	p.SetLastResponseMeta_(_meta130)
	if _err != nil {
		return
	}
	switch {
	case _result131.Err!= nil:
		return _r, _result131.Err
	}

	return _result131.GetSuccess(), nil
}

func (p *NodeClient) GetPersistRateLimit(ctx context.Context) (_r *NodePersistRateLimitResult_, _err error) {
	var _args132 NodeGetPersistRateLimitArgs
	var _result134 NodeGetPersistRateLimitResult
	var _meta133 thrift.ResponseMeta
	_meta133, _err = p.Client_().Call(ctx, "getPersistRateLimit", &_args132, &_result134)
	p.SetLastResponseMeta_(_meta133)
	if _err != nil {
		return
	}
	switch {
	case _result134.Err!= nil:
		return _r, _result134.Err
	}

	return _result134.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) SetPersistRateLimit(ctx context.Context, req *NodeSetPersistRateLimitRequest) (_r *NodePersistRateLimitResult_, _err error) {
	var _args135 NodeSetPersistRateLimitArgs
	_args135.Req = req
	var _result137 NodeSetPersistRateLimitResult
	var _meta136 thrift.ResponseMeta
	_meta136, _err = p.Client_().Call(ctx, "setPersistRateLimit", &_args135, &_result137)
	p.SetLastResponseMeta_(_meta136)
	if _err != nil {
		return
	}
	switch {
	case _result137.Err!= nil:
		return _r, _result137.Err
	}

	return _result137.GetSuccess(), nil
}

func (p *NodeClient) GetWriteNewSeriesAsync(ctx context.Context) (_r *NodeWriteNewSeriesAsyncResult_, _err error) {
	var _args138 NodeGetWriteNewSeriesAsyncArgs
	var _result140 NodeGetWriteNewSeriesAsyncResult
	var _meta139 thrift.ResponseMeta
	_meta139, _err = p.Client_().Call(ctx, "getWriteNewSeriesAsync", &_args138, &_result140)
	p.SetLastResponseMeta_(_meta139)
	if _err != nil {
		return
	}
	switch {
	case _result140.Err!= nil:
		return _r, _result140.Err
	}

	return _result140.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) SetWriteNewSeriesAsync(ctx context.Context, req *NodeSetWriteNewSeriesAsyncRequest) (_r *NodeWriteNewSeriesAsyncResult_, _err error) {
	var _args141 NodeSetWriteNewSeriesAsyncArgs
	_args141.Req = req
	var _result143 NodeSetWriteNewSeriesAsyncResult
	var _meta142 thrift.ResponseMeta
	_meta142, _err = p.Client_().Call(ctx, "setWriteNewSeriesAsync", &_args141, &_result143)
	p.SetLastResponseMeta_(_meta142)
	if _err != nil {
		return
	}
	switch {
	case _result143.Err!= nil:
		return _r, _result143.Err
	}

	return _result143.GetSuccess(), nil
}

func (p *NodeClient) GetWriteNewSeriesBackoffDuration(ctx context.Context) (_r *NodeWriteNewSeriesBackoffDurationResult_, _err error) {
	var _args144 NodeGetWriteNewSeriesBackoffDurationArgs
	var _result146 NodeGetWriteNewSeriesBackoffDurationResult
	var _meta145 thrift.ResponseMeta
	_meta145, _err = p.Client_().Call(ctx, "getWriteNewSeriesBackoffDuration", &_args144, &_result146)
	p.SetLastResponseMeta_(_meta145)
	if _err != nil {
		return
	}
	switch {
	case _result146.Err!= nil:
		return _r, _result146.Err
	}

	return _result146.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) SetWriteNewSeriesBackoffDuration(ctx context.Context, req *NodeSetWriteNewSeriesBackoffDurationRequest) (_r *NodeWriteNewSeriesBackoffDurationResult_, _err error) {
	var _args147 NodeSetWriteNewSeriesBackoffDurationArgs
	_args147.Req = req
	var _result149 NodeSetWriteNewSeriesBackoffDurationResult
	var _meta148 thrift.ResponseMeta
	_meta148, _err = p.Client_().Call(ctx, "setWriteNewSeriesBackoffDuration", &_args147, &_result149)
	p.SetLastResponseMeta_(_meta148)
	if _err != nil {
		return
	}
	switch {
	case _result149.Err!= nil:
		return _r, _result149.Err
	}

	return _result149.GetSuccess(), nil
}

func (p *NodeClient) GetWriteNewSeriesLimitPerShardPerSecond(ctx context.Context) (_r *NodeWriteNewSeriesLimitPerShardPerSecondResult_, _err error) {
	var _args150 NodeGetWriteNewSeriesLimitPerShardPerSecondArgs
	var _result152 NodeGetWriteNewSeriesLimitPerShardPerSecondResult
	var _meta151 thrift.ResponseMeta
	_meta151, _err = p.Client_().Call(ctx, "getWriteNewSeriesLimitPerShardPerSecond", &_args150, &_result152)
	p.SetLastResponseMeta_(_meta151)
	if _err != nil {
		return
	}
	switch {
	case _result152.Err!= nil:
		return _r, _result152.Err
	}

	return _result152.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) SetWriteNewSeriesLimitPerShardPerSecond(ctx context.Context, req *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest) (_r *NodeWriteNewSeriesLimitPerShardPerSecondResult_, _err error) {
	var _args153 NodeSetWriteNewSeriesLimitPerShardPerSecondArgs
	_args153.Req = req
	var _result155 NodeSetWriteNewSeriesLimitPerShardPerSecondResult
	var _meta154 thrift.ResponseMeta
	_meta154, _err = p.Client_().Call(ctx, "setWriteNewSeriesLimitPerShardPerSecond", &_args153, &_result155)
	p.SetLastResponseMeta_(_meta154)
	if _err != nil {
		return
	}
	switch {
	case _result155.Err!= nil:
		return _r, _result155.Err
	}

	return _result155.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) DebugProfileStart(ctx context.Context, req *DebugProfileStartRequest) (_r *DebugProfileStartResult_, _err error) {
	var _args156 NodeDebugProfileStartArgs
	_args156.Req = req
	var _result158 NodeDebugProfileStartResult
	var _meta157 thrift.ResponseMeta
	_meta157, _err = p.Client_().Call(ctx, "debugProfileStart", &_args156, &_result158)
	p.SetLastResponseMeta_(_meta157)
	if _err != nil {
		return
	}
	switch {
	case _result158.Err!= nil:
		return _r, _result158.Err
	}

	return _result158.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) DebugProfileStop(ctx context.Context, req *DebugProfileStopRequest) (_r *DebugProfileStopResult_, _err error) {
	var _args159 NodeDebugProfileStopArgs
	_args159.Req = req
	var _result161 NodeDebugProfileStopResult
	var _meta160 thrift.ResponseMeta
	_meta160, _err = p.Client_().Call(ctx, "debugProfileStop", &_args159, &_result161)
	p.SetLastResponseMeta_(_meta160)
	if _err != nil {
		return
	}
	switch {
	case _result161.Err!= nil:
		return _r, _result161.Err
	}

	return _result161.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *NodeClient) DebugIndexMemorySegments(ctx context.Context, req *DebugIndexMemorySegmentsRequest) (_r *DebugIndexMemorySegmentsResult_, _err error) {
	var _args162 NodeDebugIndexMemorySegmentsArgs
	_args162.Req = req
	var _result164 NodeDebugIndexMemorySegmentsResult
	var _meta163 thrift.ResponseMeta
	_meta163, _err = p.Client_().Call(ctx, "debugIndexMemorySegments", &_args162, &_result164)
	p.SetLastResponseMeta_(_meta163)
	if _err != nil {
		return
	}
	switch {
	case _result164.Err!= nil:
		return _r, _result164.Err
	}

	return _result164.GetSuccess(), nil
}

type NodeProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler Node
}

func (p *NodeProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *NodeProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *NodeProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewNodeProcessor(handler Node) *NodeProcessor {

	self165 := &NodeProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self165.processorMap["query"] = &nodeProcessorQuery{handler:handler}
	self165.processorMap["aggregate"] = &nodeProcessorAggregate{handler:handler}
	self165.processorMap["fetch"] = &nodeProcessorFetch{handler:handler}
	self165.processorMap["write"] = &nodeProcessorWrite{handler:handler}
	self165.processorMap["writeTagged"] = &nodeProcessorWriteTagged{handler:handler}
	self165.processorMap["aggregateRaw"] = &nodeProcessorAggregateRaw{handler:handler}
	self165.processorMap["fetchBatchRaw"] = &nodeProcessorFetchBatchRaw{handler:handler}
	self165.processorMap["fetchBatchRawV2"] = &nodeProcessorFetchBatchRawV2{handler:handler}
	self165.processorMap["fetchBlocksRaw"] = &nodeProcessorFetchBlocksRaw{handler:handler}
	self165.processorMap["fetchTagged"] = &nodeProcessorFetchTagged{handler:handler}
	self165.processorMap["fetchBlocksMetadataRawV2"] = &nodeProcessorFetchBlocksMetadataRawV2{handler:handler}
	self165.processorMap["writeBatchRaw"] = &nodeProcessorWriteBatchRaw{handler:handler}
	self165.processorMap["writeBatchRawV2"] = &nodeProcessorWriteBatchRawV2{handler:handler}
	self165.processorMap["writeTaggedBatchRaw"] = &nodeProcessorWriteTaggedBatchRaw{handler:handler}
	self165.processorMap["writeTaggedBatchRawV2"] = &nodeProcessorWriteTaggedBatchRawV2{handler:handler}
	self165.processorMap["repair"] = &nodeProcessorRepair{handler:handler}
	self165.processorMap["truncate"] = &nodeProcessorTruncate{handler:handler}
	self165.processorMap["aggregateTiles"] = &nodeProcessorAggregateTiles{handler:handler}
	self165.processorMap["health"] = &nodeProcessorHealth{handler:handler}
	self165.processorMap["bootstrapped"] = &nodeProcessorBootstrapped{handler:handler}
	self165.processorMap["bootstrappedInPlacementOrNoPlacement"] = &nodeProcessorBootstrappedInPlacementOrNoPlacement{handler:handler}
	self165.processorMap["getPersistRateLimit"] = &nodeProcessorGetPersistRateLimit{handler:handler}
	self165.processorMap["setPersistRateLimit"] = &nodeProcessorSetPersistRateLimit{handler:handler}
	self165.processorMap["getWriteNewSeriesAsync"] = &nodeProcessorGetWriteNewSeriesAsync{handler:handler}
	self165.processorMap["setWriteNewSeriesAsync"] = &nodeProcessorSetWriteNewSeriesAsync{handler:handler}
	self165.processorMap["getWriteNewSeriesBackoffDuration"] = &nodeProcessorGetWriteNewSeriesBackoffDuration{handler:handler}
	self165.processorMap["setWriteNewSeriesBackoffDuration"] = &nodeProcessorSetWriteNewSeriesBackoffDuration{handler:handler}
	self165.processorMap["getWriteNewSeriesLimitPerShardPerSecond"] = &nodeProcessorGetWriteNewSeriesLimitPerShardPerSecond{handler:handler}
	self165.processorMap["setWriteNewSeriesLimitPerShardPerSecond"] = &nodeProcessorSetWriteNewSeriesLimitPerShardPerSecond{handler:handler}
	self165.processorMap["debugProfileStart"] = &nodeProcessorDebugProfileStart{handler:handler}
	self165.processorMap["debugProfileStop"] = &nodeProcessorDebugProfileStop{handler:handler}
	self165.processorMap["debugIndexMemorySegments"] = &nodeProcessorDebugIndexMemorySegments{handler:handler}
	return self165
}

func (p *NodeProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x166 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x166.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x166
}

type nodeProcessorQuery struct {
	handler Node
}

func (p *nodeProcessorQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err167 error
	args := NodeQueryArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "query", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeQueryResult{}
	if retval, err2 := p.handler.Query(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc168 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing query: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "query", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err167 = thrift.WrapTException(err2)
			}
			if err2 := _exc168.Write(ctx, oprot); _write_err167 == nil && err2 != nil {
				_write_err167 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err167 == nil && err2 != nil {
				_write_err167 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err167 == nil && err2 != nil {
				_write_err167 = thrift.WrapTException(err2)
			}
			if _write_err167 != nil {
				return false, thrift.WrapTException(_write_err167)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "query", thrift.REPLY, seqId); err2 != nil {
		_write_err167 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err167 == nil && err2 != nil {
		_write_err167 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err167 == nil && err2 != nil {
		_write_err167 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err167 == nil && err2 != nil {
		_write_err167 = thrift.WrapTException(err2)
	}
	if _write_err167 != nil {
		return false, thrift.WrapTException(_write_err167)
	}
	return true, err
}

type nodeProcessorAggregate struct {
	handler Node
}

func (p *nodeProcessorAggregate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err169 error
	args := NodeAggregateArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "aggregate", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeAggregateResult{}
	if retval, err2 := p.handler.Aggregate(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc170 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregate: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "aggregate", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err169 = thrift.WrapTException(err2)
			}
			if err2 := _exc170.Write(ctx, oprot); _write_err169 == nil && err2 != nil {
				_write_err169 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err169 == nil && err2 != nil {
				_write_err169 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err169 == nil && err2 != nil {
				_write_err169 = thrift.WrapTException(err2)
			}
			if _write_err169 != nil {
				return false, thrift.WrapTException(_write_err169)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "aggregate", thrift.REPLY, seqId); err2 != nil {
		_write_err169 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err169 == nil && err2 != nil {
		_write_err169 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err169 == nil && err2 != nil {
		_write_err169 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err169 == nil && err2 != nil {
		_write_err169 = thrift.WrapTException(err2)
	}
	if _write_err169 != nil {
		return false, thrift.WrapTException(_write_err169)
	}
	return true, err
}

type nodeProcessorFetch struct {
	handler Node
}

func (p *nodeProcessorFetch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err171 error
	args := NodeFetchArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchResult{}
	if retval, err2 := p.handler.Fetch(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc172 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetch: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetch", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err171 = thrift.WrapTException(err2)
			}
			if err2 := _exc172.Write(ctx, oprot); _write_err171 == nil && err2 != nil {
				_write_err171 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err171 == nil && err2 != nil {
				_write_err171 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err171 == nil && err2 != nil {
				_write_err171 = thrift.WrapTException(err2)
			}
			if _write_err171 != nil {
				return false, thrift.WrapTException(_write_err171)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetch", thrift.REPLY, seqId); err2 != nil {
		_write_err171 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err171 == nil && err2 != nil {
		_write_err171 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err171 == nil && err2 != nil {
		_write_err171 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err171 == nil && err2 != nil {
		_write_err171 = thrift.WrapTException(err2)
	}
	if _write_err171 != nil {
		return false, thrift.WrapTException(_write_err171)
	}
	return true, err
}

type nodeProcessorWrite struct {
	handler Node
}

func (p *nodeProcessorWrite) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err173 error
	args := NodeWriteArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "write", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteResult{}
	if err2 := p.handler.Write(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc174 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing write: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "write", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err173 = thrift.WrapTException(err2)
			}
			if err2 := _exc174.Write(ctx, oprot); _write_err173 == nil && err2 != nil {
				_write_err173 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err173 == nil && err2 != nil {
				_write_err173 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err173 == nil && err2 != nil {
				_write_err173 = thrift.WrapTException(err2)
			}
			if _write_err173 != nil {
				return false, thrift.WrapTException(_write_err173)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "write", thrift.REPLY, seqId); err2 != nil {
		_write_err173 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err173 == nil && err2 != nil {
		_write_err173 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err173 == nil && err2 != nil {
		_write_err173 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err173 == nil && err2 != nil {
		_write_err173 = thrift.WrapTException(err2)
	}
	if _write_err173 != nil {
		return false, thrift.WrapTException(_write_err173)
	}
	return true, err
}

type nodeProcessorWriteTagged struct {
	handler Node
}

func (p *nodeProcessorWriteTagged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err175 error
	args := NodeWriteTaggedArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeTagged", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteTaggedResult{}
	if err2 := p.handler.WriteTagged(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc176 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeTagged: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeTagged", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err175 = thrift.WrapTException(err2)
			}
			if err2 := _exc176.Write(ctx, oprot); _write_err175 == nil && err2 != nil {
				_write_err175 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err175 == nil && err2 != nil {
				_write_err175 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err175 == nil && err2 != nil {
				_write_err175 = thrift.WrapTException(err2)
			}
			if _write_err175 != nil {
				return false, thrift.WrapTException(_write_err175)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeTagged", thrift.REPLY, seqId); err2 != nil {
		_write_err175 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err175 == nil && err2 != nil {
		_write_err175 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err175 == nil && err2 != nil {
		_write_err175 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err175 == nil && err2 != nil {
		_write_err175 = thrift.WrapTException(err2)
	}
	if _write_err175 != nil {
		return false, thrift.WrapTException(_write_err175)
	}
	return true, err
}

type nodeProcessorAggregateRaw struct {
	handler Node
}

func (p *nodeProcessorAggregateRaw) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err177 error
	args := NodeAggregateRawArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "aggregateRaw", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeAggregateRawResult{}
	if retval, err2 := p.handler.AggregateRaw(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc178 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregateRaw: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "aggregateRaw", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err177 = thrift.WrapTException(err2)
			}
			if err2 := _exc178.Write(ctx, oprot); _write_err177 == nil && err2 != nil {
				_write_err177 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err177 == nil && err2 != nil {
				_write_err177 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err177 == nil && err2 != nil {
				_write_err177 = thrift.WrapTException(err2)
			}
			if _write_err177 != nil {
				return false, thrift.WrapTException(_write_err177)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "aggregateRaw", thrift.REPLY, seqId); err2 != nil {
		_write_err177 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err177 == nil && err2 != nil {
		_write_err177 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err177 == nil && err2 != nil {
		_write_err177 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err177 == nil && err2 != nil {
		_write_err177 = thrift.WrapTException(err2)
	}
	if _write_err177 != nil {
		return false, thrift.WrapTException(_write_err177)
	}
	return true, err
}

type nodeProcessorFetchBatchRaw struct {
	handler Node
}

func (p *nodeProcessorFetchBatchRaw) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err179 error
	args := NodeFetchBatchRawArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetchBatchRaw", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchBatchRawResult{}
	if retval, err2 := p.handler.FetchBatchRaw(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc180 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchBatchRaw: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetchBatchRaw", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err179 = thrift.WrapTException(err2)
			}
			if err2 := _exc180.Write(ctx, oprot); _write_err179 == nil && err2 != nil {
				_write_err179 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err179 == nil && err2 != nil {
				_write_err179 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err179 == nil && err2 != nil {
				_write_err179 = thrift.WrapTException(err2)
			}
			if _write_err179 != nil {
				return false, thrift.WrapTException(_write_err179)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetchBatchRaw", thrift.REPLY, seqId); err2 != nil {
		_write_err179 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err179 == nil && err2 != nil {
		_write_err179 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err179 == nil && err2 != nil {
		_write_err179 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err179 == nil && err2 != nil {
		_write_err179 = thrift.WrapTException(err2)
	}
	if _write_err179 != nil {
		return false, thrift.WrapTException(_write_err179)
	}
	return true, err
}

type nodeProcessorFetchBatchRawV2 struct {
	handler Node
}

func (p *nodeProcessorFetchBatchRawV2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err181 error
	args := NodeFetchBatchRawV2Args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetchBatchRawV2", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchBatchRawV2Result{}
	if retval, err2 := p.handler.FetchBatchRawV2(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc182 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchBatchRawV2: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetchBatchRawV2", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err181 = thrift.WrapTException(err2)
			}
			if err2 := _exc182.Write(ctx, oprot); _write_err181 == nil && err2 != nil {
				_write_err181 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err181 == nil && err2 != nil {
				_write_err181 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err181 == nil && err2 != nil {
				_write_err181 = thrift.WrapTException(err2)
			}
			if _write_err181 != nil {
				return false, thrift.WrapTException(_write_err181)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetchBatchRawV2", thrift.REPLY, seqId); err2 != nil {
		_write_err181 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err181 == nil && err2 != nil {
		_write_err181 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err181 == nil && err2 != nil {
		_write_err181 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err181 == nil && err2 != nil {
		_write_err181 = thrift.WrapTException(err2)
	}
	if _write_err181 != nil {
		return false, thrift.WrapTException(_write_err181)
	}
	return true, err
}

type nodeProcessorFetchBlocksRaw struct {
	handler Node
}

func (p *nodeProcessorFetchBlocksRaw) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err183 error
	args := NodeFetchBlocksRawArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetchBlocksRaw", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchBlocksRawResult{}
	if retval, err2 := p.handler.FetchBlocksRaw(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc184 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchBlocksRaw: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetchBlocksRaw", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err183 = thrift.WrapTException(err2)
			}
			if err2 := _exc184.Write(ctx, oprot); _write_err183 == nil && err2 != nil {
				_write_err183 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err183 == nil && err2 != nil {
				_write_err183 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err183 == nil && err2 != nil {
				_write_err183 = thrift.WrapTException(err2)
			}
			if _write_err183 != nil {
				return false, thrift.WrapTException(_write_err183)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetchBlocksRaw", thrift.REPLY, seqId); err2 != nil {
		_write_err183 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err183 == nil && err2 != nil {
		_write_err183 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err183 == nil && err2 != nil {
		_write_err183 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err183 == nil && err2 != nil {
		_write_err183 = thrift.WrapTException(err2)
	}
	if _write_err183 != nil {
		return false, thrift.WrapTException(_write_err183)
	}
	return true, err
}

type nodeProcessorFetchTagged struct {
	handler Node
}

func (p *nodeProcessorFetchTagged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err185 error
	args := NodeFetchTaggedArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetchTagged", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchTaggedResult{}
	if retval, err2 := p.handler.FetchTagged(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc186 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchTagged: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetchTagged", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err185 = thrift.WrapTException(err2)
			}
			if err2 := _exc186.Write(ctx, oprot); _write_err185 == nil && err2 != nil {
				_write_err185 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err185 == nil && err2 != nil {
				_write_err185 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err185 == nil && err2 != nil {
				_write_err185 = thrift.WrapTException(err2)
			}
			if _write_err185 != nil {
				return false, thrift.WrapTException(_write_err185)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetchTagged", thrift.REPLY, seqId); err2 != nil {
		_write_err185 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err185 == nil && err2 != nil {
		_write_err185 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err185 == nil && err2 != nil {
		_write_err185 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err185 == nil && err2 != nil {
		_write_err185 = thrift.WrapTException(err2)
	}
	if _write_err185 != nil {
		return false, thrift.WrapTException(_write_err185)
	}
	return true, err
}

type nodeProcessorFetchBlocksMetadataRawV2 struct {
	handler Node
}

func (p *nodeProcessorFetchBlocksMetadataRawV2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err187 error
	args := NodeFetchBlocksMetadataRawV2Args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetchBlocksMetadataRawV2", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeFetchBlocksMetadataRawV2Result{}
	if retval, err2 := p.handler.FetchBlocksMetadataRawV2(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc188 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetchBlocksMetadataRawV2: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetchBlocksMetadataRawV2", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err187 = thrift.WrapTException(err2)
			}
			if err2 := _exc188.Write(ctx, oprot); _write_err187 == nil && err2 != nil {
				_write_err187 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err187 == nil && err2 != nil {
				_write_err187 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err187 == nil && err2 != nil {
				_write_err187 = thrift.WrapTException(err2)
			}
			if _write_err187 != nil {
				return false, thrift.WrapTException(_write_err187)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetchBlocksMetadataRawV2", thrift.REPLY, seqId); err2 != nil {
		_write_err187 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err187 == nil && err2 != nil {
		_write_err187 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err187 == nil && err2 != nil {
		_write_err187 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err187 == nil && err2 != nil {
		_write_err187 = thrift.WrapTException(err2)
	}
	if _write_err187 != nil {
		return false, thrift.WrapTException(_write_err187)
	}
	return true, err
}

type nodeProcessorWriteBatchRaw struct {
	handler Node
}

func (p *nodeProcessorWriteBatchRaw) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err189 error
	args := NodeWriteBatchRawArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeBatchRaw", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteBatchRawResult{}
	if err2 := p.handler.WriteBatchRaw(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *WriteBatchRawErrors:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc190 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeBatchRaw: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeBatchRaw", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err189 = thrift.WrapTException(err2)
			}
			if err2 := _exc190.Write(ctx, oprot); _write_err189 == nil && err2 != nil {
				_write_err189 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err189 == nil && err2 != nil {
				_write_err189 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err189 == nil && err2 != nil {
				_write_err189 = thrift.WrapTException(err2)
			}
			if _write_err189 != nil {
				return false, thrift.WrapTException(_write_err189)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeBatchRaw", thrift.REPLY, seqId); err2 != nil {
		_write_err189 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err189 == nil && err2 != nil {
		_write_err189 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err189 == nil && err2 != nil {
		_write_err189 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err189 == nil && err2 != nil {
		_write_err189 = thrift.WrapTException(err2)
	}
	if _write_err189 != nil {
		return false, thrift.WrapTException(_write_err189)
	}
	return true, err
}

type nodeProcessorWriteBatchRawV2 struct {
	handler Node
}

func (p *nodeProcessorWriteBatchRawV2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err191 error
	args := NodeWriteBatchRawV2Args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeBatchRawV2", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteBatchRawV2Result{}
	if err2 := p.handler.WriteBatchRawV2(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *WriteBatchRawErrors:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc192 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeBatchRawV2: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeBatchRawV2", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err191 = thrift.WrapTException(err2)
			}
			if err2 := _exc192.Write(ctx, oprot); _write_err191 == nil && err2 != nil {
				_write_err191 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err191 == nil && err2 != nil {
				_write_err191 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err191 == nil && err2 != nil {
				_write_err191 = thrift.WrapTException(err2)
			}
			if _write_err191 != nil {
				return false, thrift.WrapTException(_write_err191)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeBatchRawV2", thrift.REPLY, seqId); err2 != nil {
		_write_err191 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err191 == nil && err2 != nil {
		_write_err191 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err191 == nil && err2 != nil {
		_write_err191 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err191 == nil && err2 != nil {
		_write_err191 = thrift.WrapTException(err2)
	}
	if _write_err191 != nil {
		return false, thrift.WrapTException(_write_err191)
	}
	return true, err
}

type nodeProcessorWriteTaggedBatchRaw struct {
	handler Node
}

func (p *nodeProcessorWriteTaggedBatchRaw) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err193 error
	args := NodeWriteTaggedBatchRawArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeTaggedBatchRaw", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteTaggedBatchRawResult{}
	if err2 := p.handler.WriteTaggedBatchRaw(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *WriteBatchRawErrors:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc194 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeTaggedBatchRaw: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeTaggedBatchRaw", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err193 = thrift.WrapTException(err2)
			}
			if err2 := _exc194.Write(ctx, oprot); _write_err193 == nil && err2 != nil {
				_write_err193 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err193 == nil && err2 != nil {
				_write_err193 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err193 == nil && err2 != nil {
				_write_err193 = thrift.WrapTException(err2)
			}
			if _write_err193 != nil {
				return false, thrift.WrapTException(_write_err193)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeTaggedBatchRaw", thrift.REPLY, seqId); err2 != nil {
		_write_err193 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err193 == nil && err2 != nil {
		_write_err193 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err193 == nil && err2 != nil {
		_write_err193 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err193 == nil && err2 != nil {
		_write_err193 = thrift.WrapTException(err2)
	}
	if _write_err193 != nil {
		return false, thrift.WrapTException(_write_err193)
	}
	return true, err
}

type nodeProcessorWriteTaggedBatchRawV2 struct {
	handler Node
}

func (p *nodeProcessorWriteTaggedBatchRawV2) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err195 error
	args := NodeWriteTaggedBatchRawV2Args{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeTaggedBatchRawV2", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeWriteTaggedBatchRawV2Result{}
	if err2 := p.handler.WriteTaggedBatchRawV2(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *WriteBatchRawErrors:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc196 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeTaggedBatchRawV2: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeTaggedBatchRawV2", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err195 = thrift.WrapTException(err2)
			}
			if err2 := _exc196.Write(ctx, oprot); _write_err195 == nil && err2 != nil {
				_write_err195 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err195 == nil && err2 != nil {
				_write_err195 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err195 == nil && err2 != nil {
				_write_err195 = thrift.WrapTException(err2)
			}
			if _write_err195 != nil {
				return false, thrift.WrapTException(_write_err195)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeTaggedBatchRawV2", thrift.REPLY, seqId); err2 != nil {
		_write_err195 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err195 == nil && err2 != nil {
		_write_err195 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err195 == nil && err2 != nil {
		_write_err195 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err195 == nil && err2 != nil {
		_write_err195 = thrift.WrapTException(err2)
	}
	if _write_err195 != nil {
		return false, thrift.WrapTException(_write_err195)
	}
	return true, err
}

type nodeProcessorRepair struct {
	handler Node
}

func (p *nodeProcessorRepair) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err197 error
	args := NodeRepairArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "repair", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeRepairResult{}
	if err2 := p.handler.Repair(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc198 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing repair: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "repair", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err197 = thrift.WrapTException(err2)
			}
			if err2 := _exc198.Write(ctx, oprot); _write_err197 == nil && err2 != nil {
				_write_err197 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err197 == nil && err2 != nil {
				_write_err197 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err197 == nil && err2 != nil {
				_write_err197 = thrift.WrapTException(err2)
			}
			if _write_err197 != nil {
				return false, thrift.WrapTException(_write_err197)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "repair", thrift.REPLY, seqId); err2 != nil {
		_write_err197 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err197 == nil && err2 != nil {
		_write_err197 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err197 == nil && err2 != nil {
		_write_err197 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err197 == nil && err2 != nil {
		_write_err197 = thrift.WrapTException(err2)
	}
	if _write_err197 != nil {
		return false, thrift.WrapTException(_write_err197)
	}
	return true, err
}

type nodeProcessorTruncate struct {
	handler Node
}

func (p *nodeProcessorTruncate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err199 error
	args := NodeTruncateArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "truncate", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeTruncateResult{}
	if retval, err2 := p.handler.Truncate(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc200 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "truncate", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err199 = thrift.WrapTException(err2)
			}
			if err2 := _exc200.Write(ctx, oprot); _write_err199 == nil && err2 != nil {
				_write_err199 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err199 == nil && err2 != nil {
				_write_err199 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err199 == nil && err2 != nil {
				_write_err199 = thrift.WrapTException(err2)
			}
			if _write_err199 != nil {
				return false, thrift.WrapTException(_write_err199)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "truncate", thrift.REPLY, seqId); err2 != nil {
		_write_err199 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err199 == nil && err2 != nil {
		_write_err199 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err199 == nil && err2 != nil {
		_write_err199 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err199 == nil && err2 != nil {
		_write_err199 = thrift.WrapTException(err2)
	}
	if _write_err199 != nil {
		return false, thrift.WrapTException(_write_err199)
	}
	return true, err
}

type nodeProcessorAggregateTiles struct {
	handler Node
}

func (p *nodeProcessorAggregateTiles) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err201 error
	args := NodeAggregateTilesArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "aggregateTiles", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeAggregateTilesResult{}
	if retval, err2 := p.handler.AggregateTiles(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc202 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregateTiles: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "aggregateTiles", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err201 = thrift.WrapTException(err2)
			}
			if err2 := _exc202.Write(ctx, oprot); _write_err201 == nil && err2 != nil {
				_write_err201 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err201 == nil && err2 != nil {
				_write_err201 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err201 == nil && err2 != nil {
				_write_err201 = thrift.WrapTException(err2)
			}
			if _write_err201 != nil {
				return false, thrift.WrapTException(_write_err201)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "aggregateTiles", thrift.REPLY, seqId); err2 != nil {
		_write_err201 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err201 == nil && err2 != nil {
		_write_err201 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err201 == nil && err2 != nil {
		_write_err201 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err201 == nil && err2 != nil {
		_write_err201 = thrift.WrapTException(err2)
	}
	if _write_err201 != nil {
		return false, thrift.WrapTException(_write_err201)
	}
	return true, err
}

type nodeProcessorHealth struct {
	handler Node
}

func (p *nodeProcessorHealth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err203 error
	args := NodeHealthArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "health", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeHealthResult{}
	if retval, err2 := p.handler.Health(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc204 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing health: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "health", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err203 = thrift.WrapTException(err2)
			}
			if err2 := _exc204.Write(ctx, oprot); _write_err203 == nil && err2 != nil {
				_write_err203 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err203 == nil && err2 != nil {
				_write_err203 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err203 == nil && err2 != nil {
				_write_err203 = thrift.WrapTException(err2)
			}
			if _write_err203 != nil {
				return false, thrift.WrapTException(_write_err203)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "health", thrift.REPLY, seqId); err2 != nil {
		_write_err203 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err203 == nil && err2 != nil {
		_write_err203 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err203 == nil && err2 != nil {
		_write_err203 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err203 == nil && err2 != nil {
		_write_err203 = thrift.WrapTException(err2)
	}
	if _write_err203 != nil {
		return false, thrift.WrapTException(_write_err203)
	}
	return true, err
}

type nodeProcessorBootstrapped struct {
	handler Node
}

func (p *nodeProcessorBootstrapped) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err205 error
	args := NodeBootstrappedArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "bootstrapped", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeBootstrappedResult{}
	if retval, err2 := p.handler.Bootstrapped(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc206 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing bootstrapped: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "bootstrapped", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err205 = thrift.WrapTException(err2)
			}
			if err2 := _exc206.Write(ctx, oprot); _write_err205 == nil && err2 != nil {
				_write_err205 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err205 == nil && err2 != nil {
				_write_err205 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err205 == nil && err2 != nil {
				_write_err205 = thrift.WrapTException(err2)
			}
			if _write_err205 != nil {
				return false, thrift.WrapTException(_write_err205)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "bootstrapped", thrift.REPLY, seqId); err2 != nil {
		_write_err205 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err205 == nil && err2 != nil {
		_write_err205 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err205 == nil && err2 != nil {
		_write_err205 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err205 == nil && err2 != nil {
		_write_err205 = thrift.WrapTException(err2)
	}
	if _write_err205 != nil {
		return false, thrift.WrapTException(_write_err205)
	}
	return true, err
}

type nodeProcessorBootstrappedInPlacementOrNoPlacement struct {
	handler Node
}

func (p *nodeProcessorBootstrappedInPlacementOrNoPlacement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err207 error
	args := NodeBootstrappedInPlacementOrNoPlacementArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "bootstrappedInPlacementOrNoPlacement", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeBootstrappedInPlacementOrNoPlacementResult{}
	if retval, err2 := p.handler.BootstrappedInPlacementOrNoPlacement(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc208 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing bootstrappedInPlacementOrNoPlacement: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "bootstrappedInPlacementOrNoPlacement", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err207 = thrift.WrapTException(err2)
			}
			if err2 := _exc208.Write(ctx, oprot); _write_err207 == nil && err2 != nil {
				_write_err207 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err207 == nil && err2 != nil {
				_write_err207 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err207 == nil && err2 != nil {
				_write_err207 = thrift.WrapTException(err2)
			}
			if _write_err207 != nil {
				return false, thrift.WrapTException(_write_err207)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "bootstrappedInPlacementOrNoPlacement", thrift.REPLY, seqId); err2 != nil {
		_write_err207 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err207 == nil && err2 != nil {
		_write_err207 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err207 == nil && err2 != nil {
		_write_err207 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err207 == nil && err2 != nil {
		_write_err207 = thrift.WrapTException(err2)
	}
	if _write_err207 != nil {
		return false, thrift.WrapTException(_write_err207)
	}
	return true, err
}

type nodeProcessorGetPersistRateLimit struct {
	handler Node
}

func (p *nodeProcessorGetPersistRateLimit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err209 error
	args := NodeGetPersistRateLimitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getPersistRateLimit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeGetPersistRateLimitResult{}
	if retval, err2 := p.handler.GetPersistRateLimit(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc210 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPersistRateLimit: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getPersistRateLimit", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err209 = thrift.WrapTException(err2)
			}
			if err2 := _exc210.Write(ctx, oprot); _write_err209 == nil && err2 != nil {
				_write_err209 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err209 == nil && err2 != nil {
				_write_err209 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err209 == nil && err2 != nil {
				_write_err209 = thrift.WrapTException(err2)
			}
			if _write_err209 != nil {
				return false, thrift.WrapTException(_write_err209)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getPersistRateLimit", thrift.REPLY, seqId); err2 != nil {
		_write_err209 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err209 == nil && err2 != nil {
		_write_err209 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err209 == nil && err2 != nil {
		_write_err209 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err209 == nil && err2 != nil {
		_write_err209 = thrift.WrapTException(err2)
	}
	if _write_err209 != nil {
		return false, thrift.WrapTException(_write_err209)
	}
	return true, err
}

type nodeProcessorSetPersistRateLimit struct {
	handler Node
}

func (p *nodeProcessorSetPersistRateLimit) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err211 error
	args := NodeSetPersistRateLimitArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "setPersistRateLimit", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeSetPersistRateLimitResult{}
	if retval, err2 := p.handler.SetPersistRateLimit(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc212 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setPersistRateLimit: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "setPersistRateLimit", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err211 = thrift.WrapTException(err2)
			}
			if err2 := _exc212.Write(ctx, oprot); _write_err211 == nil && err2 != nil {
				_write_err211 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err211 == nil && err2 != nil {
				_write_err211 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err211 == nil && err2 != nil {
				_write_err211 = thrift.WrapTException(err2)
			}
			if _write_err211 != nil {
				return false, thrift.WrapTException(_write_err211)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "setPersistRateLimit", thrift.REPLY, seqId); err2 != nil {
		_write_err211 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err211 == nil && err2 != nil {
		_write_err211 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err211 == nil && err2 != nil {
		_write_err211 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err211 == nil && err2 != nil {
		_write_err211 = thrift.WrapTException(err2)
	}
	if _write_err211 != nil {
		return false, thrift.WrapTException(_write_err211)
	}
	return true, err
}

type nodeProcessorGetWriteNewSeriesAsync struct {
	handler Node
}

func (p *nodeProcessorGetWriteNewSeriesAsync) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err213 error
	args := NodeGetWriteNewSeriesAsyncArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getWriteNewSeriesAsync", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeGetWriteNewSeriesAsyncResult{}
	if retval, err2 := p.handler.GetWriteNewSeriesAsync(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc214 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getWriteNewSeriesAsync: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesAsync", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err213 = thrift.WrapTException(err2)
			}
			if err2 := _exc214.Write(ctx, oprot); _write_err213 == nil && err2 != nil {
				_write_err213 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err213 == nil && err2 != nil {
				_write_err213 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err213 == nil && err2 != nil {
				_write_err213 = thrift.WrapTException(err2)
			}
			if _write_err213 != nil {
				return false, thrift.WrapTException(_write_err213)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesAsync", thrift.REPLY, seqId); err2 != nil {
		_write_err213 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err213 == nil && err2 != nil {
		_write_err213 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err213 == nil && err2 != nil {
		_write_err213 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err213 == nil && err2 != nil {
		_write_err213 = thrift.WrapTException(err2)
	}
	if _write_err213 != nil {
		return false, thrift.WrapTException(_write_err213)
	}
	return true, err
}

type nodeProcessorSetWriteNewSeriesAsync struct {
	handler Node
}

func (p *nodeProcessorSetWriteNewSeriesAsync) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err215 error
	args := NodeSetWriteNewSeriesAsyncArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "setWriteNewSeriesAsync", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeSetWriteNewSeriesAsyncResult{}
	if retval, err2 := p.handler.SetWriteNewSeriesAsync(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc216 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setWriteNewSeriesAsync: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesAsync", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err215 = thrift.WrapTException(err2)
			}
			if err2 := _exc216.Write(ctx, oprot); _write_err215 == nil && err2 != nil {
				_write_err215 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err215 == nil && err2 != nil {
				_write_err215 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err215 == nil && err2 != nil {
				_write_err215 = thrift.WrapTException(err2)
			}
			if _write_err215 != nil {
				return false, thrift.WrapTException(_write_err215)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesAsync", thrift.REPLY, seqId); err2 != nil {
		_write_err215 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err215 == nil && err2 != nil {
		_write_err215 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err215 == nil && err2 != nil {
		_write_err215 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err215 == nil && err2 != nil {
		_write_err215 = thrift.WrapTException(err2)
	}
	if _write_err215 != nil {
		return false, thrift.WrapTException(_write_err215)
	}
	return true, err
}

type nodeProcessorGetWriteNewSeriesBackoffDuration struct {
	handler Node
}

func (p *nodeProcessorGetWriteNewSeriesBackoffDuration) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err217 error
	args := NodeGetWriteNewSeriesBackoffDurationArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getWriteNewSeriesBackoffDuration", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeGetWriteNewSeriesBackoffDurationResult{}
	if retval, err2 := p.handler.GetWriteNewSeriesBackoffDuration(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc218 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getWriteNewSeriesBackoffDuration: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesBackoffDuration", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err217 = thrift.WrapTException(err2)
			}
			if err2 := _exc218.Write(ctx, oprot); _write_err217 == nil && err2 != nil {
				_write_err217 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err217 == nil && err2 != nil {
				_write_err217 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err217 == nil && err2 != nil {
				_write_err217 = thrift.WrapTException(err2)
			}
			if _write_err217 != nil {
				return false, thrift.WrapTException(_write_err217)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesBackoffDuration", thrift.REPLY, seqId); err2 != nil {
		_write_err217 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err217 == nil && err2 != nil {
		_write_err217 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err217 == nil && err2 != nil {
		_write_err217 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err217 == nil && err2 != nil {
		_write_err217 = thrift.WrapTException(err2)
	}
	if _write_err217 != nil {
		return false, thrift.WrapTException(_write_err217)
	}
	return true, err
}

type nodeProcessorSetWriteNewSeriesBackoffDuration struct {
	handler Node
}

func (p *nodeProcessorSetWriteNewSeriesBackoffDuration) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err219 error
	args := NodeSetWriteNewSeriesBackoffDurationArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "setWriteNewSeriesBackoffDuration", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeSetWriteNewSeriesBackoffDurationResult{}
	if retval, err2 := p.handler.SetWriteNewSeriesBackoffDuration(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc220 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setWriteNewSeriesBackoffDuration: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesBackoffDuration", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err219 = thrift.WrapTException(err2)
			}
			if err2 := _exc220.Write(ctx, oprot); _write_err219 == nil && err2 != nil {
				_write_err219 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err219 == nil && err2 != nil {
				_write_err219 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err219 == nil && err2 != nil {
				_write_err219 = thrift.WrapTException(err2)
			}
			if _write_err219 != nil {
				return false, thrift.WrapTException(_write_err219)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesBackoffDuration", thrift.REPLY, seqId); err2 != nil {
		_write_err219 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err219 == nil && err2 != nil {
		_write_err219 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err219 == nil && err2 != nil {
		_write_err219 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err219 == nil && err2 != nil {
		_write_err219 = thrift.WrapTException(err2)
	}
	if _write_err219 != nil {
		return false, thrift.WrapTException(_write_err219)
	}
	return true, err
}

type nodeProcessorGetWriteNewSeriesLimitPerShardPerSecond struct {
	handler Node
}

func (p *nodeProcessorGetWriteNewSeriesLimitPerShardPerSecond) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err221 error
	args := NodeGetWriteNewSeriesLimitPerShardPerSecondArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "getWriteNewSeriesLimitPerShardPerSecond", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeGetWriteNewSeriesLimitPerShardPerSecondResult{}
	if retval, err2 := p.handler.GetWriteNewSeriesLimitPerShardPerSecond(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc222 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getWriteNewSeriesLimitPerShardPerSecond: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesLimitPerShardPerSecond", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err221 = thrift.WrapTException(err2)
			}
			if err2 := _exc222.Write(ctx, oprot); _write_err221 == nil && err2 != nil {
				_write_err221 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err221 == nil && err2 != nil {
				_write_err221 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err221 == nil && err2 != nil {
				_write_err221 = thrift.WrapTException(err2)
			}
			if _write_err221 != nil {
				return false, thrift.WrapTException(_write_err221)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "getWriteNewSeriesLimitPerShardPerSecond", thrift.REPLY, seqId); err2 != nil {
		_write_err221 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err221 == nil && err2 != nil {
		_write_err221 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err221 == nil && err2 != nil {
		_write_err221 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err221 == nil && err2 != nil {
		_write_err221 = thrift.WrapTException(err2)
	}
	if _write_err221 != nil {
		return false, thrift.WrapTException(_write_err221)
	}
	return true, err
}

type nodeProcessorSetWriteNewSeriesLimitPerShardPerSecond struct {
	handler Node
}

func (p *nodeProcessorSetWriteNewSeriesLimitPerShardPerSecond) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err223 error
	args := NodeSetWriteNewSeriesLimitPerShardPerSecondArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "setWriteNewSeriesLimitPerShardPerSecond", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeSetWriteNewSeriesLimitPerShardPerSecondResult{}
	if retval, err2 := p.handler.SetWriteNewSeriesLimitPerShardPerSecond(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc224 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing setWriteNewSeriesLimitPerShardPerSecond: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesLimitPerShardPerSecond", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err223 = thrift.WrapTException(err2)
			}
			if err2 := _exc224.Write(ctx, oprot); _write_err223 == nil && err2 != nil {
				_write_err223 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err223 == nil && err2 != nil {
				_write_err223 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err223 == nil && err2 != nil {
				_write_err223 = thrift.WrapTException(err2)
			}
			if _write_err223 != nil {
				return false, thrift.WrapTException(_write_err223)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "setWriteNewSeriesLimitPerShardPerSecond", thrift.REPLY, seqId); err2 != nil {
		_write_err223 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err223 == nil && err2 != nil {
		_write_err223 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err223 == nil && err2 != nil {
		_write_err223 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err223 == nil && err2 != nil {
		_write_err223 = thrift.WrapTException(err2)
	}
	if _write_err223 != nil {
		return false, thrift.WrapTException(_write_err223)
	}
	return true, err
}

type nodeProcessorDebugProfileStart struct {
	handler Node
}

func (p *nodeProcessorDebugProfileStart) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err225 error
	args := NodeDebugProfileStartArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "debugProfileStart", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeDebugProfileStartResult{}
	if retval, err2 := p.handler.DebugProfileStart(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc226 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing debugProfileStart: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "debugProfileStart", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err225 = thrift.WrapTException(err2)
			}
			if err2 := _exc226.Write(ctx, oprot); _write_err225 == nil && err2 != nil {
				_write_err225 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err225 == nil && err2 != nil {
				_write_err225 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err225 == nil && err2 != nil {
				_write_err225 = thrift.WrapTException(err2)
			}
			if _write_err225 != nil {
				return false, thrift.WrapTException(_write_err225)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "debugProfileStart", thrift.REPLY, seqId); err2 != nil {
		_write_err225 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err225 == nil && err2 != nil {
		_write_err225 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err225 == nil && err2 != nil {
		_write_err225 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err225 == nil && err2 != nil {
		_write_err225 = thrift.WrapTException(err2)
	}
	if _write_err225 != nil {
		return false, thrift.WrapTException(_write_err225)
	}
	return true, err
}

type nodeProcessorDebugProfileStop struct {
	handler Node
}

func (p *nodeProcessorDebugProfileStop) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err227 error
	args := NodeDebugProfileStopArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "debugProfileStop", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeDebugProfileStopResult{}
	if retval, err2 := p.handler.DebugProfileStop(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc228 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing debugProfileStop: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "debugProfileStop", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err227 = thrift.WrapTException(err2)
			}
			if err2 := _exc228.Write(ctx, oprot); _write_err227 == nil && err2 != nil {
				_write_err227 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err227 == nil && err2 != nil {
				_write_err227 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err227 == nil && err2 != nil {
				_write_err227 = thrift.WrapTException(err2)
			}
			if _write_err227 != nil {
				return false, thrift.WrapTException(_write_err227)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "debugProfileStop", thrift.REPLY, seqId); err2 != nil {
		_write_err227 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err227 == nil && err2 != nil {
		_write_err227 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err227 == nil && err2 != nil {
		_write_err227 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err227 == nil && err2 != nil {
		_write_err227 = thrift.WrapTException(err2)
	}
	if _write_err227 != nil {
		return false, thrift.WrapTException(_write_err227)
	}
	return true, err
}

type nodeProcessorDebugIndexMemorySegments struct {
	handler Node
}

func (p *nodeProcessorDebugIndexMemorySegments) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err229 error
	args := NodeDebugIndexMemorySegmentsArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "debugIndexMemorySegments", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := NodeDebugIndexMemorySegmentsResult{}
	if retval, err2 := p.handler.DebugIndexMemorySegments(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc230 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing debugIndexMemorySegments: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "debugIndexMemorySegments", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err229 = thrift.WrapTException(err2)
			}
			if err2 := _exc230.Write(ctx, oprot); _write_err229 == nil && err2 != nil {
				_write_err229 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err229 == nil && err2 != nil {
				_write_err229 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err229 == nil && err2 != nil {
				_write_err229 = thrift.WrapTException(err2)
			}
			if _write_err229 != nil {
				return false, thrift.WrapTException(_write_err229)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "debugIndexMemorySegments", thrift.REPLY, seqId); err2 != nil {
		_write_err229 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err229 == nil && err2 != nil {
		_write_err229 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err229 == nil && err2 != nil {
		_write_err229 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err229 == nil && err2 != nil {
		_write_err229 = thrift.WrapTException(err2)
	}
	if _write_err229 != nil {
		return false, thrift.WrapTException(_write_err229)
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - Req
// 
type NodeQueryArgs struct {
	Req *QueryRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeQueryArgs() *NodeQueryArgs {
	return &NodeQueryArgs{}
}

var NodeQueryArgs_Req_DEFAULT *QueryRequest

func (p *NodeQueryArgs) GetReq() *QueryRequest {
	if !p.IsSetReq() {
		return NodeQueryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeQueryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeQueryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeQueryArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &QueryRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeQueryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeQueryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeQueryArgs(%+v)", *p)
}

func (p *NodeQueryArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeQueryArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeQueryArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeQueryResult struct {
	Success *QueryResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeQueryResult() *NodeQueryResult {
	return &NodeQueryResult{}
}

var NodeQueryResult_Success_DEFAULT *QueryResult_

func (p *NodeQueryResult) GetSuccess() *QueryResult_ {
	if !p.IsSetSuccess() {
		return NodeQueryResult_Success_DEFAULT
	}
	return p.Success
}

var NodeQueryResult_Err_DEFAULT *Error

func (p *NodeQueryResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeQueryResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeQueryResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeQueryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeQueryResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &QueryResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeQueryResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeQueryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeQueryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeQueryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeQueryResult(%+v)", *p)
}

func (p *NodeQueryResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeQueryResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeQueryResult)(nil)

// Attributes:
//  - Req
// 
type NodeAggregateArgs struct {
	Req *AggregateQueryRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeAggregateArgs() *NodeAggregateArgs {
	return &NodeAggregateArgs{}
}

var NodeAggregateArgs_Req_DEFAULT *AggregateQueryRequest

func (p *NodeAggregateArgs) GetReq() *AggregateQueryRequest {
	if !p.IsSetReq() {
		return NodeAggregateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeAggregateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeAggregateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &AggregateQueryRequest{
		AggregateQueryType: 1,
		RangeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeAggregateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeAggregateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateArgs(%+v)", *p)
}

func (p *NodeAggregateArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeAggregateResult struct {
	Success *AggregateQueryResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeAggregateResult() *NodeAggregateResult {
	return &NodeAggregateResult{}
}

var NodeAggregateResult_Success_DEFAULT *AggregateQueryResult_

func (p *NodeAggregateResult) GetSuccess() *AggregateQueryResult_ {
	if !p.IsSetSuccess() {
		return NodeAggregateResult_Success_DEFAULT
	}
	return p.Success
}

var NodeAggregateResult_Err_DEFAULT *Error

func (p *NodeAggregateResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeAggregateResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeAggregateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeAggregateResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeAggregateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &AggregateQueryResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeAggregateResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeAggregateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateResult(%+v)", *p)
}

func (p *NodeAggregateResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateResult)(nil)

// Attributes:
//  - Req
// 
type NodeFetchArgs struct {
	Req *FetchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchArgs() *NodeFetchArgs {
	return &NodeFetchArgs{}
}

var NodeFetchArgs_Req_DEFAULT *FetchRequest

func (p *NodeFetchArgs) GetReq() *FetchRequest {
	if !p.IsSetReq() {
		return NodeFetchArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchArgs(%+v)", *p)
}

func (p *NodeFetchArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchResult struct {
	Success *FetchResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchResult() *NodeFetchResult {
	return &NodeFetchResult{}
}

var NodeFetchResult_Success_DEFAULT *FetchResult_

func (p *NodeFetchResult) GetSuccess() *FetchResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchResult_Err_DEFAULT *Error

func (p *NodeFetchResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchResult(%+v)", *p)
}

func (p *NodeFetchResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchResult)(nil)

// Attributes:
//  - Req
// 
type NodeWriteArgs struct {
	Req *WriteRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteArgs() *NodeWriteArgs {
	return &NodeWriteArgs{}
}

var NodeWriteArgs_Req_DEFAULT *WriteRequest

func (p *NodeWriteArgs) GetReq() *WriteRequest {
	if !p.IsSetReq() {
		return NodeWriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "write_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteArgs(%+v)", *p)
}

func (p *NodeWriteArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteArgs)(nil)

// Attributes:
//  - Err
// 
type NodeWriteResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteResult() *NodeWriteResult {
	return &NodeWriteResult{}
}

var NodeWriteResult_Err_DEFAULT *Error

func (p *NodeWriteResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeWriteResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "write_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteResult(%+v)", *p)
}

func (p *NodeWriteResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteResult)(nil)

// Attributes:
//  - Req
// 
type NodeWriteTaggedArgs struct {
	Req *WriteTaggedRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteTaggedArgs() *NodeWriteTaggedArgs {
	return &NodeWriteTaggedArgs{}
}

var NodeWriteTaggedArgs_Req_DEFAULT *WriteTaggedRequest

func (p *NodeWriteTaggedArgs) GetReq() *WriteTaggedRequest {
	if !p.IsSetReq() {
		return NodeWriteTaggedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteTaggedArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteTaggedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteTaggedRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteTaggedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTagged_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteTaggedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedArgs(%+v)", *p)
}

func (p *NodeWriteTaggedArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedArgs)(nil)

// Attributes:
//  - Err
// 
type NodeWriteTaggedResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteTaggedResult() *NodeWriteTaggedResult {
	return &NodeWriteTaggedResult{}
}

var NodeWriteTaggedResult_Err_DEFAULT *Error

func (p *NodeWriteTaggedResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeWriteTaggedResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteTaggedResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteTaggedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteTaggedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTagged_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteTaggedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedResult(%+v)", *p)
}

func (p *NodeWriteTaggedResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedResult)(nil)

// Attributes:
//  - Req
// 
type NodeAggregateRawArgs struct {
	Req *AggregateQueryRawRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeAggregateRawArgs() *NodeAggregateRawArgs {
	return &NodeAggregateRawArgs{}
}

var NodeAggregateRawArgs_Req_DEFAULT *AggregateQueryRawRequest

func (p *NodeAggregateRawArgs) GetReq() *AggregateQueryRawRequest {
	if !p.IsSetReq() {
		return NodeAggregateRawArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeAggregateRawArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeAggregateRawArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateRawArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &AggregateQueryRawRequest{
		AggregateQueryType: 1,
		RangeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeAggregateRawArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregateRaw_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateRawArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeAggregateRawArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateRawArgs(%+v)", *p)
}

func (p *NodeAggregateRawArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateRawArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateRawArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeAggregateRawResult struct {
	Success *AggregateQueryRawResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeAggregateRawResult() *NodeAggregateRawResult {
	return &NodeAggregateRawResult{}
}

var NodeAggregateRawResult_Success_DEFAULT *AggregateQueryRawResult_

func (p *NodeAggregateRawResult) GetSuccess() *AggregateQueryRawResult_ {
	if !p.IsSetSuccess() {
		return NodeAggregateRawResult_Success_DEFAULT
	}
	return p.Success
}

var NodeAggregateRawResult_Err_DEFAULT *Error

func (p *NodeAggregateRawResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeAggregateRawResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeAggregateRawResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeAggregateRawResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeAggregateRawResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateRawResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &AggregateQueryRawResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeAggregateRawResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeAggregateRawResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregateRaw_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateRawResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateRawResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateRawResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateRawResult(%+v)", *p)
}

func (p *NodeAggregateRawResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateRawResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateRawResult)(nil)

// Attributes:
//  - Req
// 
type NodeFetchBatchRawArgs struct {
	Req *FetchBatchRawRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchBatchRawArgs() *NodeFetchBatchRawArgs {
	return &NodeFetchBatchRawArgs{}
}

var NodeFetchBatchRawArgs_Req_DEFAULT *FetchBatchRawRequest

func (p *NodeFetchBatchRawArgs) GetReq() *FetchBatchRawRequest {
	if !p.IsSetReq() {
		return NodeFetchBatchRawArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchBatchRawArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchBatchRawArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBatchRawArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchBatchRawRequest{
		RangeTimeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchBatchRawArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBatchRaw_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBatchRawArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchBatchRawArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBatchRawArgs(%+v)", *p)
}

func (p *NodeFetchBatchRawArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBatchRawArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBatchRawArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchBatchRawResult struct {
	Success *FetchBatchRawResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchBatchRawResult() *NodeFetchBatchRawResult {
	return &NodeFetchBatchRawResult{}
}

var NodeFetchBatchRawResult_Success_DEFAULT *FetchBatchRawResult_

func (p *NodeFetchBatchRawResult) GetSuccess() *FetchBatchRawResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchBatchRawResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchBatchRawResult_Err_DEFAULT *Error

func (p *NodeFetchBatchRawResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchBatchRawResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchBatchRawResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchBatchRawResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchBatchRawResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBatchRawResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchBatchRawResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchBatchRawResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchBatchRawResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBatchRaw_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBatchRawResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBatchRawResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBatchRawResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBatchRawResult(%+v)", *p)
}

func (p *NodeFetchBatchRawResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBatchRawResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBatchRawResult)(nil)

// Attributes:
//  - Req
// 
type NodeFetchBatchRawV2Args struct {
	Req *FetchBatchRawV2Request `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchBatchRawV2Args() *NodeFetchBatchRawV2Args {
	return &NodeFetchBatchRawV2Args{}
}

var NodeFetchBatchRawV2Args_Req_DEFAULT *FetchBatchRawV2Request

func (p *NodeFetchBatchRawV2Args) GetReq() *FetchBatchRawV2Request {
	if !p.IsSetReq() {
		return NodeFetchBatchRawV2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchBatchRawV2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchBatchRawV2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchBatchRawV2Request{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBatchRawV2_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchBatchRawV2Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBatchRawV2Args(%+v)", *p)
}

func (p *NodeFetchBatchRawV2Args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBatchRawV2Args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBatchRawV2Args)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchBatchRawV2Result struct {
	Success *FetchBatchRawResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchBatchRawV2Result() *NodeFetchBatchRawV2Result {
	return &NodeFetchBatchRawV2Result{}
}

var NodeFetchBatchRawV2Result_Success_DEFAULT *FetchBatchRawResult_

func (p *NodeFetchBatchRawV2Result) GetSuccess() *FetchBatchRawResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchBatchRawV2Result_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchBatchRawV2Result_Err_DEFAULT *Error

func (p *NodeFetchBatchRawV2Result) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchBatchRawV2Result_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchBatchRawV2Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchBatchRawV2Result) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchBatchRawV2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchBatchRawResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBatchRawV2_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBatchRawV2Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBatchRawV2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBatchRawV2Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBatchRawV2Result(%+v)", *p)
}

func (p *NodeFetchBatchRawV2Result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBatchRawV2Result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBatchRawV2Result)(nil)

// Attributes:
//  - Req
// 
type NodeFetchBlocksRawArgs struct {
	Req *FetchBlocksRawRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchBlocksRawArgs() *NodeFetchBlocksRawArgs {
	return &NodeFetchBlocksRawArgs{}
}

var NodeFetchBlocksRawArgs_Req_DEFAULT *FetchBlocksRawRequest

func (p *NodeFetchBlocksRawArgs) GetReq() *FetchBlocksRawRequest {
	if !p.IsSetReq() {
		return NodeFetchBlocksRawArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchBlocksRawArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchBlocksRawArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBlocksRawArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchBlocksRawRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchBlocksRawArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBlocksRaw_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBlocksRawArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchBlocksRawArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBlocksRawArgs(%+v)", *p)
}

func (p *NodeFetchBlocksRawArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBlocksRawArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBlocksRawArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchBlocksRawResult struct {
	Success *FetchBlocksRawResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchBlocksRawResult() *NodeFetchBlocksRawResult {
	return &NodeFetchBlocksRawResult{}
}

var NodeFetchBlocksRawResult_Success_DEFAULT *FetchBlocksRawResult_

func (p *NodeFetchBlocksRawResult) GetSuccess() *FetchBlocksRawResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchBlocksRawResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchBlocksRawResult_Err_DEFAULT *Error

func (p *NodeFetchBlocksRawResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchBlocksRawResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchBlocksRawResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchBlocksRawResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchBlocksRawResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBlocksRawResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchBlocksRawResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchBlocksRawResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchBlocksRawResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBlocksRaw_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBlocksRawResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBlocksRawResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBlocksRawResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBlocksRawResult(%+v)", *p)
}

func (p *NodeFetchBlocksRawResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBlocksRawResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBlocksRawResult)(nil)

// Attributes:
//  - Req
// 
type NodeFetchTaggedArgs struct {
	Req *FetchTaggedRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchTaggedArgs() *NodeFetchTaggedArgs {
	return &NodeFetchTaggedArgs{}
}

var NodeFetchTaggedArgs_Req_DEFAULT *FetchTaggedRequest

func (p *NodeFetchTaggedArgs) GetReq() *FetchTaggedRequest {
	if !p.IsSetReq() {
		return NodeFetchTaggedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchTaggedArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchTaggedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchTaggedArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchTaggedRequest{
		RangeTimeType: 0,
		RequireExhaustive: true,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchTaggedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchTagged_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchTaggedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchTaggedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchTaggedArgs(%+v)", *p)
}

func (p *NodeFetchTaggedArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchTaggedArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchTaggedArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchTaggedResult struct {
	Success *FetchTaggedResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchTaggedResult() *NodeFetchTaggedResult {
	return &NodeFetchTaggedResult{}
}

var NodeFetchTaggedResult_Success_DEFAULT *FetchTaggedResult_

func (p *NodeFetchTaggedResult) GetSuccess() *FetchTaggedResult_ {
	if !p.IsSetSuccess() {
		return NodeFetchTaggedResult_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchTaggedResult_Err_DEFAULT *Error

func (p *NodeFetchTaggedResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchTaggedResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchTaggedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchTaggedResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchTaggedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchTaggedResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchTaggedResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchTaggedResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchTaggedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchTagged_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchTaggedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchTaggedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchTaggedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchTaggedResult(%+v)", *p)
}

func (p *NodeFetchTaggedResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchTaggedResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchTaggedResult)(nil)

// Attributes:
//  - Req
// 
type NodeFetchBlocksMetadataRawV2Args struct {
	Req *FetchBlocksMetadataRawV2Request `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeFetchBlocksMetadataRawV2Args() *NodeFetchBlocksMetadataRawV2Args {
	return &NodeFetchBlocksMetadataRawV2Args{}
}

var NodeFetchBlocksMetadataRawV2Args_Req_DEFAULT *FetchBlocksMetadataRawV2Request

func (p *NodeFetchBlocksMetadataRawV2Args) GetReq() *FetchBlocksMetadataRawV2Request {
	if !p.IsSetReq() {
		return NodeFetchBlocksMetadataRawV2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeFetchBlocksMetadataRawV2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeFetchBlocksMetadataRawV2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchBlocksMetadataRawV2Request{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBlocksMetadataRawV2_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeFetchBlocksMetadataRawV2Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBlocksMetadataRawV2Args(%+v)", *p)
}

func (p *NodeFetchBlocksMetadataRawV2Args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBlocksMetadataRawV2Args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBlocksMetadataRawV2Args)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeFetchBlocksMetadataRawV2Result struct {
	Success *FetchBlocksMetadataRawV2Result_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeFetchBlocksMetadataRawV2Result() *NodeFetchBlocksMetadataRawV2Result {
	return &NodeFetchBlocksMetadataRawV2Result{}
}

var NodeFetchBlocksMetadataRawV2Result_Success_DEFAULT *FetchBlocksMetadataRawV2Result_

func (p *NodeFetchBlocksMetadataRawV2Result) GetSuccess() *FetchBlocksMetadataRawV2Result_ {
	if !p.IsSetSuccess() {
		return NodeFetchBlocksMetadataRawV2Result_Success_DEFAULT
	}
	return p.Success
}

var NodeFetchBlocksMetadataRawV2Result_Err_DEFAULT *Error

func (p *NodeFetchBlocksMetadataRawV2Result) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeFetchBlocksMetadataRawV2Result_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeFetchBlocksMetadataRawV2Result) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchBlocksMetadataRawV2Result_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetchBlocksMetadataRawV2_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeFetchBlocksMetadataRawV2Result) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBlocksMetadataRawV2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeFetchBlocksMetadataRawV2Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeFetchBlocksMetadataRawV2Result(%+v)", *p)
}

func (p *NodeFetchBlocksMetadataRawV2Result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeFetchBlocksMetadataRawV2Result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeFetchBlocksMetadataRawV2Result)(nil)

// Attributes:
//  - Req
// 
type NodeWriteBatchRawArgs struct {
	Req *WriteBatchRawRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteBatchRawArgs() *NodeWriteBatchRawArgs {
	return &NodeWriteBatchRawArgs{}
}

var NodeWriteBatchRawArgs_Req_DEFAULT *WriteBatchRawRequest

func (p *NodeWriteBatchRawArgs) GetReq() *WriteBatchRawRequest {
	if !p.IsSetReq() {
		return NodeWriteBatchRawArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteBatchRawArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteBatchRawArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchRawArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteBatchRawRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteBatchRawArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeBatchRaw_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchRawArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteBatchRawArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchRawArgs(%+v)", *p)
}

func (p *NodeWriteBatchRawArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteBatchRawArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteBatchRawArgs)(nil)

// Attributes:
//  - Err
// 
type NodeWriteBatchRawResult struct {
	Err *WriteBatchRawErrors `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteBatchRawResult() *NodeWriteBatchRawResult {
	return &NodeWriteBatchRawResult{}
}

var NodeWriteBatchRawResult_Err_DEFAULT *WriteBatchRawErrors

func (p *NodeWriteBatchRawResult) GetErr() *WriteBatchRawErrors {
	if !p.IsSetErr() {
		return NodeWriteBatchRawResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteBatchRawResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteBatchRawResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchRawResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &WriteBatchRawErrors{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteBatchRawResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeBatchRaw_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchRawResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteBatchRawResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchRawResult(%+v)", *p)
}

func (p *NodeWriteBatchRawResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteBatchRawResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteBatchRawResult)(nil)

// Attributes:
//  - Req
// 
type NodeWriteBatchRawV2Args struct {
	Req *WriteBatchRawV2Request `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteBatchRawV2Args() *NodeWriteBatchRawV2Args {
	return &NodeWriteBatchRawV2Args{}
}

var NodeWriteBatchRawV2Args_Req_DEFAULT *WriteBatchRawV2Request

func (p *NodeWriteBatchRawV2Args) GetReq() *WriteBatchRawV2Request {
	if !p.IsSetReq() {
		return NodeWriteBatchRawV2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteBatchRawV2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteBatchRawV2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteBatchRawV2Request{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeBatchRawV2_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteBatchRawV2Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchRawV2Args(%+v)", *p)
}

func (p *NodeWriteBatchRawV2Args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteBatchRawV2Args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteBatchRawV2Args)(nil)

// Attributes:
//  - Err
// 
type NodeWriteBatchRawV2Result struct {
	Err *WriteBatchRawErrors `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteBatchRawV2Result() *NodeWriteBatchRawV2Result {
	return &NodeWriteBatchRawV2Result{}
}

var NodeWriteBatchRawV2Result_Err_DEFAULT *WriteBatchRawErrors

func (p *NodeWriteBatchRawV2Result) GetErr() *WriteBatchRawErrors {
	if !p.IsSetErr() {
		return NodeWriteBatchRawV2Result_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteBatchRawV2Result) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteBatchRawV2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &WriteBatchRawErrors{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeBatchRawV2_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteBatchRawV2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteBatchRawV2Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteBatchRawV2Result(%+v)", *p)
}

func (p *NodeWriteBatchRawV2Result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteBatchRawV2Result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteBatchRawV2Result)(nil)

// Attributes:
//  - Req
// 
type NodeWriteTaggedBatchRawArgs struct {
	Req *WriteTaggedBatchRawRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteTaggedBatchRawArgs() *NodeWriteTaggedBatchRawArgs {
	return &NodeWriteTaggedBatchRawArgs{}
}

var NodeWriteTaggedBatchRawArgs_Req_DEFAULT *WriteTaggedBatchRawRequest

func (p *NodeWriteTaggedBatchRawArgs) GetReq() *WriteTaggedBatchRawRequest {
	if !p.IsSetReq() {
		return NodeWriteTaggedBatchRawArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteTaggedBatchRawArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteTaggedBatchRawArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteTaggedBatchRawRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTaggedBatchRaw_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteTaggedBatchRawArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedBatchRawArgs(%+v)", *p)
}

func (p *NodeWriteTaggedBatchRawArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedBatchRawArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedBatchRawArgs)(nil)

// Attributes:
//  - Err
// 
type NodeWriteTaggedBatchRawResult struct {
	Err *WriteBatchRawErrors `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteTaggedBatchRawResult() *NodeWriteTaggedBatchRawResult {
	return &NodeWriteTaggedBatchRawResult{}
}

var NodeWriteTaggedBatchRawResult_Err_DEFAULT *WriteBatchRawErrors

func (p *NodeWriteTaggedBatchRawResult) GetErr() *WriteBatchRawErrors {
	if !p.IsSetErr() {
		return NodeWriteTaggedBatchRawResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteTaggedBatchRawResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteTaggedBatchRawResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &WriteBatchRawErrors{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTaggedBatchRaw_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteTaggedBatchRawResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedBatchRawResult(%+v)", *p)
}

func (p *NodeWriteTaggedBatchRawResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedBatchRawResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedBatchRawResult)(nil)

// Attributes:
//  - Req
// 
type NodeWriteTaggedBatchRawV2Args struct {
	Req *WriteTaggedBatchRawV2Request `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeWriteTaggedBatchRawV2Args() *NodeWriteTaggedBatchRawV2Args {
	return &NodeWriteTaggedBatchRawV2Args{}
}

var NodeWriteTaggedBatchRawV2Args_Req_DEFAULT *WriteTaggedBatchRawV2Request

func (p *NodeWriteTaggedBatchRawV2Args) GetReq() *WriteTaggedBatchRawV2Request {
	if !p.IsSetReq() {
		return NodeWriteTaggedBatchRawV2Args_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeWriteTaggedBatchRawV2Args) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeWriteTaggedBatchRawV2Args) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Args) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteTaggedBatchRawV2Request{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Args) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTaggedBatchRawV2_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Args) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeWriteTaggedBatchRawV2Args) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedBatchRawV2Args(%+v)", *p)
}

func (p *NodeWriteTaggedBatchRawV2Args) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedBatchRawV2Args",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedBatchRawV2Args)(nil)

// Attributes:
//  - Err
// 
type NodeWriteTaggedBatchRawV2Result struct {
	Err *WriteBatchRawErrors `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeWriteTaggedBatchRawV2Result() *NodeWriteTaggedBatchRawV2Result {
	return &NodeWriteTaggedBatchRawV2Result{}
}

var NodeWriteTaggedBatchRawV2Result_Err_DEFAULT *WriteBatchRawErrors

func (p *NodeWriteTaggedBatchRawV2Result) GetErr() *WriteBatchRawErrors {
	if !p.IsSetErr() {
		return NodeWriteTaggedBatchRawV2Result_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeWriteTaggedBatchRawV2Result) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeWriteTaggedBatchRawV2Result) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Result) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &WriteBatchRawErrors{}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Result) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTaggedBatchRawV2_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeWriteTaggedBatchRawV2Result) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeWriteTaggedBatchRawV2Result) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeWriteTaggedBatchRawV2Result(%+v)", *p)
}

func (p *NodeWriteTaggedBatchRawV2Result) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeWriteTaggedBatchRawV2Result",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeWriteTaggedBatchRawV2Result)(nil)

type NodeRepairArgs struct {
}

func NewNodeRepairArgs() *NodeRepairArgs {
	return &NodeRepairArgs{}
}

func (p *NodeRepairArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeRepairArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "repair_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeRepairArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeRepairArgs(%+v)", *p)
}

func (p *NodeRepairArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeRepairArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeRepairArgs)(nil)

// Attributes:
//  - Err
// 
type NodeRepairResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeRepairResult() *NodeRepairResult {
	return &NodeRepairResult{}
}

var NodeRepairResult_Err_DEFAULT *Error

func (p *NodeRepairResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeRepairResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeRepairResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeRepairResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeRepairResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeRepairResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "repair_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeRepairResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeRepairResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeRepairResult(%+v)", *p)
}

func (p *NodeRepairResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeRepairResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeRepairResult)(nil)

// Attributes:
//  - Req
// 
type NodeTruncateArgs struct {
	Req *TruncateRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeTruncateArgs() *NodeTruncateArgs {
	return &NodeTruncateArgs{}
}

var NodeTruncateArgs_Req_DEFAULT *TruncateRequest

func (p *NodeTruncateArgs) GetReq() *TruncateRequest {
	if !p.IsSetReq() {
		return NodeTruncateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeTruncateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeTruncateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeTruncateArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &TruncateRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeTruncateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeTruncateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeTruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeTruncateArgs(%+v)", *p)
}

func (p *NodeTruncateArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeTruncateArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeTruncateArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeTruncateResult struct {
	Success *TruncateResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeTruncateResult() *NodeTruncateResult {
	return &NodeTruncateResult{}
}

var NodeTruncateResult_Success_DEFAULT *TruncateResult_

func (p *NodeTruncateResult) GetSuccess() *TruncateResult_ {
	if !p.IsSetSuccess() {
		return NodeTruncateResult_Success_DEFAULT
	}
	return p.Success
}

var NodeTruncateResult_Err_DEFAULT *Error

func (p *NodeTruncateResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeTruncateResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeTruncateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeTruncateResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeTruncateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeTruncateResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TruncateResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeTruncateResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeTruncateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeTruncateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeTruncateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeTruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeTruncateResult(%+v)", *p)
}

func (p *NodeTruncateResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeTruncateResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeTruncateResult)(nil)

// Attributes:
//  - Req
// 
type NodeAggregateTilesArgs struct {
	Req *AggregateTilesRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeAggregateTilesArgs() *NodeAggregateTilesArgs {
	return &NodeAggregateTilesArgs{}
}

var NodeAggregateTilesArgs_Req_DEFAULT *AggregateTilesRequest

func (p *NodeAggregateTilesArgs) GetReq() *AggregateTilesRequest {
	if !p.IsSetReq() {
		return NodeAggregateTilesArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeAggregateTilesArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeAggregateTilesArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateTilesArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &AggregateTilesRequest{
		RangeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeAggregateTilesArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregateTiles_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateTilesArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeAggregateTilesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateTilesArgs(%+v)", *p)
}

func (p *NodeAggregateTilesArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateTilesArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateTilesArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeAggregateTilesResult struct {
	Success *AggregateTilesResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeAggregateTilesResult() *NodeAggregateTilesResult {
	return &NodeAggregateTilesResult{}
}

var NodeAggregateTilesResult_Success_DEFAULT *AggregateTilesResult_

func (p *NodeAggregateTilesResult) GetSuccess() *AggregateTilesResult_ {
	if !p.IsSetSuccess() {
		return NodeAggregateTilesResult_Success_DEFAULT
	}
	return p.Success
}

var NodeAggregateTilesResult_Err_DEFAULT *Error

func (p *NodeAggregateTilesResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeAggregateTilesResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeAggregateTilesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeAggregateTilesResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeAggregateTilesResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeAggregateTilesResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &AggregateTilesResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeAggregateTilesResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeAggregateTilesResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregateTiles_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeAggregateTilesResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateTilesResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeAggregateTilesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeAggregateTilesResult(%+v)", *p)
}

func (p *NodeAggregateTilesResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeAggregateTilesResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeAggregateTilesResult)(nil)

type NodeHealthArgs struct {
}

func NewNodeHealthArgs() *NodeHealthArgs {
	return &NodeHealthArgs{}
}

func (p *NodeHealthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeHealthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "health_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeHealthArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeHealthArgs(%+v)", *p)
}

func (p *NodeHealthArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeHealthArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeHealthArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeHealthResult struct {
	Success *NodeHealthResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeHealthResult() *NodeHealthResult {
	return &NodeHealthResult{}
}

var NodeHealthResult_Success_DEFAULT *NodeHealthResult_

func (p *NodeHealthResult) GetSuccess() *NodeHealthResult_ {
	if !p.IsSetSuccess() {
		return NodeHealthResult_Success_DEFAULT
	}
	return p.Success
}

var NodeHealthResult_Err_DEFAULT *Error

func (p *NodeHealthResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeHealthResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeHealthResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeHealthResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeHealthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeHealthResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeHealthResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeHealthResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeHealthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "health_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeHealthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeHealthResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeHealthResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeHealthResult(%+v)", *p)
}

func (p *NodeHealthResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeHealthResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeHealthResult)(nil)

type NodeBootstrappedArgs struct {
}

func NewNodeBootstrappedArgs() *NodeBootstrappedArgs {
	return &NodeBootstrappedArgs{}
}

func (p *NodeBootstrappedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "bootstrapped_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedArgs(%+v)", *p)
}

func (p *NodeBootstrappedArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeBootstrappedResult struct {
	Success *NodeBootstrappedResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeBootstrappedResult() *NodeBootstrappedResult {
	return &NodeBootstrappedResult{}
}

var NodeBootstrappedResult_Success_DEFAULT *NodeBootstrappedResult_

func (p *NodeBootstrappedResult) GetSuccess() *NodeBootstrappedResult_ {
	if !p.IsSetSuccess() {
		return NodeBootstrappedResult_Success_DEFAULT
	}
	return p.Success
}

var NodeBootstrappedResult_Err_DEFAULT *Error

func (p *NodeBootstrappedResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeBootstrappedResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeBootstrappedResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeBootstrappedResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeBootstrappedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeBootstrappedResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeBootstrappedResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeBootstrappedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "bootstrapped_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeBootstrappedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeBootstrappedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedResult(%+v)", *p)
}

func (p *NodeBootstrappedResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedResult)(nil)

type NodeBootstrappedInPlacementOrNoPlacementArgs struct {
}

func NewNodeBootstrappedInPlacementOrNoPlacementArgs() *NodeBootstrappedInPlacementOrNoPlacementArgs {
	return &NodeBootstrappedInPlacementOrNoPlacementArgs{}
}

func (p *NodeBootstrappedInPlacementOrNoPlacementArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "bootstrappedInPlacementOrNoPlacement_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedInPlacementOrNoPlacementArgs(%+v)", *p)
}

func (p *NodeBootstrappedInPlacementOrNoPlacementArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedInPlacementOrNoPlacementArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedInPlacementOrNoPlacementArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeBootstrappedInPlacementOrNoPlacementResult struct {
	Success *NodeBootstrappedInPlacementOrNoPlacementResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeBootstrappedInPlacementOrNoPlacementResult() *NodeBootstrappedInPlacementOrNoPlacementResult {
	return &NodeBootstrappedInPlacementOrNoPlacementResult{}
}

var NodeBootstrappedInPlacementOrNoPlacementResult_Success_DEFAULT *NodeBootstrappedInPlacementOrNoPlacementResult_

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) GetSuccess() *NodeBootstrappedInPlacementOrNoPlacementResult_ {
	if !p.IsSetSuccess() {
		return NodeBootstrappedInPlacementOrNoPlacementResult_Success_DEFAULT
	}
	return p.Success
}

var NodeBootstrappedInPlacementOrNoPlacementResult_Err_DEFAULT *Error

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeBootstrappedInPlacementOrNoPlacementResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeBootstrappedInPlacementOrNoPlacementResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "bootstrappedInPlacementOrNoPlacement_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeBootstrappedInPlacementOrNoPlacementResult(%+v)", *p)
}

func (p *NodeBootstrappedInPlacementOrNoPlacementResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeBootstrappedInPlacementOrNoPlacementResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeBootstrappedInPlacementOrNoPlacementResult)(nil)

type NodeGetPersistRateLimitArgs struct {
}

func NewNodeGetPersistRateLimitArgs() *NodeGetPersistRateLimitArgs {
	return &NodeGetPersistRateLimitArgs{}
}

func (p *NodeGetPersistRateLimitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getPersistRateLimit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetPersistRateLimitArgs(%+v)", *p)
}

func (p *NodeGetPersistRateLimitArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetPersistRateLimitArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetPersistRateLimitArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeGetPersistRateLimitResult struct {
	Success *NodePersistRateLimitResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeGetPersistRateLimitResult() *NodeGetPersistRateLimitResult {
	return &NodeGetPersistRateLimitResult{}
}

var NodeGetPersistRateLimitResult_Success_DEFAULT *NodePersistRateLimitResult_

func (p *NodeGetPersistRateLimitResult) GetSuccess() *NodePersistRateLimitResult_ {
	if !p.IsSetSuccess() {
		return NodeGetPersistRateLimitResult_Success_DEFAULT
	}
	return p.Success
}

var NodeGetPersistRateLimitResult_Err_DEFAULT *Error

func (p *NodeGetPersistRateLimitResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeGetPersistRateLimitResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeGetPersistRateLimitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeGetPersistRateLimitResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeGetPersistRateLimitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodePersistRateLimitResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getPersistRateLimit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetPersistRateLimitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeGetPersistRateLimitResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeGetPersistRateLimitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetPersistRateLimitResult(%+v)", *p)
}

func (p *NodeGetPersistRateLimitResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetPersistRateLimitResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetPersistRateLimitResult)(nil)

// Attributes:
//  - Req
// 
type NodeSetPersistRateLimitArgs struct {
	Req *NodeSetPersistRateLimitRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeSetPersistRateLimitArgs() *NodeSetPersistRateLimitArgs {
	return &NodeSetPersistRateLimitArgs{}
}

var NodeSetPersistRateLimitArgs_Req_DEFAULT *NodeSetPersistRateLimitRequest

func (p *NodeSetPersistRateLimitArgs) GetReq() *NodeSetPersistRateLimitRequest {
	if !p.IsSetReq() {
		return NodeSetPersistRateLimitArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeSetPersistRateLimitArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeSetPersistRateLimitArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &NodeSetPersistRateLimitRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setPersistRateLimit_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeSetPersistRateLimitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetPersistRateLimitArgs(%+v)", *p)
}

func (p *NodeSetPersistRateLimitArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetPersistRateLimitArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetPersistRateLimitArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeSetPersistRateLimitResult struct {
	Success *NodePersistRateLimitResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeSetPersistRateLimitResult() *NodeSetPersistRateLimitResult {
	return &NodeSetPersistRateLimitResult{}
}

var NodeSetPersistRateLimitResult_Success_DEFAULT *NodePersistRateLimitResult_

func (p *NodeSetPersistRateLimitResult) GetSuccess() *NodePersistRateLimitResult_ {
	if !p.IsSetSuccess() {
		return NodeSetPersistRateLimitResult_Success_DEFAULT
	}
	return p.Success
}

var NodeSetPersistRateLimitResult_Err_DEFAULT *Error

func (p *NodeSetPersistRateLimitResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeSetPersistRateLimitResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeSetPersistRateLimitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeSetPersistRateLimitResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeSetPersistRateLimitResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodePersistRateLimitResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setPersistRateLimit_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetPersistRateLimitResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeSetPersistRateLimitResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeSetPersistRateLimitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetPersistRateLimitResult(%+v)", *p)
}

func (p *NodeSetPersistRateLimitResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetPersistRateLimitResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetPersistRateLimitResult)(nil)

type NodeGetWriteNewSeriesAsyncArgs struct {
}

func NewNodeGetWriteNewSeriesAsyncArgs() *NodeGetWriteNewSeriesAsyncArgs {
	return &NodeGetWriteNewSeriesAsyncArgs{}
}

func (p *NodeGetWriteNewSeriesAsyncArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesAsync_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesAsyncArgs(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesAsyncArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesAsyncArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesAsyncArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeGetWriteNewSeriesAsyncResult struct {
	Success *NodeWriteNewSeriesAsyncResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeGetWriteNewSeriesAsyncResult() *NodeGetWriteNewSeriesAsyncResult {
	return &NodeGetWriteNewSeriesAsyncResult{}
}

var NodeGetWriteNewSeriesAsyncResult_Success_DEFAULT *NodeWriteNewSeriesAsyncResult_

func (p *NodeGetWriteNewSeriesAsyncResult) GetSuccess() *NodeWriteNewSeriesAsyncResult_ {
	if !p.IsSetSuccess() {
		return NodeGetWriteNewSeriesAsyncResult_Success_DEFAULT
	}
	return p.Success
}

var NodeGetWriteNewSeriesAsyncResult_Err_DEFAULT *Error

func (p *NodeGetWriteNewSeriesAsyncResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeGetWriteNewSeriesAsyncResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeGetWriteNewSeriesAsyncResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesAsyncResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesAsync_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesAsyncResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesAsyncResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesAsyncResult(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesAsyncResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesAsyncResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesAsyncResult)(nil)

// Attributes:
//  - Req
// 
type NodeSetWriteNewSeriesAsyncArgs struct {
	Req *NodeSetWriteNewSeriesAsyncRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeSetWriteNewSeriesAsyncArgs() *NodeSetWriteNewSeriesAsyncArgs {
	return &NodeSetWriteNewSeriesAsyncArgs{}
}

var NodeSetWriteNewSeriesAsyncArgs_Req_DEFAULT *NodeSetWriteNewSeriesAsyncRequest

func (p *NodeSetWriteNewSeriesAsyncArgs) GetReq() *NodeSetWriteNewSeriesAsyncRequest {
	if !p.IsSetReq() {
		return NodeSetWriteNewSeriesAsyncArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeSetWriteNewSeriesAsyncArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeSetWriteNewSeriesAsyncArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &NodeSetWriteNewSeriesAsyncRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesAsync_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesAsyncArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesAsyncArgs(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesAsyncArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesAsyncArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesAsyncArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeSetWriteNewSeriesAsyncResult struct {
	Success *NodeWriteNewSeriesAsyncResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeSetWriteNewSeriesAsyncResult() *NodeSetWriteNewSeriesAsyncResult {
	return &NodeSetWriteNewSeriesAsyncResult{}
}

var NodeSetWriteNewSeriesAsyncResult_Success_DEFAULT *NodeWriteNewSeriesAsyncResult_

func (p *NodeSetWriteNewSeriesAsyncResult) GetSuccess() *NodeWriteNewSeriesAsyncResult_ {
	if !p.IsSetSuccess() {
		return NodeSetWriteNewSeriesAsyncResult_Success_DEFAULT
	}
	return p.Success
}

var NodeSetWriteNewSeriesAsyncResult_Err_DEFAULT *Error

func (p *NodeSetWriteNewSeriesAsyncResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeSetWriteNewSeriesAsyncResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeSetWriteNewSeriesAsyncResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesAsyncResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesAsync_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesAsyncResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesAsyncResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesAsyncResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesAsyncResult(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesAsyncResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesAsyncResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesAsyncResult)(nil)

type NodeGetWriteNewSeriesBackoffDurationArgs struct {
}

func NewNodeGetWriteNewSeriesBackoffDurationArgs() *NodeGetWriteNewSeriesBackoffDurationArgs {
	return &NodeGetWriteNewSeriesBackoffDurationArgs{}
}

func (p *NodeGetWriteNewSeriesBackoffDurationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesBackoffDuration_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesBackoffDurationArgs(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesBackoffDurationArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesBackoffDurationArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesBackoffDurationArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeGetWriteNewSeriesBackoffDurationResult struct {
	Success *NodeWriteNewSeriesBackoffDurationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeGetWriteNewSeriesBackoffDurationResult() *NodeGetWriteNewSeriesBackoffDurationResult {
	return &NodeGetWriteNewSeriesBackoffDurationResult{}
}

var NodeGetWriteNewSeriesBackoffDurationResult_Success_DEFAULT *NodeWriteNewSeriesBackoffDurationResult_

func (p *NodeGetWriteNewSeriesBackoffDurationResult) GetSuccess() *NodeWriteNewSeriesBackoffDurationResult_ {
	if !p.IsSetSuccess() {
		return NodeGetWriteNewSeriesBackoffDurationResult_Success_DEFAULT
	}
	return p.Success
}

var NodeGetWriteNewSeriesBackoffDurationResult_Err_DEFAULT *Error

func (p *NodeGetWriteNewSeriesBackoffDurationResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeGetWriteNewSeriesBackoffDurationResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesBackoffDurationResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesBackoffDuration_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesBackoffDurationResult(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesBackoffDurationResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesBackoffDurationResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesBackoffDurationResult)(nil)

// Attributes:
//  - Req
// 
type NodeSetWriteNewSeriesBackoffDurationArgs struct {
	Req *NodeSetWriteNewSeriesBackoffDurationRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeSetWriteNewSeriesBackoffDurationArgs() *NodeSetWriteNewSeriesBackoffDurationArgs {
	return &NodeSetWriteNewSeriesBackoffDurationArgs{}
}

var NodeSetWriteNewSeriesBackoffDurationArgs_Req_DEFAULT *NodeSetWriteNewSeriesBackoffDurationRequest

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) GetReq() *NodeSetWriteNewSeriesBackoffDurationRequest {
	if !p.IsSetReq() {
		return NodeSetWriteNewSeriesBackoffDurationArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &NodeSetWriteNewSeriesBackoffDurationRequest{
		DurationType: 2,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesBackoffDuration_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesBackoffDurationArgs(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesBackoffDurationArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesBackoffDurationArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesBackoffDurationArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeSetWriteNewSeriesBackoffDurationResult struct {
	Success *NodeWriteNewSeriesBackoffDurationResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeSetWriteNewSeriesBackoffDurationResult() *NodeSetWriteNewSeriesBackoffDurationResult {
	return &NodeSetWriteNewSeriesBackoffDurationResult{}
}

var NodeSetWriteNewSeriesBackoffDurationResult_Success_DEFAULT *NodeWriteNewSeriesBackoffDurationResult_

func (p *NodeSetWriteNewSeriesBackoffDurationResult) GetSuccess() *NodeWriteNewSeriesBackoffDurationResult_ {
	if !p.IsSetSuccess() {
		return NodeSetWriteNewSeriesBackoffDurationResult_Success_DEFAULT
	}
	return p.Success
}

var NodeSetWriteNewSeriesBackoffDurationResult_Err_DEFAULT *Error

func (p *NodeSetWriteNewSeriesBackoffDurationResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeSetWriteNewSeriesBackoffDurationResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesBackoffDurationResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesBackoffDuration_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesBackoffDurationResult(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesBackoffDurationResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesBackoffDurationResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesBackoffDurationResult)(nil)

type NodeGetWriteNewSeriesLimitPerShardPerSecondArgs struct {
}

func NewNodeGetWriteNewSeriesLimitPerShardPerSecondArgs() *NodeGetWriteNewSeriesLimitPerShardPerSecondArgs {
	return &NodeGetWriteNewSeriesLimitPerShardPerSecondArgs{}
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesLimitPerShardPerSecond_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesLimitPerShardPerSecondArgs(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesLimitPerShardPerSecondArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesLimitPerShardPerSecondArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeGetWriteNewSeriesLimitPerShardPerSecondResult struct {
	Success *NodeWriteNewSeriesLimitPerShardPerSecondResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeGetWriteNewSeriesLimitPerShardPerSecondResult() *NodeGetWriteNewSeriesLimitPerShardPerSecondResult {
	return &NodeGetWriteNewSeriesLimitPerShardPerSecondResult{}
}

var NodeGetWriteNewSeriesLimitPerShardPerSecondResult_Success_DEFAULT *NodeWriteNewSeriesLimitPerShardPerSecondResult_

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) GetSuccess() *NodeWriteNewSeriesLimitPerShardPerSecondResult_ {
	if !p.IsSetSuccess() {
		return NodeGetWriteNewSeriesLimitPerShardPerSecondResult_Success_DEFAULT
	}
	return p.Success
}

var NodeGetWriteNewSeriesLimitPerShardPerSecondResult_Err_DEFAULT *Error

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeGetWriteNewSeriesLimitPerShardPerSecondResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesLimitPerShardPerSecondResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "getWriteNewSeriesLimitPerShardPerSecond_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeGetWriteNewSeriesLimitPerShardPerSecondResult(%+v)", *p)
}

func (p *NodeGetWriteNewSeriesLimitPerShardPerSecondResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeGetWriteNewSeriesLimitPerShardPerSecondResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeGetWriteNewSeriesLimitPerShardPerSecondResult)(nil)

// Attributes:
//  - Req
// 
type NodeSetWriteNewSeriesLimitPerShardPerSecondArgs struct {
	Req *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeSetWriteNewSeriesLimitPerShardPerSecondArgs() *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs {
	return &NodeSetWriteNewSeriesLimitPerShardPerSecondArgs{}
}

var NodeSetWriteNewSeriesLimitPerShardPerSecondArgs_Req_DEFAULT *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) GetReq() *NodeSetWriteNewSeriesLimitPerShardPerSecondRequest {
	if !p.IsSetReq() {
		return NodeSetWriteNewSeriesLimitPerShardPerSecondArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &NodeSetWriteNewSeriesLimitPerShardPerSecondRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesLimitPerShardPerSecond_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesLimitPerShardPerSecondArgs(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesLimitPerShardPerSecondArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesLimitPerShardPerSecondArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeSetWriteNewSeriesLimitPerShardPerSecondResult struct {
	Success *NodeWriteNewSeriesLimitPerShardPerSecondResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeSetWriteNewSeriesLimitPerShardPerSecondResult() *NodeSetWriteNewSeriesLimitPerShardPerSecondResult {
	return &NodeSetWriteNewSeriesLimitPerShardPerSecondResult{}
}

var NodeSetWriteNewSeriesLimitPerShardPerSecondResult_Success_DEFAULT *NodeWriteNewSeriesLimitPerShardPerSecondResult_

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) GetSuccess() *NodeWriteNewSeriesLimitPerShardPerSecondResult_ {
	if !p.IsSetSuccess() {
		return NodeSetWriteNewSeriesLimitPerShardPerSecondResult_Success_DEFAULT
	}
	return p.Success
}

var NodeSetWriteNewSeriesLimitPerShardPerSecondResult_Err_DEFAULT *Error

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeSetWriteNewSeriesLimitPerShardPerSecondResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &NodeWriteNewSeriesLimitPerShardPerSecondResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "setWriteNewSeriesLimitPerShardPerSecond_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeSetWriteNewSeriesLimitPerShardPerSecondResult(%+v)", *p)
}

func (p *NodeSetWriteNewSeriesLimitPerShardPerSecondResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeSetWriteNewSeriesLimitPerShardPerSecondResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeSetWriteNewSeriesLimitPerShardPerSecondResult)(nil)

// Attributes:
//  - Req
// 
type NodeDebugProfileStartArgs struct {
	Req *DebugProfileStartRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeDebugProfileStartArgs() *NodeDebugProfileStartArgs {
	return &NodeDebugProfileStartArgs{}
}

var NodeDebugProfileStartArgs_Req_DEFAULT *DebugProfileStartRequest

func (p *NodeDebugProfileStartArgs) GetReq() *DebugProfileStartRequest {
	if !p.IsSetReq() {
		return NodeDebugProfileStartArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeDebugProfileStartArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeDebugProfileStartArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugProfileStartArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &DebugProfileStartRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeDebugProfileStartArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugProfileStart_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugProfileStartArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeDebugProfileStartArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugProfileStartArgs(%+v)", *p)
}

func (p *NodeDebugProfileStartArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugProfileStartArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugProfileStartArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeDebugProfileStartResult struct {
	Success *DebugProfileStartResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeDebugProfileStartResult() *NodeDebugProfileStartResult {
	return &NodeDebugProfileStartResult{}
}

var NodeDebugProfileStartResult_Success_DEFAULT *DebugProfileStartResult_

func (p *NodeDebugProfileStartResult) GetSuccess() *DebugProfileStartResult_ {
	if !p.IsSetSuccess() {
		return NodeDebugProfileStartResult_Success_DEFAULT
	}
	return p.Success
}

var NodeDebugProfileStartResult_Err_DEFAULT *Error

func (p *NodeDebugProfileStartResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeDebugProfileStartResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeDebugProfileStartResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeDebugProfileStartResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeDebugProfileStartResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugProfileStartResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &DebugProfileStartResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeDebugProfileStartResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeDebugProfileStartResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugProfileStart_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugProfileStartResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugProfileStartResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugProfileStartResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugProfileStartResult(%+v)", *p)
}

func (p *NodeDebugProfileStartResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugProfileStartResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugProfileStartResult)(nil)

// Attributes:
//  - Req
// 
type NodeDebugProfileStopArgs struct {
	Req *DebugProfileStopRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeDebugProfileStopArgs() *NodeDebugProfileStopArgs {
	return &NodeDebugProfileStopArgs{}
}

var NodeDebugProfileStopArgs_Req_DEFAULT *DebugProfileStopRequest

func (p *NodeDebugProfileStopArgs) GetReq() *DebugProfileStopRequest {
	if !p.IsSetReq() {
		return NodeDebugProfileStopArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeDebugProfileStopArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeDebugProfileStopArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugProfileStopArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &DebugProfileStopRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeDebugProfileStopArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugProfileStop_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugProfileStopArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeDebugProfileStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugProfileStopArgs(%+v)", *p)
}

func (p *NodeDebugProfileStopArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugProfileStopArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugProfileStopArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeDebugProfileStopResult struct {
	Success *DebugProfileStopResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeDebugProfileStopResult() *NodeDebugProfileStopResult {
	return &NodeDebugProfileStopResult{}
}

var NodeDebugProfileStopResult_Success_DEFAULT *DebugProfileStopResult_

func (p *NodeDebugProfileStopResult) GetSuccess() *DebugProfileStopResult_ {
	if !p.IsSetSuccess() {
		return NodeDebugProfileStopResult_Success_DEFAULT
	}
	return p.Success
}

var NodeDebugProfileStopResult_Err_DEFAULT *Error

func (p *NodeDebugProfileStopResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeDebugProfileStopResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeDebugProfileStopResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeDebugProfileStopResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeDebugProfileStopResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugProfileStopResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &DebugProfileStopResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeDebugProfileStopResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeDebugProfileStopResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugProfileStop_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugProfileStopResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugProfileStopResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugProfileStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugProfileStopResult(%+v)", *p)
}

func (p *NodeDebugProfileStopResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugProfileStopResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugProfileStopResult)(nil)

// Attributes:
//  - Req
// 
type NodeDebugIndexMemorySegmentsArgs struct {
	Req *DebugIndexMemorySegmentsRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewNodeDebugIndexMemorySegmentsArgs() *NodeDebugIndexMemorySegmentsArgs {
	return &NodeDebugIndexMemorySegmentsArgs{}
}

var NodeDebugIndexMemorySegmentsArgs_Req_DEFAULT *DebugIndexMemorySegmentsRequest

func (p *NodeDebugIndexMemorySegmentsArgs) GetReq() *DebugIndexMemorySegmentsRequest {
	if !p.IsSetReq() {
		return NodeDebugIndexMemorySegmentsArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *NodeDebugIndexMemorySegmentsArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *NodeDebugIndexMemorySegmentsArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &DebugIndexMemorySegmentsRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugIndexMemorySegments_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *NodeDebugIndexMemorySegmentsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugIndexMemorySegmentsArgs(%+v)", *p)
}

func (p *NodeDebugIndexMemorySegmentsArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugIndexMemorySegmentsArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugIndexMemorySegmentsArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type NodeDebugIndexMemorySegmentsResult struct {
	Success *DebugIndexMemorySegmentsResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewNodeDebugIndexMemorySegmentsResult() *NodeDebugIndexMemorySegmentsResult {
	return &NodeDebugIndexMemorySegmentsResult{}
}

var NodeDebugIndexMemorySegmentsResult_Success_DEFAULT *DebugIndexMemorySegmentsResult_

func (p *NodeDebugIndexMemorySegmentsResult) GetSuccess() *DebugIndexMemorySegmentsResult_ {
	if !p.IsSetSuccess() {
		return NodeDebugIndexMemorySegmentsResult_Success_DEFAULT
	}
	return p.Success
}

var NodeDebugIndexMemorySegmentsResult_Err_DEFAULT *Error

func (p *NodeDebugIndexMemorySegmentsResult) GetErr() *Error {
	if !p.IsSetErr() {
		return NodeDebugIndexMemorySegmentsResult_Err_DEFAULT
	}
	return p.Err
}

func (p *NodeDebugIndexMemorySegmentsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *NodeDebugIndexMemorySegmentsResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *NodeDebugIndexMemorySegmentsResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &DebugIndexMemorySegmentsResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "debugIndexMemorySegments_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *NodeDebugIndexMemorySegmentsResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugIndexMemorySegmentsResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *NodeDebugIndexMemorySegmentsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NodeDebugIndexMemorySegmentsResult(%+v)", *p)
}

func (p *NodeDebugIndexMemorySegmentsResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.NodeDebugIndexMemorySegmentsResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*NodeDebugIndexMemorySegmentsResult)(nil)


type Cluster interface {
	Health(ctx context.Context) (_r *HealthResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Write(ctx context.Context, req *WriteRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	WriteTagged(ctx context.Context, req *WriteTaggedRequest) (_err error)
	// Parameters:
	//  - Req
	// 
	Query(ctx context.Context, req *QueryRequest) (_r *QueryResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Aggregate(ctx context.Context, req *AggregateQueryRequest) (_r *AggregateQueryResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Fetch(ctx context.Context, req *FetchRequest) (_r *FetchResult_, _err error)
	// Parameters:
	//  - Req
	// 
	Truncate(ctx context.Context, req *TruncateRequest) (_r *TruncateResult_, _err error)
}

type ClusterClient struct {
	c thrift.TClient
	meta thrift.ResponseMeta
}

func NewClusterClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *ClusterClient {
	return &ClusterClient{
		c: thrift.NewTStandardClient(f.GetProtocol(t), f.GetProtocol(t)),
	}
}

func NewClusterClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *ClusterClient {
	return &ClusterClient{
		c: thrift.NewTStandardClient(iprot, oprot),
	}
}

func NewClusterClient(c thrift.TClient) *ClusterClient {
	return &ClusterClient{
		c: c,
	}
}

func (p *ClusterClient) Client_() thrift.TClient {
	return p.c
}

func (p *ClusterClient) LastResponseMeta_() thrift.ResponseMeta {
	return p.meta
}

func (p *ClusterClient) SetLastResponseMeta_(meta thrift.ResponseMeta) {
	p.meta = meta
}

func (p *ClusterClient) Health(ctx context.Context) (_r *HealthResult_, _err error) {
	var _args375 ClusterHealthArgs
	var _result377 ClusterHealthResult
	var _meta376 thrift.ResponseMeta
	_meta376, _err = p.Client_().Call(ctx, "health", &_args375, &_result377)
	p.SetLastResponseMeta_(_meta376)
	if _err != nil {
		return
	}
	switch {
	case _result377.Err!= nil:
		return _r, _result377.Err
	}

	return _result377.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) Write(ctx context.Context, req *WriteRequest) (_err error) {
	var _args378 ClusterWriteArgs
	_args378.Req = req
	var _result380 ClusterWriteResult
	var _meta379 thrift.ResponseMeta
	_meta379, _err = p.Client_().Call(ctx, "write", &_args378, &_result380)
	p.SetLastResponseMeta_(_meta379)
	if _err != nil {
		return
	}
	switch {
	case _result380.Err!= nil:
		return _result380.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) WriteTagged(ctx context.Context, req *WriteTaggedRequest) (_err error) {
	var _args381 ClusterWriteTaggedArgs
	_args381.Req = req
	var _result383 ClusterWriteTaggedResult
	var _meta382 thrift.ResponseMeta
	_meta382, _err = p.Client_().Call(ctx, "writeTagged", &_args381, &_result383)
	p.SetLastResponseMeta_(_meta382)
	if _err != nil {
		return
	}
	switch {
	case _result383.Err!= nil:
		return _result383.Err
	}

	return nil
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) Query(ctx context.Context, req *QueryRequest) (_r *QueryResult_, _err error) {
	var _args384 ClusterQueryArgs
	_args384.Req = req
	var _result386 ClusterQueryResult
	var _meta385 thrift.ResponseMeta
	_meta385, _err = p.Client_().Call(ctx, "query", &_args384, &_result386)
	p.SetLastResponseMeta_(_meta385)
	if _err != nil {
		return
	}
	switch {
	case _result386.Err!= nil:
		return _r, _result386.Err
	}

	return _result386.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) Aggregate(ctx context.Context, req *AggregateQueryRequest) (_r *AggregateQueryResult_, _err error) {
	var _args387 ClusterAggregateArgs
	_args387.Req = req
	var _result389 ClusterAggregateResult
	var _meta388 thrift.ResponseMeta
	_meta388, _err = p.Client_().Call(ctx, "aggregate", &_args387, &_result389)
	p.SetLastResponseMeta_(_meta388)
	if _err != nil {
		return
	}
	switch {
	case _result389.Err!= nil:
		return _r, _result389.Err
	}

	return _result389.GetSuccess(), nil
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) Fetch(ctx context.Context, req *FetchRequest) (_r *FetchResult_, _err error) {
	var _args390 ClusterFetchArgs
	_args390.Req = req
	var _result392 ClusterFetchResult
	var _meta391 thrift.ResponseMeta
	_meta391, _err = p.Client_().Call(ctx, "fetch", &_args390, &_result392)
	p.SetLastResponseMeta_(_meta391)
	if _err != nil {
		return
	}
	switch {
	case _result392.Err!= nil:
		return _r, _result392.Err
	}

	if _ret393 := _result392.GetSuccess(); _ret393 != nil {
		return _ret393, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "fetch failed: unknown result")
}

// Parameters:
//  - Req
// 
func (p *ClusterClient) Truncate(ctx context.Context, req *TruncateRequest) (_r *TruncateResult_, _err error) {
	var _args394 ClusterTruncateArgs
	_args394.Req = req
	var _result396 ClusterTruncateResult
	var _meta395 thrift.ResponseMeta
	_meta395, _err = p.Client_().Call(ctx, "truncate", &_args394, &_result396)
	p.SetLastResponseMeta_(_meta395)
	if _err != nil {
		return
	}
	switch {
	case _result396.Err!= nil:
		return _r, _result396.Err
	}

	if _ret397 := _result396.GetSuccess(); _ret397 != nil {
		return _ret397, nil
	}
	return nil, thrift.NewTApplicationException(thrift.MISSING_RESULT, "truncate failed: unknown result")
}

type ClusterProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler Cluster
}

func (p *ClusterProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *ClusterProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *ClusterProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewClusterProcessor(handler Cluster) *ClusterProcessor {

	self398 := &ClusterProcessor{handler:handler, processorMap:make(map[string]thrift.TProcessorFunction)}
	self398.processorMap["health"] = &clusterProcessorHealth{handler:handler}
	self398.processorMap["write"] = &clusterProcessorWrite{handler:handler}
	self398.processorMap["writeTagged"] = &clusterProcessorWriteTagged{handler:handler}
	self398.processorMap["query"] = &clusterProcessorQuery{handler:handler}
	self398.processorMap["aggregate"] = &clusterProcessorAggregate{handler:handler}
	self398.processorMap["fetch"] = &clusterProcessorFetch{handler:handler}
	self398.processorMap["truncate"] = &clusterProcessorTruncate{handler:handler}
	return self398
}

func (p *ClusterProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err2 := iprot.ReadMessageBegin(ctx)
	if err2 != nil { return false, thrift.WrapTException(err2) }
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(ctx, thrift.STRUCT)
	iprot.ReadMessageEnd(ctx)
	x399 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function " + name)
	oprot.WriteMessageBegin(ctx, name, thrift.EXCEPTION, seqId)
	x399.Write(ctx, oprot)
	oprot.WriteMessageEnd(ctx)
	oprot.Flush(ctx)
	return false, x399
}

type clusterProcessorHealth struct {
	handler Cluster
}

func (p *clusterProcessorHealth) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err400 error
	args := ClusterHealthArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "health", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterHealthResult{}
	if retval, err2 := p.handler.Health(ctx); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc401 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing health: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "health", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err400 = thrift.WrapTException(err2)
			}
			if err2 := _exc401.Write(ctx, oprot); _write_err400 == nil && err2 != nil {
				_write_err400 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err400 == nil && err2 != nil {
				_write_err400 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err400 == nil && err2 != nil {
				_write_err400 = thrift.WrapTException(err2)
			}
			if _write_err400 != nil {
				return false, thrift.WrapTException(_write_err400)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "health", thrift.REPLY, seqId); err2 != nil {
		_write_err400 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err400 == nil && err2 != nil {
		_write_err400 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err400 == nil && err2 != nil {
		_write_err400 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err400 == nil && err2 != nil {
		_write_err400 = thrift.WrapTException(err2)
	}
	if _write_err400 != nil {
		return false, thrift.WrapTException(_write_err400)
	}
	return true, err
}

type clusterProcessorWrite struct {
	handler Cluster
}

func (p *clusterProcessorWrite) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err402 error
	args := ClusterWriteArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "write", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterWriteResult{}
	if err2 := p.handler.Write(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc403 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing write: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "write", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err402 = thrift.WrapTException(err2)
			}
			if err2 := _exc403.Write(ctx, oprot); _write_err402 == nil && err2 != nil {
				_write_err402 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err402 == nil && err2 != nil {
				_write_err402 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err402 == nil && err2 != nil {
				_write_err402 = thrift.WrapTException(err2)
			}
			if _write_err402 != nil {
				return false, thrift.WrapTException(_write_err402)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "write", thrift.REPLY, seqId); err2 != nil {
		_write_err402 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err402 == nil && err2 != nil {
		_write_err402 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err402 == nil && err2 != nil {
		_write_err402 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err402 == nil && err2 != nil {
		_write_err402 = thrift.WrapTException(err2)
	}
	if _write_err402 != nil {
		return false, thrift.WrapTException(_write_err402)
	}
	return true, err
}

type clusterProcessorWriteTagged struct {
	handler Cluster
}

func (p *clusterProcessorWriteTagged) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err404 error
	args := ClusterWriteTaggedArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "writeTagged", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterWriteTaggedResult{}
	if err2 := p.handler.WriteTagged(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc405 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing writeTagged: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "writeTagged", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err404 = thrift.WrapTException(err2)
			}
			if err2 := _exc405.Write(ctx, oprot); _write_err404 == nil && err2 != nil {
				_write_err404 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err404 == nil && err2 != nil {
				_write_err404 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err404 == nil && err2 != nil {
				_write_err404 = thrift.WrapTException(err2)
			}
			if _write_err404 != nil {
				return false, thrift.WrapTException(_write_err404)
			}
			return true, err
		}
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "writeTagged", thrift.REPLY, seqId); err2 != nil {
		_write_err404 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err404 == nil && err2 != nil {
		_write_err404 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err404 == nil && err2 != nil {
		_write_err404 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err404 == nil && err2 != nil {
		_write_err404 = thrift.WrapTException(err2)
	}
	if _write_err404 != nil {
		return false, thrift.WrapTException(_write_err404)
	}
	return true, err
}

type clusterProcessorQuery struct {
	handler Cluster
}

func (p *clusterProcessorQuery) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err406 error
	args := ClusterQueryArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "query", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterQueryResult{}
	if retval, err2 := p.handler.Query(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc407 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing query: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "query", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err406 = thrift.WrapTException(err2)
			}
			if err2 := _exc407.Write(ctx, oprot); _write_err406 == nil && err2 != nil {
				_write_err406 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err406 == nil && err2 != nil {
				_write_err406 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err406 == nil && err2 != nil {
				_write_err406 = thrift.WrapTException(err2)
			}
			if _write_err406 != nil {
				return false, thrift.WrapTException(_write_err406)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "query", thrift.REPLY, seqId); err2 != nil {
		_write_err406 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err406 == nil && err2 != nil {
		_write_err406 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err406 == nil && err2 != nil {
		_write_err406 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err406 == nil && err2 != nil {
		_write_err406 = thrift.WrapTException(err2)
	}
	if _write_err406 != nil {
		return false, thrift.WrapTException(_write_err406)
	}
	return true, err
}

type clusterProcessorAggregate struct {
	handler Cluster
}

func (p *clusterProcessorAggregate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err408 error
	args := ClusterAggregateArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "aggregate", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterAggregateResult{}
	if retval, err2 := p.handler.Aggregate(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc409 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing aggregate: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "aggregate", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err408 = thrift.WrapTException(err2)
			}
			if err2 := _exc409.Write(ctx, oprot); _write_err408 == nil && err2 != nil {
				_write_err408 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err408 == nil && err2 != nil {
				_write_err408 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err408 == nil && err2 != nil {
				_write_err408 = thrift.WrapTException(err2)
			}
			if _write_err408 != nil {
				return false, thrift.WrapTException(_write_err408)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "aggregate", thrift.REPLY, seqId); err2 != nil {
		_write_err408 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err408 == nil && err2 != nil {
		_write_err408 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err408 == nil && err2 != nil {
		_write_err408 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err408 == nil && err2 != nil {
		_write_err408 = thrift.WrapTException(err2)
	}
	if _write_err408 != nil {
		return false, thrift.WrapTException(_write_err408)
	}
	return true, err
}

type clusterProcessorFetch struct {
	handler Cluster
}

func (p *clusterProcessorFetch) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err410 error
	args := ClusterFetchArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "fetch", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterFetchResult{}
	if retval, err2 := p.handler.Fetch(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc411 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetch: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "fetch", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err410 = thrift.WrapTException(err2)
			}
			if err2 := _exc411.Write(ctx, oprot); _write_err410 == nil && err2 != nil {
				_write_err410 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err410 == nil && err2 != nil {
				_write_err410 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err410 == nil && err2 != nil {
				_write_err410 = thrift.WrapTException(err2)
			}
			if _write_err410 != nil {
				return false, thrift.WrapTException(_write_err410)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "fetch", thrift.REPLY, seqId); err2 != nil {
		_write_err410 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err410 == nil && err2 != nil {
		_write_err410 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err410 == nil && err2 != nil {
		_write_err410 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err410 == nil && err2 != nil {
		_write_err410 = thrift.WrapTException(err2)
	}
	if _write_err410 != nil {
		return false, thrift.WrapTException(_write_err410)
	}
	return true, err
}

type clusterProcessorTruncate struct {
	handler Cluster
}

func (p *clusterProcessorTruncate) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	var _write_err412 error
	args := ClusterTruncateArgs{}
	if err2 := args.Read(ctx, iprot); err2 != nil {
		iprot.ReadMessageEnd(ctx)
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err2.Error())
		oprot.WriteMessageBegin(ctx, "truncate", thrift.EXCEPTION, seqId)
		x.Write(ctx, oprot)
		oprot.WriteMessageEnd(ctx)
		oprot.Flush(ctx)
		return false, thrift.WrapTException(err2)
	}
	iprot.ReadMessageEnd(ctx)

	tickerCancel := func() {}
	// Start a goroutine to do server side connectivity check.
	if thrift.ServerConnectivityCheckInterval > 0 {
		var cancel context.CancelCauseFunc
		ctx, cancel = context.WithCancelCause(ctx)
		defer cancel(nil)
		var tickerCtx context.Context
		tickerCtx, tickerCancel = context.WithCancel(context.Background())
		defer tickerCancel()
		go func(ctx context.Context, cancel context.CancelCauseFunc) {
			ticker := time.NewTicker(thrift.ServerConnectivityCheckInterval)
			defer ticker.Stop()
			for {
				select {
				case <-ctx.Done():
					return
				case <-ticker.C:
					if !iprot.Transport().IsOpen() {
						cancel(thrift.ErrAbandonRequest)
						return
					}
				}
			}
		}(tickerCtx, cancel)
	}

	result := ClusterTruncateResult{}
	if retval, err2 := p.handler.Truncate(ctx, args.Req); err2 != nil {
		tickerCancel()
		err = thrift.WrapTException(err2)
		switch v := err2.(type) {
		case *Error:
			result.Err = v
		default:
			if errors.Is(err2, thrift.ErrAbandonRequest) {
				return false, thrift.WrapTException(err2)
			}
			if errors.Is(err2, context.Canceled) {
				if err := context.Cause(ctx); errors.Is(err, thrift.ErrAbandonRequest) {
					return false, thrift.WrapTException(err)
				}
			}
			_exc413 := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: " + err2.Error())
			if err2 := oprot.WriteMessageBegin(ctx, "truncate", thrift.EXCEPTION, seqId); err2 != nil {
				_write_err412 = thrift.WrapTException(err2)
			}
			if err2 := _exc413.Write(ctx, oprot); _write_err412 == nil && err2 != nil {
				_write_err412 = thrift.WrapTException(err2)
			}
			if err2 := oprot.WriteMessageEnd(ctx); _write_err412 == nil && err2 != nil {
				_write_err412 = thrift.WrapTException(err2)
			}
			if err2 := oprot.Flush(ctx); _write_err412 == nil && err2 != nil {
				_write_err412 = thrift.WrapTException(err2)
			}
			if _write_err412 != nil {
				return false, thrift.WrapTException(_write_err412)
			}
			return true, err
		}
	} else {
		result.Success = retval
	}
	tickerCancel()
	if err2 := oprot.WriteMessageBegin(ctx, "truncate", thrift.REPLY, seqId); err2 != nil {
		_write_err412 = thrift.WrapTException(err2)
	}
	if err2 := result.Write(ctx, oprot); _write_err412 == nil && err2 != nil {
		_write_err412 = thrift.WrapTException(err2)
	}
	if err2 := oprot.WriteMessageEnd(ctx); _write_err412 == nil && err2 != nil {
		_write_err412 = thrift.WrapTException(err2)
	}
	if err2 := oprot.Flush(ctx); _write_err412 == nil && err2 != nil {
		_write_err412 = thrift.WrapTException(err2)
	}
	if _write_err412 != nil {
		return false, thrift.WrapTException(_write_err412)
	}
	return true, err
}


// HELPER FUNCTIONS AND STRUCTURES

type ClusterHealthArgs struct {
}

func NewClusterHealthArgs() *ClusterHealthArgs {
	return &ClusterHealthArgs{}
}

func (p *ClusterHealthArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(ctx, fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterHealthArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "health_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterHealthArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterHealthArgs(%+v)", *p)
}

func (p *ClusterHealthArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterHealthArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterHealthArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type ClusterHealthResult struct {
	Success *HealthResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterHealthResult() *ClusterHealthResult {
	return &ClusterHealthResult{}
}

var ClusterHealthResult_Success_DEFAULT *HealthResult_

func (p *ClusterHealthResult) GetSuccess() *HealthResult_ {
	if !p.IsSetSuccess() {
		return ClusterHealthResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterHealthResult_Err_DEFAULT *Error

func (p *ClusterHealthResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterHealthResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterHealthResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterHealthResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterHealthResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterHealthResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &HealthResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterHealthResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterHealthResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "health_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterHealthResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterHealthResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterHealthResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterHealthResult(%+v)", *p)
}

func (p *ClusterHealthResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterHealthResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterHealthResult)(nil)

// Attributes:
//  - Req
// 
type ClusterWriteArgs struct {
	Req *WriteRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterWriteArgs() *ClusterWriteArgs {
	return &ClusterWriteArgs{}
}

var ClusterWriteArgs_Req_DEFAULT *WriteRequest

func (p *ClusterWriteArgs) GetReq() *WriteRequest {
	if !p.IsSetReq() {
		return ClusterWriteArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterWriteArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterWriteArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterWriteArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "write_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterWriteArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteArgs(%+v)", *p)
}

func (p *ClusterWriteArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterWriteArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterWriteArgs)(nil)

// Attributes:
//  - Err
// 
type ClusterWriteResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterWriteResult() *ClusterWriteResult {
	return &ClusterWriteResult{}
}

var ClusterWriteResult_Err_DEFAULT *Error

func (p *ClusterWriteResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterWriteResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterWriteResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterWriteResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterWriteResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "write_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterWriteResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteResult(%+v)", *p)
}

func (p *ClusterWriteResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterWriteResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterWriteResult)(nil)

// Attributes:
//  - Req
// 
type ClusterWriteTaggedArgs struct {
	Req *WriteTaggedRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterWriteTaggedArgs() *ClusterWriteTaggedArgs {
	return &ClusterWriteTaggedArgs{}
}

var ClusterWriteTaggedArgs_Req_DEFAULT *WriteTaggedRequest

func (p *ClusterWriteTaggedArgs) GetReq() *WriteTaggedRequest {
	if !p.IsSetReq() {
		return ClusterWriteTaggedArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterWriteTaggedArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterWriteTaggedArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteTaggedArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &WriteTaggedRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterWriteTaggedArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTagged_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteTaggedArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterWriteTaggedArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteTaggedArgs(%+v)", *p)
}

func (p *ClusterWriteTaggedArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterWriteTaggedArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterWriteTaggedArgs)(nil)

// Attributes:
//  - Err
// 
type ClusterWriteTaggedResult struct {
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterWriteTaggedResult() *ClusterWriteTaggedResult {
	return &ClusterWriteTaggedResult{}
}

var ClusterWriteTaggedResult_Err_DEFAULT *Error

func (p *ClusterWriteTaggedResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterWriteTaggedResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterWriteTaggedResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterWriteTaggedResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterWriteTaggedResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterWriteTaggedResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "writeTagged_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterWriteTaggedResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterWriteTaggedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterWriteTaggedResult(%+v)", *p)
}

func (p *ClusterWriteTaggedResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterWriteTaggedResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterWriteTaggedResult)(nil)

// Attributes:
//  - Req
// 
type ClusterQueryArgs struct {
	Req *QueryRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterQueryArgs() *ClusterQueryArgs {
	return &ClusterQueryArgs{}
}

var ClusterQueryArgs_Req_DEFAULT *QueryRequest

func (p *ClusterQueryArgs) GetReq() *QueryRequest {
	if !p.IsSetReq() {
		return ClusterQueryArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterQueryArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterQueryArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterQueryArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &QueryRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterQueryArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "query_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterQueryArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterQueryArgs(%+v)", *p)
}

func (p *ClusterQueryArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterQueryArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterQueryArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type ClusterQueryResult struct {
	Success *QueryResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterQueryResult() *ClusterQueryResult {
	return &ClusterQueryResult{}
}

var ClusterQueryResult_Success_DEFAULT *QueryResult_

func (p *ClusterQueryResult) GetSuccess() *QueryResult_ {
	if !p.IsSetSuccess() {
		return ClusterQueryResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterQueryResult_Err_DEFAULT *Error

func (p *ClusterQueryResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterQueryResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterQueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterQueryResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterQueryResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterQueryResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &QueryResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterQueryResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterQueryResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "query_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterQueryResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterQueryResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterQueryResult(%+v)", *p)
}

func (p *ClusterQueryResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterQueryResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterQueryResult)(nil)

// Attributes:
//  - Req
// 
type ClusterAggregateArgs struct {
	Req *AggregateQueryRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterAggregateArgs() *ClusterAggregateArgs {
	return &ClusterAggregateArgs{}
}

var ClusterAggregateArgs_Req_DEFAULT *AggregateQueryRequest

func (p *ClusterAggregateArgs) GetReq() *AggregateQueryRequest {
	if !p.IsSetReq() {
		return ClusterAggregateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterAggregateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterAggregateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterAggregateArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &AggregateQueryRequest{
		AggregateQueryType: 1,
		RangeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterAggregateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterAggregateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterAggregateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterAggregateArgs(%+v)", *p)
}

func (p *ClusterAggregateArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterAggregateArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterAggregateArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type ClusterAggregateResult struct {
	Success *AggregateQueryResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterAggregateResult() *ClusterAggregateResult {
	return &ClusterAggregateResult{}
}

var ClusterAggregateResult_Success_DEFAULT *AggregateQueryResult_

func (p *ClusterAggregateResult) GetSuccess() *AggregateQueryResult_ {
	if !p.IsSetSuccess() {
		return ClusterAggregateResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterAggregateResult_Err_DEFAULT *Error

func (p *ClusterAggregateResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterAggregateResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterAggregateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterAggregateResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterAggregateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterAggregateResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &AggregateQueryResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterAggregateResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterAggregateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "aggregate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterAggregateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterAggregateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterAggregateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterAggregateResult(%+v)", *p)
}

func (p *ClusterAggregateResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterAggregateResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterAggregateResult)(nil)

// Attributes:
//  - Req
// 
type ClusterFetchArgs struct {
	Req *FetchRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterFetchArgs() *ClusterFetchArgs {
	return &ClusterFetchArgs{}
}

var ClusterFetchArgs_Req_DEFAULT *FetchRequest

func (p *ClusterFetchArgs) GetReq() *FetchRequest {
	if !p.IsSetReq() {
		return ClusterFetchArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterFetchArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterFetchArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterFetchArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &FetchRequest{
		RangeType: 0,
		ResultTimeType: 0,
	}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterFetchArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetch_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterFetchArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterFetchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterFetchArgs(%+v)", *p)
}

func (p *ClusterFetchArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterFetchArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterFetchArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type ClusterFetchResult struct {
	Success *FetchResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterFetchResult() *ClusterFetchResult {
	return &ClusterFetchResult{}
}

var ClusterFetchResult_Success_DEFAULT *FetchResult_

func (p *ClusterFetchResult) GetSuccess() *FetchResult_ {
	if !p.IsSetSuccess() {
		return ClusterFetchResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterFetchResult_Err_DEFAULT *Error

func (p *ClusterFetchResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterFetchResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterFetchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterFetchResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterFetchResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterFetchResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &FetchResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterFetchResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterFetchResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "fetch_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterFetchResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterFetchResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterFetchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterFetchResult(%+v)", *p)
}

func (p *ClusterFetchResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterFetchResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterFetchResult)(nil)

// Attributes:
//  - Req
// 
type ClusterTruncateArgs struct {
	Req *TruncateRequest `thrift:"req,1" db:"req" json:"req"`
}

func NewClusterTruncateArgs() *ClusterTruncateArgs {
	return &ClusterTruncateArgs{}
}

var ClusterTruncateArgs_Req_DEFAULT *TruncateRequest

func (p *ClusterTruncateArgs) GetReq() *TruncateRequest {
	if !p.IsSetReq() {
		return ClusterTruncateArgs_Req_DEFAULT
	}
	return p.Req
}

func (p *ClusterTruncateArgs) IsSetReq() bool {
	return p.Req != nil
}

func (p *ClusterTruncateArgs) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterTruncateArgs) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Req = &TruncateRequest{}
	if err := p.Req.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Req), err)
	}
	return nil
}

func (p *ClusterTruncateArgs) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncate_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterTruncateArgs) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin(ctx, "req", thrift.STRUCT, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:req: ", p), err)
	}
	if err := p.Req.Write(ctx, oprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Req), err)
	}
	if err := oprot.WriteFieldEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:req: ", p), err)
	}
	return err
}

func (p *ClusterTruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterTruncateArgs(%+v)", *p)
}

func (p *ClusterTruncateArgs) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterTruncateArgs",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterTruncateArgs)(nil)

// Attributes:
//  - Success
//  - Err
// 
type ClusterTruncateResult struct {
	Success *TruncateResult_ `thrift:"success,0" db:"success" json:"success,omitempty"`
	Err *Error `thrift:"err,1" db:"err" json:"err,omitempty"`
}

func NewClusterTruncateResult() *ClusterTruncateResult {
	return &ClusterTruncateResult{}
}

var ClusterTruncateResult_Success_DEFAULT *TruncateResult_

func (p *ClusterTruncateResult) GetSuccess() *TruncateResult_ {
	if !p.IsSetSuccess() {
		return ClusterTruncateResult_Success_DEFAULT
	}
	return p.Success
}

var ClusterTruncateResult_Err_DEFAULT *Error

func (p *ClusterTruncateResult) GetErr() *Error {
	if !p.IsSetErr() {
		return ClusterTruncateResult_Err_DEFAULT
	}
	return p.Err
}

func (p *ClusterTruncateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ClusterTruncateResult) IsSetErr() bool {
	return p.Err != nil
}

func (p *ClusterTruncateResult) Read(ctx context.Context, iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}


	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin(ctx)
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField0(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		case 1:
			if fieldTypeId == thrift.STRUCT {
				if err := p.ReadField1(ctx, iprot); err != nil {
					return err
				}
			} else {
				if err := iprot.Skip(ctx, fieldTypeId); err != nil {
					return err
				}
			}
		default:
			if err := iprot.Skip(ctx, fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(ctx); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(ctx); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *ClusterTruncateResult) ReadField0(ctx context.Context, iprot thrift.TProtocol) error {
	p.Success = &TruncateResult_{}
	if err := p.Success.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *ClusterTruncateResult) ReadField1(ctx context.Context, iprot thrift.TProtocol) error {
	p.Err = &Error{
		Type: 0,
	}
	if err := p.Err.Read(ctx, iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Err), err)
	}
	return nil
}

func (p *ClusterTruncateResult) Write(ctx context.Context, oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin(ctx, "truncate_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if p != nil {
		if err := p.writeField0(ctx, oprot); err != nil { return err }
		if err := p.writeField1(ctx, oprot); err != nil { return err }
	}
	if err := oprot.WriteFieldStop(ctx); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(ctx); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *ClusterTruncateResult) writeField0(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin(ctx, "success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *ClusterTruncateResult) writeField1(ctx context.Context, oprot thrift.TProtocol) (err error) {
	if p.IsSetErr() {
		if err := oprot.WriteFieldBegin(ctx, "err", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:err: ", p), err)
		}
		if err := p.Err.Write(ctx, oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Err), err)
		}
		if err := oprot.WriteFieldEnd(ctx); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:err: ", p), err)
		}
	}
	return err
}

func (p *ClusterTruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ClusterTruncateResult(%+v)", *p)
}

func (p *ClusterTruncateResult) LogValue() slog.Value {
	if p == nil {
		return slog.AnyValue(nil)
	}
	v := thrift.SlogTStructWrapper{
		Type: "*rpc.ClusterTruncateResult",
		Value: p,
	}
	return slog.AnyValue(v)
}

var _ slog.LogValuer = (*ClusterTruncateResult)(nil)


