// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/m3db/m3/src/dbnode/storage/index (interfaces: Results,Block,OnIndexSeries)

// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Package index is a generated GoMock package.
package index

import (
	"reflect"
	"time"

	"github.com/m3db/m3/src/dbnode/storage/bootstrap/result"
	"github.com/m3db/m3/src/m3ninx/doc"
	"github.com/m3db/m3x/context"
	"github.com/m3db/m3x/ident"
	time0 "github.com/m3db/m3x/time"

	"github.com/golang/mock/gomock"
)

// MockResults is a mock of Results interface
type MockResults struct {
	ctrl     *gomock.Controller
	recorder *MockResultsMockRecorder
}

// MockResultsMockRecorder is the mock recorder for MockResults
type MockResultsMockRecorder struct {
	mock *MockResults
}

// NewMockResults creates a new mock instance
func NewMockResults(ctrl *gomock.Controller) *MockResults {
	mock := &MockResults{ctrl: ctrl}
	mock.recorder = &MockResultsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockResults) EXPECT() *MockResultsMockRecorder {
	return m.recorder
}

// Add mocks base method
func (m *MockResults) Add(arg0 doc.Document) (bool, int, error) {
	ret := m.ctrl.Call(m, "Add", arg0)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(int)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// Add indicates an expected call of Add
func (mr *MockResultsMockRecorder) Add(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockResults)(nil).Add), arg0)
}

// Finalize mocks base method
func (m *MockResults) Finalize() {
	m.ctrl.Call(m, "Finalize")
}

// Finalize indicates an expected call of Finalize
func (mr *MockResultsMockRecorder) Finalize() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Finalize", reflect.TypeOf((*MockResults)(nil).Finalize))
}

// Map mocks base method
func (m *MockResults) Map() *ResultsMap {
	ret := m.ctrl.Call(m, "Map")
	ret0, _ := ret[0].(*ResultsMap)
	return ret0
}

// Map indicates an expected call of Map
func (mr *MockResultsMockRecorder) Map() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Map", reflect.TypeOf((*MockResults)(nil).Map))
}

// Namespace mocks base method
func (m *MockResults) Namespace() ident.ID {
	ret := m.ctrl.Call(m, "Namespace")
	ret0, _ := ret[0].(ident.ID)
	return ret0
}

// Namespace indicates an expected call of Namespace
func (mr *MockResultsMockRecorder) Namespace() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Namespace", reflect.TypeOf((*MockResults)(nil).Namespace))
}

// Reset mocks base method
func (m *MockResults) Reset(arg0 ident.ID) {
	m.ctrl.Call(m, "Reset", arg0)
}

// Reset indicates an expected call of Reset
func (mr *MockResultsMockRecorder) Reset(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Reset", reflect.TypeOf((*MockResults)(nil).Reset), arg0)
}

// Size mocks base method
func (m *MockResults) Size() int {
	ret := m.ctrl.Call(m, "Size")
	ret0, _ := ret[0].(int)
	return ret0
}

// Size indicates an expected call of Size
func (mr *MockResultsMockRecorder) Size() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Size", reflect.TypeOf((*MockResults)(nil).Size))
}

// MockBlock is a mock of Block interface
type MockBlock struct {
	ctrl     *gomock.Controller
	recorder *MockBlockMockRecorder
}

// MockBlockMockRecorder is the mock recorder for MockBlock
type MockBlockMockRecorder struct {
	mock *MockBlock
}

// NewMockBlock creates a new mock instance
func NewMockBlock(ctrl *gomock.Controller) *MockBlock {
	mock := &MockBlock{ctrl: ctrl}
	mock.recorder = &MockBlockMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockBlock) EXPECT() *MockBlockMockRecorder {
	return m.recorder
}

// AddResults mocks base method
func (m *MockBlock) AddResults(arg0 result.IndexBlock) error {
	ret := m.ctrl.Call(m, "AddResults", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// AddResults indicates an expected call of AddResults
func (mr *MockBlockMockRecorder) AddResults(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddResults", reflect.TypeOf((*MockBlock)(nil).AddResults), arg0)
}

// Close mocks base method
func (m *MockBlock) Close() error {
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockBlockMockRecorder) Close() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockBlock)(nil).Close))
}

// EndTime mocks base method
func (m *MockBlock) EndTime() time.Time {
	ret := m.ctrl.Call(m, "EndTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// EndTime indicates an expected call of EndTime
func (mr *MockBlockMockRecorder) EndTime() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EndTime", reflect.TypeOf((*MockBlock)(nil).EndTime))
}

// EvictActiveSegments mocks base method
func (m *MockBlock) EvictActiveSegments() (EvictActiveSegmentResults, error) {
	ret := m.ctrl.Call(m, "EvictActiveSegments")
	ret0, _ := ret[0].(EvictActiveSegmentResults)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// EvictActiveSegments indicates an expected call of EvictActiveSegments
func (mr *MockBlockMockRecorder) EvictActiveSegments() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EvictActiveSegments", reflect.TypeOf((*MockBlock)(nil).EvictActiveSegments))
}

// IsSealed mocks base method
func (m *MockBlock) IsSealed() bool {
	ret := m.ctrl.Call(m, "IsSealed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsSealed indicates an expected call of IsSealed
func (mr *MockBlockMockRecorder) IsSealed() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsSealed", reflect.TypeOf((*MockBlock)(nil).IsSealed))
}

// NeedsFlush mocks base method
func (m *MockBlock) NeedsFlush() bool {
	ret := m.ctrl.Call(m, "NeedsFlush")
	ret0, _ := ret[0].(bool)
	return ret0
}

// NeedsFlush indicates an expected call of NeedsFlush
func (mr *MockBlockMockRecorder) NeedsFlush() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NeedsFlush", reflect.TypeOf((*MockBlock)(nil).NeedsFlush))
}

// Query mocks base method
func (m *MockBlock) Query(arg0 Query, arg1 QueryOptions, arg2 Results) (bool, error) {
	ret := m.ctrl.Call(m, "Query", arg0, arg1, arg2)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Query indicates an expected call of Query
func (mr *MockBlockMockRecorder) Query(arg0, arg1, arg2 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Query", reflect.TypeOf((*MockBlock)(nil).Query), arg0, arg1, arg2)
}

// Seal mocks base method
func (m *MockBlock) Seal() error {
	ret := m.ctrl.Call(m, "Seal")
	ret0, _ := ret[0].(error)
	return ret0
}

// Seal indicates an expected call of Seal
func (mr *MockBlockMockRecorder) Seal() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Seal", reflect.TypeOf((*MockBlock)(nil).Seal))
}

// StartTime mocks base method
func (m *MockBlock) StartTime() time.Time {
	ret := m.ctrl.Call(m, "StartTime")
	ret0, _ := ret[0].(time.Time)
	return ret0
}

// StartTime indicates an expected call of StartTime
func (mr *MockBlockMockRecorder) StartTime() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "StartTime", reflect.TypeOf((*MockBlock)(nil).StartTime))
}

// Stats mocks base method
func (m *MockBlock) Stats() BlockStats {
	ret := m.ctrl.Call(m, "Stats")
	ret0, _ := ret[0].(BlockStats)
	return ret0
}

// Stats indicates an expected call of Stats
func (mr *MockBlockMockRecorder) Stats() *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stats", reflect.TypeOf((*MockBlock)(nil).Stats))
}

// Tick mocks base method
func (m *MockBlock) Tick(arg0 context.Cancellable, arg1 time.Time) (BlockTickResult, error) {
	ret := m.ctrl.Call(m, "Tick", arg0, arg1)
	ret0, _ := ret[0].(BlockTickResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Tick indicates an expected call of Tick
func (mr *MockBlockMockRecorder) Tick(arg0, arg1 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Tick", reflect.TypeOf((*MockBlock)(nil).Tick), arg0, arg1)
}

// WriteBatch mocks base method
func (m *MockBlock) WriteBatch(arg0 *WriteBatch) (WriteBatchResult, error) {
	ret := m.ctrl.Call(m, "WriteBatch", arg0)
	ret0, _ := ret[0].(WriteBatchResult)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// WriteBatch indicates an expected call of WriteBatch
func (mr *MockBlockMockRecorder) WriteBatch(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteBatch", reflect.TypeOf((*MockBlock)(nil).WriteBatch), arg0)
}

// MockOnIndexSeries is a mock of OnIndexSeries interface
type MockOnIndexSeries struct {
	ctrl     *gomock.Controller
	recorder *MockOnIndexSeriesMockRecorder
}

// MockOnIndexSeriesMockRecorder is the mock recorder for MockOnIndexSeries
type MockOnIndexSeriesMockRecorder struct {
	mock *MockOnIndexSeries
}

// NewMockOnIndexSeries creates a new mock instance
func NewMockOnIndexSeries(ctrl *gomock.Controller) *MockOnIndexSeries {
	mock := &MockOnIndexSeries{ctrl: ctrl}
	mock.recorder = &MockOnIndexSeriesMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockOnIndexSeries) EXPECT() *MockOnIndexSeriesMockRecorder {
	return m.recorder
}

// OnIndexFinalize mocks base method
func (m *MockOnIndexSeries) OnIndexFinalize(arg0 time0.UnixNano) {
	m.ctrl.Call(m, "OnIndexFinalize", arg0)
}

// OnIndexFinalize indicates an expected call of OnIndexFinalize
func (mr *MockOnIndexSeriesMockRecorder) OnIndexFinalize(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnIndexFinalize", reflect.TypeOf((*MockOnIndexSeries)(nil).OnIndexFinalize), arg0)
}

// OnIndexSuccess mocks base method
func (m *MockOnIndexSeries) OnIndexSuccess(arg0 time0.UnixNano) {
	m.ctrl.Call(m, "OnIndexSuccess", arg0)
}

// OnIndexSuccess indicates an expected call of OnIndexSuccess
func (mr *MockOnIndexSeriesMockRecorder) OnIndexSuccess(arg0 interface{}) *gomock.Call {
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "OnIndexSuccess", reflect.TypeOf((*MockOnIndexSeries)(nil).OnIndexSuccess), arg0)
}
