// Code generated by MockGen. DO NOT EDIT.
// Source: ../../storage/limits/types.go

// Copyright (c) 2025 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Package limits is a generated GoMock package.
package limits

import (
	"reflect"

	"github.com/m3db/m3/src/x/instrument"

	"github.com/golang/mock/gomock"
)

// MockQueryLimits is a mock of QueryLimits interface.
type MockQueryLimits struct {
	ctrl     *gomock.Controller
	recorder *MockQueryLimitsMockRecorder
}

// MockQueryLimitsMockRecorder is the mock recorder for MockQueryLimits.
type MockQueryLimitsMockRecorder struct {
	mock *MockQueryLimits
}

// NewMockQueryLimits creates a new mock instance.
func NewMockQueryLimits(ctrl *gomock.Controller) *MockQueryLimits {
	mock := &MockQueryLimits{ctrl: ctrl}
	mock.recorder = &MockQueryLimitsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueryLimits) EXPECT() *MockQueryLimitsMockRecorder {
	return m.recorder
}

// AggregateDocsLimit mocks base method.
func (m *MockQueryLimits) AggregateDocsLimit() LookbackLimit {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AggregateDocsLimit")
	ret0, _ := ret[0].(LookbackLimit)
	return ret0
}

// AggregateDocsLimit indicates an expected call of AggregateDocsLimit.
func (mr *MockQueryLimitsMockRecorder) AggregateDocsLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregateDocsLimit", reflect.TypeOf((*MockQueryLimits)(nil).AggregateDocsLimit))
}

// AnyFetchExceeded mocks base method.
func (m *MockQueryLimits) AnyFetchExceeded() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AnyFetchExceeded")
	ret0, _ := ret[0].(error)
	return ret0
}

// AnyFetchExceeded indicates an expected call of AnyFetchExceeded.
func (mr *MockQueryLimitsMockRecorder) AnyFetchExceeded() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AnyFetchExceeded", reflect.TypeOf((*MockQueryLimits)(nil).AnyFetchExceeded))
}

// BytesReadLimit mocks base method.
func (m *MockQueryLimits) BytesReadLimit() LookbackLimit {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BytesReadLimit")
	ret0, _ := ret[0].(LookbackLimit)
	return ret0
}

// BytesReadLimit indicates an expected call of BytesReadLimit.
func (mr *MockQueryLimitsMockRecorder) BytesReadLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BytesReadLimit", reflect.TypeOf((*MockQueryLimits)(nil).BytesReadLimit))
}

// FetchDocsLimit mocks base method.
func (m *MockQueryLimits) FetchDocsLimit() LookbackLimit {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FetchDocsLimit")
	ret0, _ := ret[0].(LookbackLimit)
	return ret0
}

// FetchDocsLimit indicates an expected call of FetchDocsLimit.
func (mr *MockQueryLimitsMockRecorder) FetchDocsLimit() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FetchDocsLimit", reflect.TypeOf((*MockQueryLimits)(nil).FetchDocsLimit))
}

// Start mocks base method.
func (m *MockQueryLimits) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockQueryLimitsMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockQueryLimits)(nil).Start))
}

// Stop mocks base method.
func (m *MockQueryLimits) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockQueryLimitsMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockQueryLimits)(nil).Stop))
}

// MockLookbackLimit is a mock of LookbackLimit interface.
type MockLookbackLimit struct {
	ctrl     *gomock.Controller
	recorder *MockLookbackLimitMockRecorder
}

// MockLookbackLimitMockRecorder is the mock recorder for MockLookbackLimit.
type MockLookbackLimitMockRecorder struct {
	mock *MockLookbackLimit
}

// NewMockLookbackLimit creates a new mock instance.
func NewMockLookbackLimit(ctrl *gomock.Controller) *MockLookbackLimit {
	mock := &MockLookbackLimit{ctrl: ctrl}
	mock.recorder = &MockLookbackLimitMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockLookbackLimit) EXPECT() *MockLookbackLimitMockRecorder {
	return m.recorder
}

// Inc mocks base method.
func (m *MockLookbackLimit) Inc(new int, source []byte) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Inc", new, source)
	ret0, _ := ret[0].(error)
	return ret0
}

// Inc indicates an expected call of Inc.
func (mr *MockLookbackLimitMockRecorder) Inc(new, source interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Inc", reflect.TypeOf((*MockLookbackLimit)(nil).Inc), new, source)
}

// Options mocks base method.
func (m *MockLookbackLimit) Options() LookbackLimitOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Options")
	ret0, _ := ret[0].(LookbackLimitOptions)
	return ret0
}

// Options indicates an expected call of Options.
func (mr *MockLookbackLimitMockRecorder) Options() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Options", reflect.TypeOf((*MockLookbackLimit)(nil).Options))
}

// Start mocks base method.
func (m *MockLookbackLimit) Start() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start")
}

// Start indicates an expected call of Start.
func (mr *MockLookbackLimitMockRecorder) Start() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockLookbackLimit)(nil).Start))
}

// Stop mocks base method.
func (m *MockLookbackLimit) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockLookbackLimitMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockLookbackLimit)(nil).Stop))
}

// Update mocks base method.
func (m *MockLookbackLimit) Update(opts LookbackLimitOptions) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Update", opts)
	ret0, _ := ret[0].(error)
	return ret0
}

// Update indicates an expected call of Update.
func (mr *MockLookbackLimitMockRecorder) Update(opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Update", reflect.TypeOf((*MockLookbackLimit)(nil).Update), opts)
}

// MockSourceLoggerBuilder is a mock of SourceLoggerBuilder interface.
type MockSourceLoggerBuilder struct {
	ctrl     *gomock.Controller
	recorder *MockSourceLoggerBuilderMockRecorder
}

// MockSourceLoggerBuilderMockRecorder is the mock recorder for MockSourceLoggerBuilder.
type MockSourceLoggerBuilderMockRecorder struct {
	mock *MockSourceLoggerBuilder
}

// NewMockSourceLoggerBuilder creates a new mock instance.
func NewMockSourceLoggerBuilder(ctrl *gomock.Controller) *MockSourceLoggerBuilder {
	mock := &MockSourceLoggerBuilder{ctrl: ctrl}
	mock.recorder = &MockSourceLoggerBuilderMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSourceLoggerBuilder) EXPECT() *MockSourceLoggerBuilderMockRecorder {
	return m.recorder
}

// NewSourceLogger mocks base method.
func (m *MockSourceLoggerBuilder) NewSourceLogger(name string, opts instrument.Options) SourceLogger {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NewSourceLogger", name, opts)
	ret0, _ := ret[0].(SourceLogger)
	return ret0
}

// NewSourceLogger indicates an expected call of NewSourceLogger.
func (mr *MockSourceLoggerBuilderMockRecorder) NewSourceLogger(name, opts interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NewSourceLogger", reflect.TypeOf((*MockSourceLoggerBuilder)(nil).NewSourceLogger), name, opts)
}

// MockSourceLogger is a mock of SourceLogger interface.
type MockSourceLogger struct {
	ctrl     *gomock.Controller
	recorder *MockSourceLoggerMockRecorder
}

// MockSourceLoggerMockRecorder is the mock recorder for MockSourceLogger.
type MockSourceLoggerMockRecorder struct {
	mock *MockSourceLogger
}

// NewMockSourceLogger creates a new mock instance.
func NewMockSourceLogger(ctrl *gomock.Controller) *MockSourceLogger {
	mock := &MockSourceLogger{ctrl: ctrl}
	mock.recorder = &MockSourceLoggerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockSourceLogger) EXPECT() *MockSourceLoggerMockRecorder {
	return m.recorder
}

// LogSourceValue mocks base method.
func (m *MockSourceLogger) LogSourceValue(val int64, source []byte) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "LogSourceValue", val, source)
}

// LogSourceValue indicates an expected call of LogSourceValue.
func (mr *MockSourceLoggerMockRecorder) LogSourceValue(val, source interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LogSourceValue", reflect.TypeOf((*MockSourceLogger)(nil).LogSourceValue), val, source)
}

// MockOptions is a mock of Options interface.
type MockOptions struct {
	ctrl     *gomock.Controller
	recorder *MockOptionsMockRecorder
}

// MockOptionsMockRecorder is the mock recorder for MockOptions.
type MockOptionsMockRecorder struct {
	mock *MockOptions
}

// NewMockOptions creates a new mock instance.
func NewMockOptions(ctrl *gomock.Controller) *MockOptions {
	mock := &MockOptions{ctrl: ctrl}
	mock.recorder = &MockOptionsMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOptions) EXPECT() *MockOptionsMockRecorder {
	return m.recorder
}

// AggregateDocsLimitOpts mocks base method.
func (m *MockOptions) AggregateDocsLimitOpts() LookbackLimitOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AggregateDocsLimitOpts")
	ret0, _ := ret[0].(LookbackLimitOptions)
	return ret0
}

// AggregateDocsLimitOpts indicates an expected call of AggregateDocsLimitOpts.
func (mr *MockOptionsMockRecorder) AggregateDocsLimitOpts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AggregateDocsLimitOpts", reflect.TypeOf((*MockOptions)(nil).AggregateDocsLimitOpts))
}

// BytesReadLimitOpts mocks base method.
func (m *MockOptions) BytesReadLimitOpts() LookbackLimitOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BytesReadLimitOpts")
	ret0, _ := ret[0].(LookbackLimitOptions)
	return ret0
}

// BytesReadLimitOpts indicates an expected call of BytesReadLimitOpts.
func (mr *MockOptionsMockRecorder) BytesReadLimitOpts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BytesReadLimitOpts", reflect.TypeOf((*MockOptions)(nil).BytesReadLimitOpts))
}

// DiskSeriesReadLimitOpts mocks base method.
func (m *MockOptions) DiskSeriesReadLimitOpts() LookbackLimitOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DiskSeriesReadLimitOpts")
	ret0, _ := ret[0].(LookbackLimitOptions)
	return ret0
}

// DiskSeriesReadLimitOpts indicates an expected call of DiskSeriesReadLimitOpts.
func (mr *MockOptionsMockRecorder) DiskSeriesReadLimitOpts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DiskSeriesReadLimitOpts", reflect.TypeOf((*MockOptions)(nil).DiskSeriesReadLimitOpts))
}

// DocsLimitOpts mocks base method.
func (m *MockOptions) DocsLimitOpts() LookbackLimitOptions {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DocsLimitOpts")
	ret0, _ := ret[0].(LookbackLimitOptions)
	return ret0
}

// DocsLimitOpts indicates an expected call of DocsLimitOpts.
func (mr *MockOptionsMockRecorder) DocsLimitOpts() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DocsLimitOpts", reflect.TypeOf((*MockOptions)(nil).DocsLimitOpts))
}

// InstrumentOptions mocks base method.
func (m *MockOptions) InstrumentOptions() instrument.Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "InstrumentOptions")
	ret0, _ := ret[0].(instrument.Options)
	return ret0
}

// InstrumentOptions indicates an expected call of InstrumentOptions.
func (mr *MockOptionsMockRecorder) InstrumentOptions() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "InstrumentOptions", reflect.TypeOf((*MockOptions)(nil).InstrumentOptions))
}

// SetAggregateDocsLimitOpts mocks base method.
func (m *MockOptions) SetAggregateDocsLimitOpts(arg0 LookbackLimitOptions) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetAggregateDocsLimitOpts", arg0)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetAggregateDocsLimitOpts indicates an expected call of SetAggregateDocsLimitOpts.
func (mr *MockOptionsMockRecorder) SetAggregateDocsLimitOpts(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetAggregateDocsLimitOpts", reflect.TypeOf((*MockOptions)(nil).SetAggregateDocsLimitOpts), arg0)
}

// SetBytesReadLimitOpts mocks base method.
func (m *MockOptions) SetBytesReadLimitOpts(value LookbackLimitOptions) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetBytesReadLimitOpts", value)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetBytesReadLimitOpts indicates an expected call of SetBytesReadLimitOpts.
func (mr *MockOptionsMockRecorder) SetBytesReadLimitOpts(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetBytesReadLimitOpts", reflect.TypeOf((*MockOptions)(nil).SetBytesReadLimitOpts), value)
}

// SetDiskSeriesReadLimitOpts mocks base method.
func (m *MockOptions) SetDiskSeriesReadLimitOpts(value LookbackLimitOptions) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDiskSeriesReadLimitOpts", value)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetDiskSeriesReadLimitOpts indicates an expected call of SetDiskSeriesReadLimitOpts.
func (mr *MockOptionsMockRecorder) SetDiskSeriesReadLimitOpts(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDiskSeriesReadLimitOpts", reflect.TypeOf((*MockOptions)(nil).SetDiskSeriesReadLimitOpts), value)
}

// SetDocsLimitOpts mocks base method.
func (m *MockOptions) SetDocsLimitOpts(value LookbackLimitOptions) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetDocsLimitOpts", value)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetDocsLimitOpts indicates an expected call of SetDocsLimitOpts.
func (mr *MockOptionsMockRecorder) SetDocsLimitOpts(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetDocsLimitOpts", reflect.TypeOf((*MockOptions)(nil).SetDocsLimitOpts), value)
}

// SetInstrumentOptions mocks base method.
func (m *MockOptions) SetInstrumentOptions(value instrument.Options) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetInstrumentOptions", value)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetInstrumentOptions indicates an expected call of SetInstrumentOptions.
func (mr *MockOptionsMockRecorder) SetInstrumentOptions(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetInstrumentOptions", reflect.TypeOf((*MockOptions)(nil).SetInstrumentOptions), value)
}

// SetSourceLoggerBuilder mocks base method.
func (m *MockOptions) SetSourceLoggerBuilder(value SourceLoggerBuilder) Options {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SetSourceLoggerBuilder", value)
	ret0, _ := ret[0].(Options)
	return ret0
}

// SetSourceLoggerBuilder indicates an expected call of SetSourceLoggerBuilder.
func (mr *MockOptionsMockRecorder) SetSourceLoggerBuilder(value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetSourceLoggerBuilder", reflect.TypeOf((*MockOptions)(nil).SetSourceLoggerBuilder), value)
}

// SourceLoggerBuilder mocks base method.
func (m *MockOptions) SourceLoggerBuilder() SourceLoggerBuilder {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SourceLoggerBuilder")
	ret0, _ := ret[0].(SourceLoggerBuilder)
	return ret0
}

// SourceLoggerBuilder indicates an expected call of SourceLoggerBuilder.
func (mr *MockOptionsMockRecorder) SourceLoggerBuilder() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SourceLoggerBuilder", reflect.TypeOf((*MockOptions)(nil).SourceLoggerBuilder))
}

// Validate mocks base method.
func (m *MockOptions) Validate() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Validate")
	ret0, _ := ret[0].(error)
	return ret0
}

// Validate indicates an expected call of Validate.
func (mr *MockOptionsMockRecorder) Validate() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Validate", reflect.TypeOf((*MockOptions)(nil).Validate))
}
