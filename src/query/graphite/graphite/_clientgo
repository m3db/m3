package graphite

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strconv"
	"time"

	"code.uber.internal/go-common.git/x/log"
	"code.uber.internal/go-common.git/x/metrics"
)

const (
	// MIMETypeApplicationPickle defines the MIME type for application/pickle content
	MIMETypeApplicationPickle = "application/pickle"
	httpClientTimeout         = time.Second * 30
)

// A Client is able to talk to a graphite server
type Client interface {
	RenderJSON(targets []string, from, to time.Time, opts *RenderOptions) (Results, error)
	RenderPickle(targets []string, from, to time.Time, opts *RenderOptions) ([]RenderResultsPickle, error)
	FindMetrics(path string, opts *FindOptions) (*FindResultsCompleterJSON, error)
	Fetch(targets []string, from, to time.Time, format string, opts *RenderOptions) (io.ReadCloser, error)
}

type client struct {
	url         *url.URL
	oauthCookie *http.Cookie
	httpClient  *http.Client
	metrics     clientMetrics
}

type clientMetrics struct {
	jsonRenders   *metrics.InstrumentedCall
	pickleRenders *metrics.InstrumentedCall
	m3tsRenders   *metrics.InstrumentedCall
}

// ClientOptions control options applicable to the client as a whole
type ClientOptions struct {
	// The oauth token to use to authenticate externalls
	OAuthToken string
}

// NewClient creates a new graphite client given a server URL and options
func NewClient(u string, ms metrics.Scope, opts *ClientOptions) (Client, error) {
	serverURL, err := url.Parse(u)
	if err != nil {
		return nil, err
	}

	if opts == nil {
		opts = &ClientOptions{}
	}

	client := &client{
		url: serverURL,
		httpClient: &http.Client{
			Timeout: httpClientTimeout,
			Transport: &http.Transport{
				MaxIdleConnsPerHost: 20,
			},
		},
		metrics: clientMetrics{
			jsonRenders:   ms.Scope("renders").InstrumentedCall("json"),
			pickleRenders: ms.Scope("renders").InstrumentedCall("pickle"),
			m3tsRenders:   ms.Scope("renders").InstrumentedCall("m3ts"),
		},
	}

	if opts.OAuthToken != "" {
		client.oauthCookie = &http.Cookie{Name: "auth-openid", Value: opts.OAuthToken}
	}

	return client, nil

}

// String returns a debug string for the client
func (c *client) String() string { return c.url.String() }

// RenderOptions tell graphite how to pull results for rendering
type RenderOptions struct {
	// If true, tells graphite to only consult locally accessible storage, not the cluster
	LocalOnly bool

	// If true, tells graphite to bypass any caching
	NoCache bool
}

// FindOptions tell graphite how to pull find results
type FindOptions RenderOptions

// RenderPickle fetches a set of results from graphite in block format
// (step, size, values) using the using the pickle protocol
func (c *client) RenderPickle(
	targets []string,
	from, to time.Time,
	opts *RenderOptions) ([]RenderResultsPickle, error) {
	var b []byte
	var p []RenderResultsPickle
	var err error
	if err := c.metrics.pickleRenders.Exec(func() error {
		b, err = c.fetch(targets, from, to, "pickle", opts)
		if err != nil {
			return err
		}

		p, err = ParseRenderResultsPickle(b)
		return err
	}); err != nil {
		return nil, err
	}

	log.Debugf("Received %d results from %s", len(p), c.url)
	return p, nil
}

// RenderJSON fetches a set of results from graphite in timestamp format using the json protocol
func (c *client) RenderJSON(
	targets []string,
	from, to time.Time,
	opts *RenderOptions) (Results, error) {
	var b []byte
	var err error
	if err := c.metrics.jsonRenders.Exec(func() error {
		b, err = c.fetch(targets, from, to, "json", opts)
		return err
	}); err != nil {
		return nil, err
	}

	return ParseJSONResponse(b)
}

// FindMetrics issues a find call to the graphite server
func (c *client) FindMetrics(query string, opts *FindOptions) (*FindResultsCompleterJSON, error) {
	if opts == nil {
		opts = &FindOptions{}
	}

	// NB(mmihic): We use completer format because pickle find format requires
	// marshaling python classes, and thus isn't supported by go
	q := url.Values{}
	q.Add("format", "completer")
	q.Add("query", query)
	if opts.NoCache {
		q.Add("noCache", "1")
	}

	if opts.LocalOnly {
		q.Add("local", "1")
	}

	q.Add("skipBlacklist", "1")

	url := *c.url
	url.Path = path.Join(c.url.Path, "metrics/find")
	url.RawQuery = q.Encode()

	data, err := c.get(&url)
	if err != nil {
		return nil, err
	}

	var results FindResultsCompleterJSON
	if err := json.Unmarshal(data, &results); err != nil {
		return nil, err
	}

	return &results, nil
}

func (c *client) Fetch(
	targets []string,
	from, to time.Time,
	format string,
	opts *RenderOptions) (io.ReadCloser, error) {

	q := url.Values{}
	q.Add("format", format)
	for _, target := range targets {
		q.Add("target", target)
	}

	q.Add("from", strconv.Itoa(int(from.Unix())-1)) // NB(mmihic): Graphite ranges are exclusive
	q.Add("until", strconv.Itoa(int(to.Unix())-1))

	if opts == nil {
		opts = &RenderOptions{}
	}

	if opts.NoCache {
		q.Add("noCache", "1")
	}

	if opts.LocalOnly {
		q.Add("local", "1")
	}

	q.Add("skipBlacklist", "1")

	reqURL := *c.url
	reqURL.Path = path.Join(c.url.Path, "render")
	reqURL.RawQuery = q.Encode()

	return c.getReader(&reqURL)
}

func (c *client) fetch(
	targets []string,
	from, to time.Time,
	format string,
	opts *RenderOptions) ([]byte, error) {

	r, err := c.Fetch(targets, from, to, format, opts)
	if err != nil {
		return nil, err
	}
	return c.getBytes(r)
}

func (c *client) getReader(url *url.URL) (io.ReadCloser, error) {
	req, err := http.NewRequest("GET", url.String(), nil)
	if err != nil {
		return nil, err
	}

	req.Header.Add("X-Uber-Source", "statsdex")

	if c.oauthCookie != nil {
		req.AddCookie(c.oauthCookie)
	}

	resp, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}

	if resp.StatusCode != 200 {
		b, _ := c.getBytes(resp.Body)
		return nil, fmt.Errorf("error %d from server: %s", resp.StatusCode, string(b))
	}

	return resp.Body, nil
}

func (c *client) get(url *url.URL) ([]byte, error) {
	r, err := c.getReader(url)
	if err != nil {
		return nil, err
	}

	return c.getBytes(r)
}

func (c *client) getBytes(r io.ReadCloser) ([]byte, error) {
	defer r.Close()

	b, err := ioutil.ReadAll(r)
	if err != nil {
		return nil, err
	}
	return b, nil
}
