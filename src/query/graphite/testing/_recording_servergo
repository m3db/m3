
package testing

import (
	"bytes"
	"context"
	"io"
	"io/ioutil"
	"net/http"
	"net/http/httptest"
	"net/http/httputil"
	"net/url"
	"regexp"
	"sync"
	"time"
)

// A RecordedRequest has information about a captured request
type RecordedRequest struct {
	Method  string
	URL     *url.URL
	Body    []byte
	Header  http.Header
	Cookies []*http.Cookie
	Raw     []byte
}

// A RequestRecorder can be used to capture information about incoming requests
// for the purpose of comparing them against other expectations
type RequestRecorder struct {
	sync.Mutex
	Requests []*RecordedRequest
}

// Record records information about an incoming request, returning the request body if needed
func (rr *RequestRecorder) Record(req *http.Request) ([]byte, error) {
	defer req.Body.Close()

	raw, err := httputil.DumpRequest(req, true)
	if err != nil {
		return nil, err
	}

	body, err := ioutil.ReadAll(req.Body)
	if err != nil {
		return nil, err
	}

	recorded := &RecordedRequest{
		URL:     req.URL,
		Method:  req.Method,
		Header:  req.Header,
		Body:    body,
		Cookies: req.Cookies(),
		Raw:     raw,
	}

	rr.Lock()
	defer rr.Unlock()
	rr.Requests = append(rr.Requests, recorded)
	return body, nil
}

// RecordingServer is a test HTTP server that captures requests and routes them
// to target handlers based on regexps and the like
type RecordingServer struct {
	RequestRecorder

	HTTPServer *httptest.Server
	Router     *Router
}

// ServeHTTP records the incoming request, then routes it through the router
func (s *RecordingServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	body, err := s.Record(r)
	if err != nil {
		panic(err)
	}
	r.Body = ioutil.NopCloser(bytes.NewReader(body))
	s.Router.ServeHTTP(w, r)
}

// Close closes the test server
func (s *RecordingServer) Close() {
	s.HTTPServer.Close()
}

// NewRecordingServer creates a new routing, recording HTTP server
func NewRecordingServer() *RecordingServer {
	server := new(RecordingServer)
	server.Router = NewRouter()
	server.HTTPServer = httptest.NewServer(server)
	return server
}

// Handler is a context-aware extension of http.Handler.
type Handler interface {
	ServeHTTP(ctx context.Context, w http.ResponseWriter, r *http.Request)
}

// ServeContentHandler returns an http.Handler that serves up the given static content.
// Note: Only one request can be served at a time when using this method.
func ServeContentHandler(name string, modtime time.Time, content io.ReadSeeker) http.Handler {
	var mu sync.Mutex
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		mu.Lock()
		defer mu.Unlock()

		http.ServeContent(w, r, name, modtime, content)
	})
}

// ServeBytesHandler returns a http.Handler that serves the given bytes.
func ServeBytesHandler(bs []byte) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, _ *http.Request) {
		w.Write(bs)
	})
}

// ErrorHandler returns an http.Handler that always responds with an error
func ErrorHandler(message string, code int) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		http.Error(w, message, code)
	})
}

// ServeFileHandler returns an http.Handler that serves a static file
func ServeFileHandler(filename string) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, filename)
	})
}

// A RequestMatcher is a matching predicate for an HTTP Request
type RequestMatcher func(r *http.Request) bool

// PathMatchesRegexp returns a matcher that evaluates the path against the given regexp
func PathMatchesRegexp(re *regexp.Regexp) RequestMatcher {
	return func(r *http.Request) bool {
		return re.MatchString(r.URL.Path)
	}
}

type route struct {
	matches RequestMatcher
	handler Handler
}

// Router is an HTTP handler that can route based on arbitrary RequestMatchers.
// It applies Filter (or filter chain) before invoking the actual routes.
// If the filter is nil, it uses DefaultFilter
type Router struct {
	mux    sync.RWMutex
	routes []route
	filter Filter
}

// NewRouter creates a new empty router
func NewRouter() *Router { return &Router{} }

// NewRouterWithFilter creates a new empty router with a pre-configured Filter or FilterChain
func NewRouterWithFilter(filter Filter) *Router {
	return &Router{filter: filter}
}

// ServeHTTP creates a new request Context, and runs the filter chain,
// eventually routing to the appropriate handler based on the incoming path.
func (h *Router) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	ctx := context.Background()
	filter := h.filter
	if filter == nil {
		filter = DefaultFilter
	}
	filter.Apply(ctx, w, r, h.selectHandler(r))
}

var _notFoundHandler = Wrap(http.NotFoundHandler())

// selectHandler routes to the appropriate handler based on the incoming path
func (h *Router) selectHandler(r *http.Request) Handler {
	h.mux.RLock()
	defer h.mux.RUnlock()

	for i := range h.routes {
		if h.routes[i].matches(r) {
			return h.routes[i].handler
		}
	}

	return _notFoundHandler
}

// Wrap converts plain http.Handler into xhttp.Handler.
// The context parameter is ignored when ServeHTTP is delegated to the plain http.Handler
func Wrap(handler http.Handler) Handler {
	return &plainHandlerWrapper{handler}
}

type plainHandlerWrapper struct {
	handler http.Handler
}

// ServeHTTP calls f(ctx, w, r).  The Context argument is ignored.
func (h *plainHandlerWrapper) ServeHTTP(_ context.Context, w http.ResponseWriter, r *http.Request) {
	h.handler.ServeHTTP(w, r)
}
